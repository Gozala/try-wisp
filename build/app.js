;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
{
    var _ns_ = {
            id: 'try-wisp.main',
            doc: void 0
        };
    var codemirrorActivine = require('codemirror-activine');
    var activine = codemirrorActivine;
    var codemirrorPersist = require('codemirror-persist');
    var persist = codemirrorPersist;
    var wisp_engine_browser = require('wisp/engine/browser');
    var wisp_sequence = require('wisp/sequence');
    var rest = wisp_sequence.rest;
    var cons = wisp_sequence.cons;
    var vec = wisp_sequence.vec;
    var wisp_runtime = require('wisp/runtime');
    var str = wisp_runtime.str;
    var wisp_reader = require('wisp/reader');
    var read_ = wisp_reader.read_;
    var wisp_compiler = require('wisp/compiler');
    var compile = wisp_compiler.compile;
}
persist(CodeMirror);
var throttle = exports.throttle = function throttle(lambda, ms) {
        return function () {
            var idø1 = 0;
            return function throttled() {
                var params = Array.prototype.slice.call(arguments, 0);
                clearTimeout(idø1, throttled);
                return idø1 = setTimeout.apply(window, vec(cons(lambda, cons(ms, params))));
            };
        }.call(this);
    };
var tooglePreview = exports.tooglePreview = function tooglePreview() {
        return function () {
            var outputø1 = document.getElementById('output');
            var inputø1 = document.getElementById('input');
            outputø1.hidden = !outputø1.hidden;
            return inputø1.style.width = outputø1.hidden ? '100%' : '50%';
        }.call(this);
    };
var _errorMarker_ = exports._errorMarker_ = function () {
        var viewø1 = document.createElement('span');
        viewø1.textContent = '\u25CF';
        viewø1.style.color = 'black';
        viewø1.style.opacity = '0.5';
        return viewø1;
    }.call(this);
var updatePreview = exports.updatePreview = throttle(function (editor) {
        editor.clearGutter('error-gutter');
        return function () {
            var codeø1 = editor.getValue();
            var resultø1 = compile(codeø1, { 'source-uri': 'scratch' });
            var errorø1 = (resultø1 || 0)['error'];
            localStorage.buffer = codeø1;
            return errorø1 ? (function () {
                localStorage.buffer = codeø1;
                _errorMarker_.setAttribute('title', errorø1.message);
                return editor.setGutterMarker(errorø1.line || 0, 'error-gutter', _errorMarker_);
            })() : output.setValue((resultø1 || 0)['code']);
        }.call(this);
    }, 200);
var input = exports.input = CodeMirror(document.getElementById('input'), {
        'lineNumbers': true,
        'matchBrackets': true,
        'electricChars': true,
        'persist': true,
        'styleActiveLine': true,
        'autofocus': true,
        'value': document.getElementById('examples').innerHTML,
        'theme': 'solarized dark',
        'mode': 'clojure',
        'autoClearEmptyLines': true,
        'fixedGutter': true,
        'gutters': ['error-gutter'],
        'extraKeys': { 'Tab': 'indentSelection' },
        'onChange': updatePreview,
        'onGutterClick': tooglePreview
    });
input.on('change', updatePreview);
input.on('gutterClick', tooglePreview);
updatePreview(input);
var output = exports.output = CodeMirror(document.getElementById('output'), {
        'lineNumbers': true,
        'fixedGutter': true,
        'matchBrackets': true,
        'mode': 'javascript',
        'theme': 'solarized dark',
        'readOnly': true
    });
},{"codemirror-activine":6,"codemirror-persist":7,"wisp/compiler":12,"wisp/engine/browser":13,"wisp/reader":32,"wisp/runtime":33,"wisp/sequence":34}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"PcZj9L":[function(require,module,exports){
var TA = require('typedarray')
var xDataView = typeof DataView === 'undefined'
  ? TA.DataView : DataView
var xArrayBuffer = typeof ArrayBuffer === 'undefined'
  ? TA.ArrayBuffer : ArrayBuffer
var xUint8Array = typeof Uint8Array === 'undefined'
  ? TA.Uint8Array : Uint8Array

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

var browserSupport

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 *
 * Firefox is a special case because it doesn't allow augmenting "native" object
 * instances. See `ProxyBuffer` below for more details.
 */
function Buffer (subject, encoding) {
  var type = typeof subject

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf = augment(new xUint8Array(length))
  if (Buffer.isBuffer(subject)) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf.set(subject)
  } else if (isArrayIsh(subject)) {
    // Treat array-ish objects as a byte array.
    for (var i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true

    default:
      return false
  }
}

Buffer.isBuffer = function isBuffer (b) {
  return b && b._isBuffer
}

Buffer.byteLength = function (str, encoding) {
  switch (encoding || 'utf8') {
    case 'hex':
      return str.length / 2

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length

    case 'ascii':
    case 'binary':
      return str.length

    case 'base64':
      return base64ToBytes(str).length

    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error('Usage: Buffer.concat(list, [totalLength])\n' +
        'list should be an Array.')
  }

  var i
  var buf

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      buf = list[i]
      totalLength += buf.length
    }
  }

  var buffer = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    buf = list[i]
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

// INSTANCE METHODS
// ================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) {
    throw new Error('Invalid hex string')
  }
  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
}

function _asciiWrite (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
}

function BufferWrite (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  switch (encoding) {
    case 'hex':
      return _hexWrite(this, string, offset, length)

    case 'utf8':
    case 'utf-8':
      return _utf8Write(this, string, offset, length)

    case 'ascii':
      return _asciiWrite(this, string, offset, length)

    case 'binary':
      return _binaryWrite(this, string, offset, length)

    case 'base64':
      return _base64Write(this, string, offset, length)

    default:
      throw new Error('Unknown encoding')
  }
}

function BufferToString (encoding, start, end) {
  var self = (this instanceof ProxyBuffer)
    ? this._proxy
    : this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  switch (encoding) {
    case 'hex':
      return _hexSlice(self, start, end)

    case 'utf8':
    case 'utf-8':
      return _utf8Slice(self, start, end)

    case 'ascii':
      return _asciiSlice(self, start, end)

    case 'binary':
      return _binarySlice(self, start, end)

    case 'base64':
      return _base64Slice(self, start, end)

    default:
      throw new Error('Unknown encoding')
  }
}

function BufferToJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
function BufferCopy (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start)
    throw new Error('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new Error('targetStart out of bounds')
  if (start < 0 || start >= source.length)
    throw new Error('sourceStart out of bounds')
  if (end < 0 || end > source.length)
    throw new Error('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  var bytes = buf.slice(start, end)
  return require('base64-js').fromByteArray(bytes)
}

function _utf8Slice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  var tmp = ''
  var i = 0
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i])
      tmp = ''
    } else {
      tmp += '%' + bytes[i].toString(16)
    }

    i++
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var ret = ''
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

// TODO: add test that modifying the new buffer slice will modify memory in the
// original buffer! Use code from:
// http://nodejs.org/api/buffer.html#buffer_buf_slice_start_end
function BufferSlice (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)
  return augment(this.subarray(start, end)) // Uint8Array built-in method
}

function BufferReadUInt8 (offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'Trying to read beyond buffer length')
  }

  if (offset >= buf.length)
    return

  return buf[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 1 === len) {
    var dv = new xDataView(new xArrayBuffer(2))
    dv.setUint8(0, buf[len - 1])
    return dv.getUint16(0, littleEndian)
  } else {
    return buf._dataview.getUint16(offset, littleEndian)
  }
}

function BufferReadUInt16LE (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

function BufferReadUInt16BE (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 3 >= len) {
    var dv = new xDataView(new xArrayBuffer(4))
    for (var i = 0; i + offset < len; i++) {
      dv.setUint8(i, buf[i + offset])
    }
    return dv.getUint32(0, littleEndian)
  } else {
    return buf._dataview.getUint32(offset, littleEndian)
  }
}

function BufferReadUInt32LE (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

function BufferReadUInt32BE (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

function BufferReadInt8 (offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < buf.length, 'Trying to read beyond buffer length')
  }

  if (offset >= buf.length)
    return

  return buf._dataview.getInt8(offset)
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 1 === len) {
    var dv = new xDataView(new xArrayBuffer(2))
    dv.setUint8(0, buf[len - 1])
    return dv.getInt16(0, littleEndian)
  } else {
    return buf._dataview.getInt16(offset, littleEndian)
  }
}

function BufferReadInt16LE (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

function BufferReadInt16BE (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 3 >= len) {
    var dv = new xDataView(new xArrayBuffer(4))
    for (var i = 0; i + offset < len; i++) {
      dv.setUint8(i, buf[i + offset])
    }
    return dv.getInt32(0, littleEndian)
  } else {
    return buf._dataview.getInt32(offset, littleEndian)
  }
}

function BufferReadInt32LE (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

function BufferReadInt32BE (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return buf._dataview.getFloat32(offset, littleEndian)
}

function BufferReadFloatLE (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

function BufferReadFloatBE (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return buf._dataview.getFloat64(offset, littleEndian)
}

function BufferReadDoubleLE (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

function BufferReadDoubleBE (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

function BufferWriteUInt8 (value, offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= buf.length) return

  buf[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 1 === len) {
    var dv = new xDataView(new xArrayBuffer(2))
    dv.setUint16(0, value, littleEndian)
    buf[offset] = dv.getUint8(0)
  } else {
    buf._dataview.setUint16(offset, value, littleEndian)
  }
}

function BufferWriteUInt16LE (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

function BufferWriteUInt16BE (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 3 >= len) {
    var dv = new xDataView(new xArrayBuffer(4))
    dv.setUint32(0, value, littleEndian)
    for (var i = 0; i + offset < len; i++) {
      buf[i + offset] = dv.getUint8(i)
    }
  } else {
    buf._dataview.setUint32(offset, value, littleEndian)
  }
}

function BufferWriteUInt32LE (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

function BufferWriteUInt32BE (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

function BufferWriteInt8 (value, offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= buf.length) return

  buf._dataview.setInt8(offset, value)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 1 === len) {
    var dv = new xDataView(new xArrayBuffer(2))
    dv.setInt16(0, value, littleEndian)
    buf[offset] = dv.getUint8(0)
  } else {
    buf._dataview.setInt16(offset, value, littleEndian)
  }
}

function BufferWriteInt16LE (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

function BufferWriteInt16BE (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 3 >= len) {
    var dv = new xDataView(new xArrayBuffer(4))
    dv.setInt32(0, value, littleEndian)
    for (var i = 0; i + offset < len; i++) {
      buf[i + offset] = dv.getUint8(i)
    }
  } else {
    buf._dataview.setInt32(offset, value, littleEndian)
  }
}

function BufferWriteInt32LE (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

function BufferWriteInt32BE (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 3 >= len) {
    var dv = new xDataView(new xArrayBuffer(4))
    dv.setFloat32(0, value, littleEndian)
    for (var i = 0; i + offset < len; i++) {
      buf[i + offset] = dv.getUint8(i)
    }
  } else {
    buf._dataview.setFloat32(offset, value, littleEndian)
  }
}

function BufferWriteFloatLE (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

function BufferWriteFloatBE (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof (littleEndian) === 'boolean',
        'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len) {
    return
  } else if (offset + 7 >= len) {
    var dv = new xDataView(new xArrayBuffer(8))
    dv.setFloat64(0, value, littleEndian)
    for (var i = 0; i + offset < len; i++) {
      buf[i + offset] = dv.getUint8(i)
    }
  } else {
    buf._dataview.setFloat64(offset, value, littleEndian)
  }
}

function BufferWriteDoubleLE (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

function BufferWriteDoubleBE (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
function BufferFill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  if (typeof value !== 'number' || isNaN(value)) {
    throw new Error('value is not a number')
  }

  if (end < start) throw new Error('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds')
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds')
  }

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

function BufferInspect () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

// Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
// Added in Node 0.12.
function BufferToArrayBuffer () {
  return (new Buffer(this)).buffer
}


// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

/**
 * Check to see if the browser supports augmenting a `Uint8Array` instance.
 * @return {boolean}
 */
function _browserSupport () {
  var arr = new xUint8Array(0)
  arr.foo = function () { return 42 }

  try {
    return (42 === arr.foo())
  } catch (e) {
    return false
  }
}

/**
 * Class: ProxyBuffer
 * ==================
 *
 * Only used in Firefox, since Firefox does not allow augmenting "native"
 * objects (like Uint8Array instances) with new properties for some unknown
 * (probably silly) reason. So we'll use an ES6 Proxy (supported since
 * Firefox 18) to wrap the Uint8Array instance without actually adding any
 * properties to it.
 *
 * Instances of this "fake" Buffer class are the "target" of the
 * ES6 Proxy (see `augment` function).
 *
 * We couldn't just use the `Uint8Array` as the target of the `Proxy` because
 * Proxies have an important limitation on trapping the `toString` method.
 * `Object.prototype.toString.call(proxy)` gets called whenever something is
 * implicitly cast to a String. Unfortunately, with a `Proxy` this
 * unconditionally returns `Object.prototype.toString.call(target)` which would
 * always return "[object Uint8Array]" if we used the `Uint8Array` instance as
 * the target. And, remember, in Firefox we cannot redefine the `Uint8Array`
 * instance's `toString` method.
 *
 * So, we use this `ProxyBuffer` class as the proxy's "target". Since this class
 * has its own custom `toString` method, it will get called whenever `toString`
 * gets called, implicitly or explicitly, on the `Proxy` instance.
 *
 * We also have to define the Uint8Array methods `subarray` and `set` on
 * `ProxyBuffer` because if we didn't then `proxy.subarray(0)` would have its
 * `this` set to `proxy` (a `Proxy` instance) which throws an exception in
 * Firefox which expects it to be a `TypedArray` instance.
 */
function ProxyBuffer (arr) {
  this._arr = arr

  if (arr.byteLength !== 0)
    this._dataview = new xDataView(arr.buffer, arr.byteOffset, arr.byteLength)
}

ProxyBuffer.prototype.write = BufferWrite
ProxyBuffer.prototype.toString = BufferToString
ProxyBuffer.prototype.toLocaleString = BufferToString
ProxyBuffer.prototype.toJSON = BufferToJSON
ProxyBuffer.prototype.copy = BufferCopy
ProxyBuffer.prototype.slice = BufferSlice
ProxyBuffer.prototype.readUInt8 = BufferReadUInt8
ProxyBuffer.prototype.readUInt16LE = BufferReadUInt16LE
ProxyBuffer.prototype.readUInt16BE = BufferReadUInt16BE
ProxyBuffer.prototype.readUInt32LE = BufferReadUInt32LE
ProxyBuffer.prototype.readUInt32BE = BufferReadUInt32BE
ProxyBuffer.prototype.readInt8 = BufferReadInt8
ProxyBuffer.prototype.readInt16LE = BufferReadInt16LE
ProxyBuffer.prototype.readInt16BE = BufferReadInt16BE
ProxyBuffer.prototype.readInt32LE = BufferReadInt32LE
ProxyBuffer.prototype.readInt32BE = BufferReadInt32BE
ProxyBuffer.prototype.readFloatLE = BufferReadFloatLE
ProxyBuffer.prototype.readFloatBE = BufferReadFloatBE
ProxyBuffer.prototype.readDoubleLE = BufferReadDoubleLE
ProxyBuffer.prototype.readDoubleBE = BufferReadDoubleBE
ProxyBuffer.prototype.writeUInt8 = BufferWriteUInt8
ProxyBuffer.prototype.writeUInt16LE = BufferWriteUInt16LE
ProxyBuffer.prototype.writeUInt16BE = BufferWriteUInt16BE
ProxyBuffer.prototype.writeUInt32LE = BufferWriteUInt32LE
ProxyBuffer.prototype.writeUInt32BE = BufferWriteUInt32BE
ProxyBuffer.prototype.writeInt8 = BufferWriteInt8
ProxyBuffer.prototype.writeInt16LE = BufferWriteInt16LE
ProxyBuffer.prototype.writeInt16BE = BufferWriteInt16BE
ProxyBuffer.prototype.writeInt32LE = BufferWriteInt32LE
ProxyBuffer.prototype.writeInt32BE = BufferWriteInt32BE
ProxyBuffer.prototype.writeFloatLE = BufferWriteFloatLE
ProxyBuffer.prototype.writeFloatBE = BufferWriteFloatBE
ProxyBuffer.prototype.writeDoubleLE = BufferWriteDoubleLE
ProxyBuffer.prototype.writeDoubleBE = BufferWriteDoubleBE
ProxyBuffer.prototype.fill = BufferFill
ProxyBuffer.prototype.inspect = BufferInspect
ProxyBuffer.prototype.toArrayBuffer = BufferToArrayBuffer
ProxyBuffer.prototype._isBuffer = true
ProxyBuffer.prototype.subarray = function () {
  return this._arr.subarray.apply(this._arr, arguments)
}
ProxyBuffer.prototype.set = function () {
  return this._arr.set.apply(this._arr, arguments)
}

var ProxyHandler = {
  get: function (target, name) {
    if (name in target) return target[name]
    else return target._arr[name]
  },
  set: function (target, name, value) {
    target._arr[name] = value
  }
}

function augment (arr) {
  if (browserSupport === undefined) {
    browserSupport = _browserSupport()
  }

  if (browserSupport) {
    // Augment the Uint8Array *instance* (not the class!) with Buffer methods
    arr.write = BufferWrite
    arr.toString = BufferToString
    arr.toLocaleString = BufferToString
    arr.toJSON = BufferToJSON
    arr.copy = BufferCopy
    arr.slice = BufferSlice
    arr.readUInt8 = BufferReadUInt8
    arr.readUInt16LE = BufferReadUInt16LE
    arr.readUInt16BE = BufferReadUInt16BE
    arr.readUInt32LE = BufferReadUInt32LE
    arr.readUInt32BE = BufferReadUInt32BE
    arr.readInt8 = BufferReadInt8
    arr.readInt16LE = BufferReadInt16LE
    arr.readInt16BE = BufferReadInt16BE
    arr.readInt32LE = BufferReadInt32LE
    arr.readInt32BE = BufferReadInt32BE
    arr.readFloatLE = BufferReadFloatLE
    arr.readFloatBE = BufferReadFloatBE
    arr.readDoubleLE = BufferReadDoubleLE
    arr.readDoubleBE = BufferReadDoubleBE
    arr.writeUInt8 = BufferWriteUInt8
    arr.writeUInt16LE = BufferWriteUInt16LE
    arr.writeUInt16BE = BufferWriteUInt16BE
    arr.writeUInt32LE = BufferWriteUInt32LE
    arr.writeUInt32BE = BufferWriteUInt32BE
    arr.writeInt8 = BufferWriteInt8
    arr.writeInt16LE = BufferWriteInt16LE
    arr.writeInt16BE = BufferWriteInt16BE
    arr.writeInt32LE = BufferWriteInt32LE
    arr.writeInt32BE = BufferWriteInt32BE
    arr.writeFloatLE = BufferWriteFloatLE
    arr.writeFloatBE = BufferWriteFloatBE
    arr.writeDoubleLE = BufferWriteDoubleLE
    arr.writeDoubleBE = BufferWriteDoubleBE
    arr.fill = BufferFill
    arr.inspect = BufferInspect
    arr.toArrayBuffer = BufferToArrayBuffer
    arr._isBuffer = true

    if (arr.byteLength !== 0)
      arr._dataview = new xDataView(arr.buffer, arr.byteOffset, arr.byteLength)

    return arr

  } else {
    // This is a browser that doesn't support augmenting the `Uint8Array`
    // instance (*ahem* Firefox) so use an ES6 `Proxy`.
    var proxyBuffer = new ProxyBuffer(arr)
    var proxy = new Proxy(proxyBuffer, ProxyHandler)
    proxyBuffer._proxy = proxy
    return proxy
  }
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArrayIsh (subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }

  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }

  return byteArray
}

function base64ToBytes (str) {
  return require('base64-js').toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos, i = 0
  while (i < length) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break

    dst[i + offset] = src[i]
    i++
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint (value, max) {
  assert(typeof (value) == 'number', 'cannot write a non-number as a number')
  assert(value >= 0,
      'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert(typeof (value) == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754(value, max, min) {
  assert(typeof (value) == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":3,"typedarray":4}],"native-buffer-browserify":[function(require,module,exports){
module.exports=require('PcZj9L');
},{}],3:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],4:[function(require,module,exports){
var undefined = (void 0); // Paranoia

// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
// create, and consume so much memory, that the browser appears frozen.
var MAX_ARRAY_LENGTH = 1e5;

// Approximations of internal ECMAScript conversion functions
var ECMAScript = (function() {
  // Stash a copy in case other scripts modify these
  var opts = Object.prototype.toString,
      ophop = Object.prototype.hasOwnProperty;

  return {
    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
    Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
    HasProperty: function(o, p) { return p in o; },
    HasOwnProperty: function(o, p) { return ophop.call(o, p); },
    IsCallable: function(o) { return typeof o === 'function'; },
    ToInt32: function(v) { return v >> 0; },
    ToUint32: function(v) { return v >>> 0; }
  };
}());

// Snapshot intrinsics
var LN2 = Math.LN2,
    abs = Math.abs,
    floor = Math.floor,
    log = Math.log,
    min = Math.min,
    pow = Math.pow,
    round = Math.round;

// ES5: lock down object properties
function configureProperties(obj) {
  if (getOwnPropertyNames && defineProperty) {
    var props = getOwnPropertyNames(obj), i;
    for (i = 0; i < props.length; i += 1) {
      defineProperty(obj, props[i], {
        value: obj[props[i]],
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
  }
}

// emulate ES5 getter/setter API using legacy APIs
// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
var defineProperty = Object.defineProperty || function(o, p, desc) {
  if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
  if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
  if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
  if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
  return o;
};

var getOwnPropertyNames = Object.getOwnPropertyNames || function getOwnPropertyNames(o) {
  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
  var props = [], p;
  for (p in o) {
    if (ECMAScript.HasOwnProperty(o, p)) {
      props.push(p);
    }
  }
  return props;
};

// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
// for index in 0 ... obj.length
function makeArrayAccessors(obj) {
  if (!defineProperty) { return; }

  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");

  function makeArrayAccessor(index) {
    defineProperty(obj, index, {
      'get': function() { return obj._getter(index); },
      'set': function(v) { obj._setter(index, v); },
      enumerable: true,
      configurable: false
    });
  }

  var i;
  for (i = 0; i < obj.length; i += 1) {
    makeArrayAccessor(i);
  }
}

// Internal conversion functions:
//    pack<Type>()   - take a number (interpreted as Type), output a byte array
//    unpack<Type>() - take a byte array, output a Type-like number

function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }

function packI8(n) { return [n & 0xff]; }
function unpackI8(bytes) { return as_signed(bytes[0], 8); }

function packU8(n) { return [n & 0xff]; }
function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }

function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }

function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }

function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }

function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

function packIEEE754(v, ebits, fbits) {

  var bias = (1 << (ebits - 1)) - 1,
      s, e, f, ln,
      i, bits, str, bytes;

  function roundToEven(n) {
    var w = floor(n), f = n - w;
    if (f < 0.5)
      return w;
    if (f > 0.5)
      return w + 1;
    return w % 2 ? w + 1 : w;
  }

  // Compute sign, exponent, fraction
  if (v !== v) {
    // NaN
    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
  } else if (v === Infinity || v === -Infinity) {
    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
  } else if (v === 0) {
    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
  } else {
    s = v < 0;
    v = abs(v);

    if (v >= pow(2, 1 - bias)) {
      e = min(floor(log(v) / LN2), 1023);
      f = roundToEven(v / pow(2, e) * pow(2, fbits));
      if (f / pow(2, fbits) >= 2) {
        e = e + 1;
        f = 1;
      }
      if (e > bias) {
        // Overflow
        e = (1 << ebits) - 1;
        f = 0;
      } else {
        // Normalized
        e = e + bias;
        f = f - pow(2, fbits);
      }
    } else {
      // Denormalized
      e = 0;
      f = roundToEven(v / pow(2, 1 - bias - fbits));
    }
  }

  // Pack sign, exponent, fraction
  bits = [];
  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
  bits.push(s ? 1 : 0);
  bits.reverse();
  str = bits.join('');

  // Bits to bytes
  bytes = [];
  while (str.length) {
    bytes.push(parseInt(str.substring(0, 8), 2));
    str = str.substring(8);
  }
  return bytes;
}

function unpackIEEE754(bytes, ebits, fbits) {

  // Bytes to bits
  var bits = [], i, j, b, str,
      bias, s, e, f;

  for (i = bytes.length; i; i -= 1) {
    b = bytes[i - 1];
    for (j = 8; j; j -= 1) {
      bits.push(b % 2 ? 1 : 0); b = b >> 1;
    }
  }
  bits.reverse();
  str = bits.join('');

  // Unpack sign, exponent, fraction
  bias = (1 << (ebits - 1)) - 1;
  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
  e = parseInt(str.substring(1, 1 + ebits), 2);
  f = parseInt(str.substring(1 + ebits), 2);

  // Produce number
  if (e === (1 << ebits) - 1) {
    return f !== 0 ? NaN : s * Infinity;
  } else if (e > 0) {
    // Normalized
    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
  } else if (f !== 0) {
    // Denormalized
    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
  } else {
    return s < 0 ? -0 : 0;
  }
}

function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
function packF64(v) { return packIEEE754(v, 11, 52); }
function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
function packF32(v) { return packIEEE754(v, 8, 23); }


//
// 3 The ArrayBuffer Type
//

(function() {

  /** @constructor */
  var ArrayBuffer = function ArrayBuffer(length) {
    length = ECMAScript.ToInt32(length);
    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');

    this.byteLength = length;
    this._bytes = [];
    this._bytes.length = length;

    var i;
    for (i = 0; i < this.byteLength; i += 1) {
      this._bytes[i] = 0;
    }

    configureProperties(this);
  };

  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;

  //
  // 4 The ArrayBufferView Type
  //

  // NOTE: this constructor is not exported
  /** @constructor */
  var ArrayBufferView = function ArrayBufferView() {
    //this.buffer = null;
    //this.byteOffset = 0;
    //this.byteLength = 0;
  };

  //
  // 5 The Typed Array View Types
  //

  function makeConstructor(bytesPerElement, pack, unpack) {
    // Each TypedArray type requires a distinct constructor instance with
    // identical logic, which this produces.

    var ctor;
    ctor = function(buffer, byteOffset, length) {
      var array, sequence, i, s;

      if (!arguments.length || typeof arguments[0] === 'number') {
        // Constructor(unsigned long length)
        this.length = ECMAScript.ToInt32(arguments[0]);
        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');

        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;
      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
        // Constructor(TypedArray array)
        array = arguments[0];

        this.length = array.length;
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) {
          this._setter(i, array._getter(i));
        }
      } else if (typeof arguments[0] === 'object' &&
                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
        // Constructor(sequence<type> array)
        sequence = arguments[0];

        this.length = ECMAScript.ToUint32(sequence.length);
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) {
          s = sequence[i];
          this._setter(i, Number(s));
        }
      } else if (typeof arguments[0] === 'object' &&
                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
        // Constructor(ArrayBuffer buffer,
        //             optional unsigned long byteOffset, optional unsigned long length)
        this.buffer = buffer;

        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }

        if (this.byteOffset % this.BYTES_PER_ELEMENT) {
          // The given byteOffset must be a multiple of the element
          // size of the specific type, otherwise an exception is raised.
          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
        }

        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;

          if (this.byteLength % this.BYTES_PER_ELEMENT) {
            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
          }
          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
        } else {
          this.length = ECMAScript.ToUint32(length);
          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        }

        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
      } else {
        throw new TypeError("Unexpected argument type(s)");
      }

      this.constructor = ctor;

      configureProperties(this);
      makeArrayAccessors(this);
    };

    ctor.prototype = new ArrayBufferView();
    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
    ctor.prototype._pack = pack;
    ctor.prototype._unpack = unpack;
    ctor.BYTES_PER_ELEMENT = bytesPerElement;

    // getter type (unsigned long index);
    ctor.prototype._getter = function(index) {
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) {
        return undefined;
      }

      var bytes = [], i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        bytes.push(this.buffer._bytes[o]);
      }
      return this._unpack(bytes);
    };

    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
    ctor.prototype.get = ctor.prototype._getter;

    // setter void (unsigned long index, type value);
    ctor.prototype._setter = function(index, value) {
      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) {
        return undefined;
      }

      var bytes = this._pack(value), i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        this.buffer._bytes[o] = bytes[i];
      }
    };

    // void set(TypedArray array, optional unsigned long offset);
    // void set(sequence<type> array, optional unsigned long offset);
    ctor.prototype.set = function(index, value) {
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
      var array, sequence, offset, len,
          i, s, d,
          byteOffset, byteLength, tmp;

      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
        // void set(TypedArray array, optional unsigned long offset);
        array = arguments[0];
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + array.length > this.length) {
          throw new RangeError("Offset plus length of array is out of range");
        }

        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
        byteLength = array.length * this.BYTES_PER_ELEMENT;

        if (array.buffer === this.buffer) {
          tmp = [];
          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
            tmp[i] = array.buffer._bytes[s];
          }
          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
            this.buffer._bytes[d] = tmp[i];
          }
        } else {
          for (i = 0, s = array.byteOffset, d = byteOffset;
               i < byteLength; i += 1, s += 1, d += 1) {
            this.buffer._bytes[d] = array.buffer._bytes[s];
          }
        }
      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
        // void set(sequence<type> array, optional unsigned long offset);
        sequence = arguments[0];
        len = ECMAScript.ToUint32(sequence.length);
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + len > this.length) {
          throw new RangeError("Offset plus length of array is out of range");
        }

        for (i = 0; i < len; i += 1) {
          s = sequence[i];
          this._setter(offset + i, Number(s));
        }
      } else {
        throw new TypeError("Unexpected argument type(s)");
      }
    };

    // TypedArray subarray(long begin, optional long end);
    ctor.prototype.subarray = function(start, end) {
      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

      start = ECMAScript.ToInt32(start);
      end = ECMAScript.ToInt32(end);

      if (arguments.length < 1) { start = 0; }
      if (arguments.length < 2) { end = this.length; }

      if (start < 0) { start = this.length + start; }
      if (end < 0) { end = this.length + end; }

      start = clamp(start, 0, this.length);
      end = clamp(end, 0, this.length);

      var len = end - start;
      if (len < 0) {
        len = 0;
      }

      return new this.constructor(
        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
    };

    return ctor;
  }

  var Int8Array = makeConstructor(1, packI8, unpackI8);
  var Uint8Array = makeConstructor(1, packU8, unpackU8);
  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
  var Int16Array = makeConstructor(2, packI16, unpackI16);
  var Uint16Array = makeConstructor(2, packU16, unpackU16);
  var Int32Array = makeConstructor(4, packI32, unpackI32);
  var Uint32Array = makeConstructor(4, packU32, unpackU32);
  var Float32Array = makeConstructor(4, packF32, unpackF32);
  var Float64Array = makeConstructor(8, packF64, unpackF64);

  exports.Int8Array = exports.Int8Array || Int8Array;
  exports.Uint8Array = exports.Uint8Array || Uint8Array;
  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
  exports.Int16Array = exports.Int16Array || Int16Array;
  exports.Uint16Array = exports.Uint16Array || Uint16Array;
  exports.Int32Array = exports.Int32Array || Int32Array;
  exports.Uint32Array = exports.Uint32Array || Uint32Array;
  exports.Float32Array = exports.Float32Array || Float32Array;
  exports.Float64Array = exports.Float64Array || Float64Array;
}());

//
// 6 The DataView View Type
//

(function() {
  function r(array, index) {
    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
  }

  var IS_BIG_ENDIAN = (function() {
    var u16array = new(exports.Uint16Array)([0x1234]),
        u8array = new(exports.Uint8Array)(u16array.buffer);
    return r(u8array, 0) === 0x12;
  }());

  // Constructor(ArrayBuffer buffer,
  //             optional unsigned long byteOffset,
  //             optional unsigned long byteLength)
  /** @constructor */
  var DataView = function DataView(buffer, byteOffset, byteLength) {
    if (arguments.length === 0) {
      buffer = new ArrayBuffer(0);
    } else if (!(buffer instanceof ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
      throw new TypeError("TypeError");
    }

    this.buffer = buffer || new ArrayBuffer(0);

    this.byteOffset = ECMAScript.ToUint32(byteOffset);
    if (this.byteOffset > this.buffer.byteLength) {
      throw new RangeError("byteOffset out of range");
    }

    if (arguments.length < 3) {
      this.byteLength = this.buffer.byteLength - this.byteOffset;
    } else {
      this.byteLength = ECMAScript.ToUint32(byteLength);
    }

    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
    }

    configureProperties(this);
  };

  function makeGetter(arrayType) {
    return function(byteOffset, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);

      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
        throw new RangeError("Array index out of range");
      }
      byteOffset += this.byteOffset;

      var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
          bytes = [], i;
      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
        bytes.push(r(uint8Array, i));
      }

      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      return r(new arrayType(new Uint8Array(bytes).buffer), 0);
    };
  }

  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);

  function makeSetter(arrayType) {
    return function(byteOffset, value, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);
      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
        throw new RangeError("Array index out of range");
      }

      // Get bytes
      var typeArray = new arrayType([value]),
          byteArray = new Uint8Array(typeArray.buffer),
          bytes = [], i, byteView;

      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
        bytes.push(r(byteArray, i));
      }

      // Flip if necessary
      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      // Write them
      byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
      byteView.set(bytes);
    };
  }

  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);

  exports.DataView = exports.DataView || DataView;

}());

},{}]},{},[])
;;module.exports=require("native-buffer-browserify").Buffer

},{}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],5:[function(require,module,exports){
var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"__browserify_process":4}],6:[function(require,module,exports){
"use strict";

var activeLine = "line@activine"

function onCursorActivity(editor) {
  var line = editor.getLineHandle(editor.getCursor().line)
  var active = editor[activeLine]
  if (line != active) {
    editor.removeLineClass(active, "background", "activeline")
    editor[activeLine] = editor.addLineClass(line, "background", "activeline")
  }
}

function setup(editor, value) {
  /**
  Takes editor and enables persists changes to the buffer across the sessions.
  **/
  if (value) {
    editor[activeLine] = editor.addLineClass(0, "background", "activeline")
    editor.on("cursorActivity", onCursorActivity)
    onCursorActivity(editor)
  } else if (activeLine in editor) {
    editor.removeLineClass(editor[activeLine], "background", "activeline")
    delete editor[activeLine]
    editor.off("cursorActivity", onCursorActivity)
  }
}

function plugin(CodeMirror) {
  CodeMirror.defineOption("activeLine", false, setup)
}

module.exports = plugin

},{}],7:[function(require,module,exports){
"use strict";

function onChange(editor) {
  localStorage[window.location.href.split("#")[0]] = editor.getValue()
}

function setup(editor, value) {
  /**
  Takes editor and enables persists changes to the buffer across the sessions.
  **/
  if (value) {
    var address = window.location.href.split("#")[0]
    var persisted = localStorage[address] || editor.getValue()
    editor.setValue(persisted)
    editor.on("change", onChange)
  } else {
    editor.off("change", onChange)
  }
}

function plugin(CodeMirror) {
  CodeMirror.defineOption("persist", false, setup)
}

module.exports = plugin

},{}],8:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.analyzer',
            doc: void 0
        };
    var wisp_ast = require('./ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var isKeyword = wisp_ast.isKeyword;
    var isQuote = wisp_ast.isQuote;
    var symbol = wisp_ast.symbol;
    var namespace = wisp_ast.namespace;
    var name = wisp_ast.name;
    var prStr = wisp_ast.prStr;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var conj = wisp_sequence.conj;
    var partition = wisp_sequence.partition;
    var seq = wisp_sequence.seq;
    var isEmpty = wisp_sequence.isEmpty;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var isEvery = wisp_sequence.isEvery;
    var concat = wisp_sequence.concat;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var last = wisp_sequence.last;
    var butlast = wisp_sequence.butlast;
    var interleave = wisp_sequence.interleave;
    var cons = wisp_sequence.cons;
    var count = wisp_sequence.count;
    var some = wisp_sequence.some;
    var assoc = wisp_sequence.assoc;
    var reduce = wisp_sequence.reduce;
    var filter = wisp_sequence.filter;
    var isSeq = wisp_sequence.isSeq;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isDictionary = wisp_runtime.isDictionary;
    var isVector = wisp_runtime.isVector;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isBoolean = wisp_runtime.isBoolean;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isEven = wisp_runtime.isEven;
    var isEqual = wisp_runtime.isEqual;
    var max = wisp_runtime.max;
    var dec = wisp_runtime.dec;
    var dictionary = wisp_runtime.dictionary;
    var subs = wisp_runtime.subs;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var wisp_expander = require('./expander');
    var macroexpand = wisp_expander.macroexpand;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
}
var syntaxError = exports.syntaxError = function syntaxError(message, form) {
        return function () {
            var metadataø1 = meta(form);
            var lineø1 = ((metadataø1 || 0)['start'] || 0)['line'];
            var uriø1 = (metadataø1 || 0)['uri'];
            var columnø1 = ((metadataø1 || 0)['start'] || 0)['column'];
            var errorø1 = SyntaxError('' + message + '\n' + 'Form: ' + prStr(form) + '\n' + 'URI: ' + uriø1 + '\n' + 'Line: ' + lineø1 + '\n' + 'Column: ' + columnø1);
            errorø1.lineNumber = lineø1;
            errorø1.line = lineø1;
            errorø1.columnNumber = columnø1;
            errorø1.column = columnø1;
            errorø1.fileName = uriø1;
            errorø1.uri = uriø1;
            return (function () {
                throw errorø1;
            })();
        }.call(this);
    };
var analyzeKeyword = exports.analyzeKeyword = function analyzeKeyword(env, form) {
        return {
            'op': 'constant',
            'form': form
        };
    };
var __specials__ = exports.__specials__ = {};
var installSpecial = exports.installSpecial = function installSpecial(op, analyzer) {
        return (__specials__ || 0)[name(op)] = analyzer;
    };
var analyzeSpecial = exports.analyzeSpecial = function analyzeSpecial(analyzer, env, form) {
        return function () {
            var metadataø1 = meta(form);
            var astø1 = analyzer(env, form);
            return conj({
                'start': (metadataø1 || 0)['start'],
                'end': (metadataø1 || 0)['end']
            }, astø1);
        }.call(this);
    };
var analyzeIf = exports.analyzeIf = function analyzeIf(env, form) {
        return function () {
            var formsø1 = rest(form);
            var testø1 = analyze(env, first(formsø1));
            var consequentø1 = analyze(env, second(formsø1));
            var alternateø1 = analyze(env, third(formsø1));
            count(formsø1) < 2 ? syntaxError('Malformed if expression, too few operands', form) : void 0;
            return {
                'op': 'if',
                'form': form,
                'test': testø1,
                'consequent': consequentø1,
                'alternate': alternateø1
            };
        }.call(this);
    };
installSpecial('if', analyzeIf);
var analyzeThrow = exports.analyzeThrow = function analyzeThrow(env, form) {
        return function () {
            var expressionø1 = analyze(env, second(form));
            return {
                'op': 'throw',
                'form': form,
                'throw': expressionø1
            };
        }.call(this);
    };
installSpecial('throw', analyzeThrow);
var analyzeTry = exports.analyzeTry = function analyzeTry(env, form) {
        return function () {
            var formsø1 = vec(rest(form));
            var tailø1 = last(formsø1);
            var finalizerFormø1 = isList(tailø1) && isEqual(symbol(void 0, 'finally'), first(tailø1)) ? rest(tailø1) : void 0;
            var finalizerø1 = finalizerFormø1 ? analyzeBlock(env, finalizerFormø1) : void 0;
            var bodyFormø1 = finalizerø1 ? butlast(formsø1) : formsø1;
            var tailø2 = last(bodyFormø1);
            var handlerFormø1 = isList(tailø2) && isEqual(symbol(void 0, 'catch'), first(tailø2)) ? rest(tailø2) : void 0;
            var handlerø1 = handlerFormø1 ? conj({ 'name': analyze(env, first(handlerFormø1)) }, analyzeBlock(env, rest(handlerFormø1))) : void 0;
            var bodyø1 = handlerFormø1 ? analyzeBlock(env, butlast(bodyFormø1)) : analyzeBlock(env, bodyFormø1);
            return {
                'op': 'try',
                'form': form,
                'body': bodyø1,
                'handler': handlerø1,
                'finalizer': finalizerø1
            };
        }.call(this);
    };
installSpecial('try', analyzeTry);
var analyzeSet = exports.analyzeSet = function analyzeSet(env, form) {
        return function () {
            var bodyø1 = rest(form);
            var leftø1 = first(bodyø1);
            var rightø1 = second(bodyø1);
            var targetø1 = isSymbol(leftø1) ? analyzeSymbol(env, leftø1) : isList(leftø1) ? analyzeList(env, leftø1) : 'else' ? leftø1 : void 0;
            var valueø1 = analyze(env, rightø1);
            return {
                'op': 'set!',
                'target': targetø1,
                'value': valueø1,
                'form': form
            };
        }.call(this);
    };
installSpecial('set!', analyzeSet);
var analyzeNew = exports.analyzeNew = function analyzeNew(env, form) {
        return function () {
            var bodyø1 = rest(form);
            var constructorø1 = analyze(env, first(bodyø1));
            var paramsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, rest(bodyø1)));
            return {
                'op': 'new',
                'constructor': constructorø1,
                'form': form,
                'params': paramsø1
            };
        }.call(this);
    };
installSpecial('new', analyzeNew);
var analyzeAget = exports.analyzeAget = function analyzeAget(env, form) {
        return function () {
            var bodyø1 = rest(form);
            var targetø1 = analyze(env, first(bodyø1));
            var attributeø1 = second(bodyø1);
            var fieldø1 = isQuote(attributeø1) && isSymbol(second(attributeø1)) && second(attributeø1);
            return isNil(attributeø1) ? syntaxError('Malformed aget expression expected (aget object member)', form) : {
                'op': 'member-expression',
                'computed': !fieldø1,
                'form': form,
                'target': targetø1,
                'property': fieldø1 ? conj(analyzeSpecial(analyzeIdentifier, env, fieldø1), { 'binding': void 0 }) : analyze(env, attributeø1)
            };
        }.call(this);
    };
installSpecial('aget', analyzeAget);
var parseDef = exports.parseDef = function parseDef() {
        switch (arguments.length) {
        case 1:
            var id = arguments[0];
            return { 'id': id };
        case 2:
            var id = arguments[0];
            var init = arguments[1];
            return {
                'id': id,
                'init': init
            };
        case 3:
            var id = arguments[0];
            var doc = arguments[1];
            var init = arguments[2];
            return {
                'id': id,
                'doc': doc,
                'init': init
            };
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var analyzeDef = exports.analyzeDef = function analyzeDef(env, form) {
        return function () {
            var paramsø1 = parseDef.apply(void 0, vec(rest(form)));
            var idø1 = (paramsø1 || 0)['id'];
            var metadataø1 = meta(idø1);
            var bindingø1 = analyzeSpecial(analyzeDeclaration, env, idø1);
            var initø1 = analyze(env, (paramsø1 || 0)['init']);
            var docø1 = (paramsø1 || 0)['doc'] || (metadataø1 || 0)['doc'];
            return {
                'op': 'def',
                'doc': docø1,
                'id': bindingø1,
                'init': initø1,
                'export': (env || 0)['top'] && !(metadataø1 || 0)['private'],
                'form': form
            };
        }.call(this);
    };
installSpecial('def', analyzeDef);
var analyzeDo = exports.analyzeDo = function analyzeDo(env, form) {
        return function () {
            var expressionsø1 = rest(form);
            var bodyø1 = analyzeBlock(env, expressionsø1);
            return conj(bodyø1, {
                'op': 'do',
                'form': form
            });
        }.call(this);
    };
installSpecial('do', analyzeDo);
var analyzeSymbol = exports.analyzeSymbol = function analyzeSymbol(env, form) {
        return function () {
            var formsø1 = split(name(form), '.');
            var metadataø1 = meta(form);
            var startø1 = (metadataø1 || 0)['start'];
            var endø1 = (metadataø1 || 0)['end'];
            var expansionø1 = count(formsø1) > 1 ? list(symbol(void 0, 'aget'), withMeta(symbol(first(formsø1)), conj(metadataø1, {
                    'start': startø1,
                    'end': {
                        'line': (endø1 || 0)['line'],
                        'column': 1 + (startø1 || 0)['column'] + count(first(formsø1))
                    }
                })), list(symbol(void 0, 'quote'), withMeta(symbol(join('.', rest(formsø1))), conj(metadataø1, {
                    'end': endø1,
                    'start': {
                        'line': (startø1 || 0)['line'],
                        'column': 1 + (startø1 || 0)['column'] + count(first(formsø1))
                    }
                })))) : void 0;
            return expansionø1 ? analyze(env, withMeta(expansionø1, meta(form))) : analyzeSpecial(analyzeIdentifier, env, form);
        }.call(this);
    };
var analyzeIdentifier = exports.analyzeIdentifier = function analyzeIdentifier(env, form) {
        return {
            'op': 'var',
            'type': 'identifier',
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end'],
            'binding': resolveBinding(env, form)
        };
    };
var unresolvedBinding = exports.unresolvedBinding = function unresolvedBinding(env, form) {
        return {
            'op': 'unresolved-binding',
            'type': 'unresolved-binding',
            'identifier': {
                'type': 'identifier',
                'form': symbol(namespace(form), name(form))
            },
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        };
    };
var resolveBinding = exports.resolveBinding = function resolveBinding(env, form) {
        return ((env || 0)['locals'] || 0)[name(form)] || ((env || 0)['enclosed'] || 0)[name(form)] || unresolvedBinding(env, form);
    };
var analyzeShadow = exports.analyzeShadow = function analyzeShadow(env, id) {
        return function () {
            var bindingø1 = resolveBinding(env, id);
            return {
                'depth': inc((bindingø1 || 0)['depth'] || 0),
                'shadow': bindingø1
            };
        }.call(this);
    };
var analyzeBinding = exports.analyzeBinding = function analyzeBinding(env, form) {
        return function () {
            var idø1 = first(form);
            var bodyø1 = second(form);
            return conj(analyzeShadow(env, idø1), {
                'op': 'binding',
                'type': 'binding',
                'id': idø1,
                'init': analyze(env, bodyø1),
                'form': form
            });
        }.call(this);
    };
var analyzeDeclaration = exports.analyzeDeclaration = function analyzeDeclaration(env, form) {
        !!(namespace(form) || 1 < count(split('.', '' + form))) ? (function () {
            throw Error('' + 'Assert failed: ' + '' + '(not (or (namespace form) (< 1 (count (split "." (str form))))))');
        })() : void 0;
        return conj(analyzeShadow(env, form), {
            'op': 'var',
            'type': 'identifier',
            'depth': 0,
            'id': form,
            'form': form
        });
    };
var analyzeParam = exports.analyzeParam = function analyzeParam(env, form) {
        return conj(analyzeShadow(env, form), {
            'op': 'param',
            'type': 'parameter',
            'id': form,
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        });
    };
var withBinding = exports.withBinding = function withBinding(env, form) {
        return conj(env, {
            'locals': assoc((env || 0)['locals'], name((form || 0)['id']), form),
            'bindings': conj((env || 0)['bindings'], form)
        });
    };
var withParam = exports.withParam = function withParam(env, form) {
        return conj(withBinding(env, form), { 'params': conj((env || 0)['params'], form) });
    };
var subEnv = exports.subEnv = function subEnv(env) {
        return {
            'enclosed': conj({}, (env || 0)['enclosed'], (env || 0)['locals']),
            'locals': {},
            'bindings': [],
            'params': (env || 0)['params'] || []
        };
    };
var analyzeLet_ = exports.analyzeLet_ = function analyzeLet_(env, form, isLoop) {
        return function () {
            var expressionsø1 = rest(form);
            var bindingsø1 = first(expressionsø1);
            var bodyø1 = rest(expressionsø1);
            var isValidBindingsø1 = isVector(bindingsø1) && isEven(count(bindingsø1));
            var _ø1 = !isValidBindingsø1 ? (function () {
                    throw Error('' + 'Assert failed: ' + 'bindings must be vector of even number of elements' + 'valid-bindings?');
                })() : void 0;
            var scopeø1 = reduce(function ($1, $2) {
                    return withBinding($1, analyzeBinding($1, $2));
                }, subEnv(env), partition(2, bindingsø1));
            var bindingsø2 = (scopeø1 || 0)['bindings'];
            var expressionsø2 = analyzeBlock(isLoop ? conj(scopeø1, { 'params': bindingsø2 }) : scopeø1, bodyø1);
            return {
                'op': 'let',
                'form': form,
                'start': (meta(form) || 0)['start'],
                'end': (meta(form) || 0)['end'],
                'bindings': bindingsø2,
                'statements': (expressionsø2 || 0)['statements'],
                'result': (expressionsø2 || 0)['result']
            };
        }.call(this);
    };
var analyzeLet = exports.analyzeLet = function analyzeLet(env, form) {
        return analyzeLet_(env, form, false);
    };
installSpecial('let', analyzeLet);
var analyzeLoop = exports.analyzeLoop = function analyzeLoop(env, form) {
        return conj(analyzeLet_(env, form, true), { 'op': 'loop' });
    };
installSpecial('loop', analyzeLoop);
var analyzeRecur = exports.analyzeRecur = function analyzeRecur(env, form) {
        return function () {
            var paramsø1 = (env || 0)['params'];
            var formsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, rest(form)));
            return isEqual(count(paramsø1), count(formsø1)) ? {
                'op': 'recur',
                'form': form,
                'params': formsø1
            } : syntaxError('Recurs with wrong number of arguments', form);
        }.call(this);
    };
installSpecial('recur', analyzeRecur);
var analyzeQuotedList = exports.analyzeQuotedList = function analyzeQuotedList(form) {
        return {
            'op': 'list',
            'items': map(analyzeQuoted, vec(form)),
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        };
    };
var analyzeQuotedVector = exports.analyzeQuotedVector = function analyzeQuotedVector(form) {
        return {
            'op': 'vector',
            'items': map(analyzeQuoted, form),
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        };
    };
var analyzeQuotedDictionary = exports.analyzeQuotedDictionary = function analyzeQuotedDictionary(form) {
        return function () {
            var namesø1 = vec(map(analyzeQuoted, keys(form)));
            var valuesø1 = vec(map(analyzeQuoted, vals(form)));
            return {
                'op': 'dictionary',
                'form': form,
                'keys': namesø1,
                'values': valuesø1,
                'start': (meta(form) || 0)['start'],
                'end': (meta(form) || 0)['end']
            };
        }.call(this);
    };
var analyzeQuotedSymbol = exports.analyzeQuotedSymbol = function analyzeQuotedSymbol(form) {
        return {
            'op': 'symbol',
            'name': name(form),
            'namespace': namespace(form),
            'form': form
        };
    };
var analyzeQuotedKeyword = exports.analyzeQuotedKeyword = function analyzeQuotedKeyword(form) {
        return {
            'op': 'keyword',
            'name': name(form),
            'namespace': namespace(form),
            'form': form
        };
    };
var analyzeQuoted = exports.analyzeQuoted = function analyzeQuoted(form) {
        return isSymbol(form) ? analyzeQuotedSymbol(form) : isKeyword(form) ? analyzeQuotedKeyword(form) : isList(form) ? analyzeQuotedList(form) : isVector(form) ? analyzeQuotedVector(form) : isDictionary(form) ? analyzeQuotedDictionary(form) : 'else' ? {
            'op': 'constant',
            'form': form
        } : void 0;
    };
var analyzeQuote = exports.analyzeQuote = function analyzeQuote(env, form) {
        return analyzeQuoted(second(form));
    };
installSpecial('quote', analyzeQuote);
var analyzeStatement = exports.analyzeStatement = function analyzeStatement(env, form) {
        return function () {
            var statementsø1 = (env || 0)['statements'] || [];
            var bindingsø1 = (env || 0)['bindings'] || [];
            var statementø1 = analyze(env, form);
            var opø1 = (statementø1 || 0)['op'];
            var defsø1 = isEqual(opø1, 'def') ? [(statementø1 || 0)['var']] : 'else' ? void 0 : void 0;
            return conj(env, {
                'statements': conj(statementsø1, statementø1),
                'bindings': concat(bindingsø1, defsø1)
            });
        }.call(this);
    };
var analyzeBlock = exports.analyzeBlock = function analyzeBlock(env, form) {
        return function () {
            var bodyø1 = count(form) > 1 ? reduce(analyzeStatement, env, butlast(form)) : void 0;
            var resultø1 = analyze(bodyø1 || env, last(form));
            return {
                'statements': (bodyø1 || 0)['statements'],
                'result': resultø1
            };
        }.call(this);
    };
var analyzeFnMethod = exports.analyzeFnMethod = function analyzeFnMethod(env, form) {
        return function () {
            var signatureø1 = isList(form) && isVector(first(form)) ? first(form) : syntaxError('Malformed fn overload form', form);
            var bodyø1 = rest(form);
            var variadicø1 = some(function ($1) {
                    return isEqual(symbol(void 0, '&'), $1);
                }, signatureø1);
            var paramsø1 = variadicø1 ? filter(function ($1) {
                    return !isEqual(symbol(void 0, '&'), $1);
                }, signatureø1) : signatureø1;
            var arityø1 = variadicø1 ? dec(count(paramsø1)) : count(paramsø1);
            var scopeø1 = reduce(function ($1, $2) {
                    return withParam($1, analyzeParam($1, $2));
                }, conj(env, { 'params': [] }), paramsø1);
            return conj(analyzeBlock(scopeø1, bodyø1), {
                'op': 'overload',
                'variadic': variadicø1,
                'arity': arityø1,
                'params': (scopeø1 || 0)['params'],
                'form': form
            });
        }.call(this);
    };
var analyzeFn = exports.analyzeFn = function analyzeFn(env, form) {
        return function () {
            var formsø1 = rest(form);
            var formsø2 = isSymbol(first(formsø1)) ? formsø1 : cons(void 0, formsø1);
            var idø1 = first(formsø2);
            var bindingø1 = idø1 ? analyzeSpecial(analyzeDeclaration, env, idø1) : void 0;
            var bodyø1 = rest(formsø2);
            var overloadsø1 = isVector(first(bodyø1)) ? list(bodyø1) : isList(first(bodyø1)) && isVector(first(first(bodyø1))) ? bodyø1 : 'else' ? syntaxError('' + 'Malformed fn expression, ' + 'parameter declaration (' + prStr(first(bodyø1)) + ') must be a vector', form) : void 0;
            var scopeø1 = bindingø1 ? withBinding(subEnv(env), bindingø1) : subEnv(env);
            var methodsø1 = map(function ($1) {
                    return analyzeFnMethod(scopeø1, $1);
                }, vec(overloadsø1));
            var arityø1 = max.apply(void 0, map(function ($1) {
                    return ($1 || 0)['arity'];
                }, methodsø1));
            var variadicø1 = some(function ($1) {
                    return ($1 || 0)['variadic'];
                }, methodsø1);
            return {
                'op': 'fn',
                'type': 'function',
                'id': bindingø1,
                'variadic': variadicø1,
                'methods': methodsø1,
                'form': form
            };
        }.call(this);
    };
installSpecial('fn', analyzeFn);
var parseReferences = exports.parseReferences = function parseReferences(forms) {
        return reduce(function (references, form) {
            return isSeq(form) ? assoc(references, name(first(form)), vec(rest(form))) : references;
        }, {}, forms);
    };
var parseRequire = exports.parseRequire = function parseRequire(form) {
        return function () {
            var requirementø1 = isSymbol(form) ? [form] : vec(form);
            var idø1 = first(requirementø1);
            var paramsø1 = dictionary.apply(void 0, rest(requirementø1));
            var renamesø1 = (paramsø1 || 0)['\uA789rename'];
            var namesø1 = (paramsø1 || 0)['\uA789refer'];
            var aliasø1 = (paramsø1 || 0)['\uA789as'];
            var referencesø1 = !isEmpty(namesø1) ? reduce(function (refers, reference) {
                    return conj(refers, {
                        'op': 'refer',
                        'form': reference,
                        'name': reference,
                        'rename': (renamesø1 || 0)[reference] || (renamesø1 || 0)[name(reference)],
                        'ns': idø1
                    });
                }, [], namesø1) : void 0;
            return {
                'op': 'require',
                'alias': aliasø1,
                'ns': idø1,
                'refer': referencesø1,
                'form': form
            };
        }.call(this);
    };
var analyzeNs = exports.analyzeNs = function analyzeNs(env, form) {
        return function () {
            var formsø1 = rest(form);
            var nameø1 = first(formsø1);
            var bodyø1 = rest(formsø1);
            var docø1 = isString(first(bodyø1)) ? first(bodyø1) : void 0;
            var referencesø1 = parseReferences(docø1 ? rest(bodyø1) : bodyø1);
            var requirementsø1 = (referencesø1 || 0)['require'] ? map(parseRequire, (referencesø1 || 0)['require']) : void 0;
            return {
                'op': 'ns',
                'name': nameø1,
                'doc': docø1,
                'require': requirementsø1 ? vec(requirementsø1) : void 0,
                'form': form
            };
        }.call(this);
    };
installSpecial('ns', analyzeNs);
var analyzeList = exports.analyzeList = function analyzeList(env, form) {
        return function () {
            var expansionø1 = macroexpand(form, env);
            var operatorø1 = first(form);
            var analyzerø1 = isSymbol(operatorø1) && (__specials__ || 0)[name(operatorø1)];
            return !(expansionø1 === form) ? analyze(env, expansionø1) : analyzerø1 ? analyzeSpecial(analyzerø1, env, expansionø1) : 'else' ? analyzeInvoke(env, expansionø1) : void 0;
        }.call(this);
    };
var analyzeVector = exports.analyzeVector = function analyzeVector(env, form) {
        return function () {
            var itemsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, form));
            return {
                'op': 'vector',
                'form': form,
                'items': itemsø1
            };
        }.call(this);
    };
var analyzeDictionary = exports.analyzeDictionary = function analyzeDictionary(env, form) {
        return function () {
            var namesø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, keys(form)));
            var valuesø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, vals(form)));
            return {
                'op': 'dictionary',
                'keys': namesø1,
                'values': valuesø1,
                'form': form
            };
        }.call(this);
    };
var analyzeInvoke = exports.analyzeInvoke = function analyzeInvoke(env, form) {
        return function () {
            var calleeø1 = analyze(env, first(form));
            var paramsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, rest(form)));
            return {
                'op': 'invoke',
                'callee': calleeø1,
                'params': paramsø1,
                'form': form
            };
        }.call(this);
    };
var analyzeConstant = exports.analyzeConstant = function analyzeConstant(env, form) {
        return {
            'op': 'constant',
            'form': form
        };
    };
var analyze = exports.analyze = function analyze() {
        switch (arguments.length) {
        case 1:
            var form = arguments[0];
            return analyze({
                'locals': {},
                'bindings': [],
                'top': true
            }, form);
        case 2:
            var env = arguments[0];
            var form = arguments[1];
            return isNil(form) ? analyzeConstant(env, form) : isSymbol(form) ? analyzeSymbol(env, form) : isList(form) ? isEmpty(form) ? analyzeQuoted(form) : analyzeList(env, form) : isDictionary(form) ? analyzeDictionary(env, form) : isVector(form) ? analyzeVector(env, form) : isKeyword(form) ? analyzeKeyword(env, form) : 'else' ? analyzeConstant(env, form) : void 0;
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
},{"./ast":9,"./expander":14,"./runtime":33,"./sequence":34,"./string":35}],9:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.ast',
            doc: void 0
        };
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var isSequential = wisp_sequence.isSequential;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var count = wisp_sequence.count;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var repeat = wisp_sequence.repeat;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isVector = wisp_runtime.isVector;
    var isNumber = wisp_runtime.isNumber;
    var isString = wisp_runtime.isString;
    var isBoolean = wisp_runtime.isBoolean;
    var isObject = wisp_runtime.isObject;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isDictionary = wisp_runtime.isDictionary;
    var str = wisp_runtime.str;
    var inc = wisp_runtime.inc;
    var subs = wisp_runtime.subs;
    var isEqual = wisp_runtime.isEqual;
}
var withMeta = exports.withMeta = function withMeta(value, metadata) {
        Object.defineProperty(value, 'metadata', {
            'value': metadata,
            'configurable': true
        });
        return value;
    };
var meta = exports.meta = function meta(value) {
        return isNil(value) ? void 0 : value.metadata;
    };
var __nsSeparator__ = exports.__nsSeparator__ = '\u2044';
var Symbol = function Symbol(namespace, name) {
    this.namespace = namespace;
    this.name = name;
    return this;
};
Symbol.type = 'wisp.symbol';
Symbol.prototype.type = Symbol.type;
Symbol.prototype.toString = function () {
    return function () {
        var prefixø1 = '' + '\uFEFF' + '\'';
        var nsø1 = namespace(this);
        return nsø1 ? '' + prefixø1 + nsø1 + '/' + name(this) : '' + prefixø1 + name(this);
    }.call(this);
};
var symbol = exports.symbol = function symbol(ns, id) {
        return isSymbol(ns) ? ns : isKeyword(ns) ? new Symbol(namespace(ns), name(ns)) : isNil(id) ? new Symbol(void 0, ns) : 'else' ? new Symbol(ns, id) : void 0;
    };
var isSymbol = exports.isSymbol = function isSymbol(x) {
        return isString(x) && '\uFEFF' === x[0] && '\'' === x[1] || x && Symbol.type === x.type;
    };
var isKeyword = exports.isKeyword = function isKeyword(x) {
        return isString(x) && count(x) > 1 && first(x) === '\uA789';
    };
var keyword = exports.keyword = function keyword(ns, id) {
        return isKeyword(ns) ? ns : isSymbol(ns) ? '' + '\uA789' + name(ns) : isNil(id) ? '' + '\uA789' + ns : isNil(ns) ? '' + '\uA789' + id : 'else' ? '' + '\uA789' + ns + __nsSeparator__ + id : void 0;
    };
var keywordName = function keywordName(value) {
    return last(split(subs(value, 1), __nsSeparator__));
};
var symbolName = function symbolName(value) {
    return value.name || last(split(subs(value, 2), __nsSeparator__));
};
var name = exports.name = function name(value) {
        return isSymbol(value) ? symbolName(value) : isKeyword(value) ? keywordName(value) : isString(value) ? value : 'else' ? (function () {
            throw new TypeError('' + 'Doesn\'t support name: ' + value);
        })() : void 0;
    };
var keywordNamespace = function keywordNamespace(x) {
    return function () {
        var partsø1 = split(subs(x, 1), __nsSeparator__);
        return count(partsø1) > 1 ? partsø1[0] : void 0;
    }.call(this);
};
var symbolNamespace = function symbolNamespace(x) {
    return function () {
        var partsø1 = isString(x) ? split(subs(x, 1), __nsSeparator__) : [
                x.namespace,
                x.name
            ];
        return count(partsø1) > 1 ? partsø1[0] : void 0;
    }.call(this);
};
var namespace = exports.namespace = function namespace(x) {
        return isSymbol(x) ? symbolNamespace(x) : isKeyword(x) ? keywordNamespace(x) : 'else' ? (function () {
            throw new TypeError('' + 'Doesn\'t supports namespace: ' + x);
        })() : void 0;
    };
var gensym = exports.gensym = function gensym(prefix) {
        return symbol('' + (isNil(prefix) ? 'G__' : prefix) + (gensym.base = gensym.base + 1));
    };
gensym.base = 0;
var isUnquote = exports.isUnquote = function isUnquote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'unquote'));
    };
var isUnquoteSplicing = exports.isUnquoteSplicing = function isUnquoteSplicing(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'unquote-splicing'));
    };
var isQuote = exports.isQuote = function isQuote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'quote'));
    };
var isSyntaxQuote = exports.isSyntaxQuote = function isSyntaxQuote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'syntax-quote'));
    };
var normalize = function normalize(n, len) {
    return function loop() {
        var recur = loop;
        var nsø1 = '' + n;
        do {
            recur = count(nsø1) < len ? (loop[0] = '' + '0' + nsø1, loop) : nsø1;
        } while (nsø1 = loop[0], recur === loop);
        return recur;
    }.call(this);
};
var quoteString = exports.quoteString = function quoteString(s) {
        s = join('\\"', split(s, '"'));
        s = join('\\\\', split(s, '\\'));
        s = join('\\b', split(s, '\b'));
        s = join('\\f', split(s, '\f'));
        s = join('\\n', split(s, '\n'));
        s = join('\\r', split(s, '\r'));
        s = join('\\t', split(s, '\t'));
        return '' + '"' + s + '"';
    };
var prStr = exports.prStr = function prStr(x, offset) {
        return function () {
            var offsetø2 = offset || 0;
            return isNil(x) ? 'nil' : isKeyword(x) ? namespace(x) ? '' + ':' + namespace(x) + '/' + name(x) : '' + ':' + name(x) : isSymbol(x) ? namespace(x) ? '' + namespace(x) + '/' + name(x) : name(x) : isString(x) ? quoteString(x) : isDate(x) ? '' + '#inst "' + x.getUTCFullYear() + '-' + normalize(inc(x.getUTCMonth()), 2) + '-' + normalize(x.getUTCDate(), 2) + 'T' + normalize(x.getUTCHours(), 2) + ':' + normalize(x.getUTCMinutes(), 2) + ':' + normalize(x.getUTCSeconds(), 2) + '.' + normalize(x.getUTCMilliseconds(), 3) + '-' + '00:00"' : isVector(x) ? '' + '[' + join('' + '\n ' + join(repeat(inc(offsetø2), ' ')), map(function ($1) {
                return prStr($1, inc(offsetø2));
            }, vec(x))) + ']' : isDictionary(x) ? '' + '{' + join('' + ',\n' + join(repeat(inc(offsetø2), ' ')), map(function (pair) {
                return function () {
                    var indentø1 = join(repeat(offsetø2, ' '));
                    var keyø1 = prStr(first(pair), inc(offsetø2));
                    var valueø1 = prStr(second(pair), 2 + offsetø2 + count(keyø1));
                    return '' + keyø1 + ' ' + valueø1;
                }.call(this);
            }, x)) + '}' : isSequential(x) ? '' + '(' + join(' ', map(function ($1) {
                return prStr($1, inc(offsetø2));
            }, vec(x))) + ')' : isRePattern(x) ? '' + '#"' + join('\\/', split(x.source, '/')) + '"' : 'else' ? '' + x : void 0;
        }.call(this);
    };
},{"./runtime":33,"./sequence":34,"./string":35}],10:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.backend.escodegen.generator',
            doc: void 0
        };
    var wisp_reader = require('./../../reader');
    var readString = wisp_reader.readFromString;
    var read_ = wisp_reader.read_;
    var wisp_ast = require('./../../ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var symbol = wisp_ast.symbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var namespace = wisp_ast.namespace;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var isQuote = wisp_ast.isQuote;
    var isSyntaxQuote = wisp_ast.isSyntaxQuote;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var prStr = wisp_ast.prStr;
    var wisp_sequence = require('./../../sequence');
    var isEmpty = wisp_sequence.isEmpty;
    var count = wisp_sequence.count;
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var cons = wisp_sequence.cons;
    var conj = wisp_sequence.conj;
    var butlast = wisp_sequence.butlast;
    var reverse = wisp_sequence.reverse;
    var reduce = wisp_sequence.reduce;
    var vec = wisp_sequence.vec;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var filter = wisp_sequence.filter;
    var take = wisp_sequence.take;
    var concat = wisp_sequence.concat;
    var partition = wisp_sequence.partition;
    var repeat = wisp_sequence.repeat;
    var interleave = wisp_sequence.interleave;
    var wisp_runtime = require('./../../runtime');
    var isOdd = wisp_runtime.isOdd;
    var isDictionary = wisp_runtime.isDictionary;
    var dictionary = wisp_runtime.dictionary;
    var merge = wisp_runtime.merge;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isContainsVector = wisp_runtime.isContainsVector;
    var mapDictionary = wisp_runtime.mapDictionary;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isVector = wisp_runtime.isVector;
    var isBoolean = wisp_runtime.isBoolean;
    var subs = wisp_runtime.subs;
    var reFind = wisp_runtime.reFind;
    var isTrue = wisp_runtime.isTrue;
    var isFalse = wisp_runtime.isFalse;
    var isNil = wisp_runtime.isNil;
    var isRePattern = wisp_runtime.isRePattern;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var str = wisp_runtime.str;
    var char = wisp_runtime.char;
    var int = wisp_runtime.int;
    var isEqual = wisp_runtime.isEqual;
    var isStrictEqual = wisp_runtime.isStrictEqual;
    var wisp_string = require('./../../string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var upperCase = wisp_string.upperCase;
    var replace = wisp_string.replace;
    var wisp_expander = require('./../../expander');
    var installMacro = wisp_expander.installMacro;
    var wisp_analyzer = require('./../../analyzer');
    var emptyEnv = wisp_analyzer.emptyEnv;
    var analyze = wisp_analyzer.analyze;
    var analyze_ = wisp_analyzer.analyze_;
    var wisp_backend_escodegen_writer = require('./writer');
    var write = wisp_backend_escodegen_writer.write;
    var compile = wisp_backend_escodegen_writer.compile;
    var write_ = wisp_backend_escodegen_writer.write_;
    var escodegen = require('escodegen');
    var generate_ = escodegen.generate;
    var base64Encode = require('base64-encode');
    var btoa = base64Encode;
    var fs = require('fs');
    var readFileSync = fs.readFileSync;
    var writeFileSync = fs.writeFileSync;
    var path = require('path');
    var basename = path.basename;
    var dirname = path.dirname;
    var joinPath = path.join;
}
var generate = exports.generate = function generate(options) {
        var nodes = Array.prototype.slice.call(arguments, 1);
        return function () {
            var astø1 = write_.apply(void 0, nodes);
            var outputø1 = generate_(astø1, {
                    'file': (options || 0)['output-uri'],
                    'sourceContent': (options || 0)['source'],
                    'sourceMap': (options || 0)['source-uri'],
                    'sourceMapRoot': (options || 0)['source-root'],
                    'sourceMapWithCode': true
                });
            (outputø1 || 0)['map'].setSourceContent((options || 0)['source-uri'], (options || 0)['source']);
            return {
                'code': (options || 0)['no-map'] ? (outputø1 || 0)['code'] : '' + (outputø1 || 0)['code'] + '\n//# sourceMappingURL=' + 'data:application/json;base64,' + btoa('' + (outputø1 || 0)['map']) + '\n',
                'source-map': (outputø1 || 0)['map'],
                'js-ast': astø1
            };
        }.call(this);
    };
var expandDefmacro = exports.expandDefmacro = function expandDefmacro(andForm, id) {
        var body = Array.prototype.slice.call(arguments, 2);
        return function () {
            var fnø1 = withMeta(list.apply(void 0, [symbol(void 0, 'defn')].concat([id], vec(body))), meta(andForm));
            var formø1 = list.apply(void 0, [symbol(void 0, 'do')].concat([fnø1], [id]));
            var astø1 = analyze(formø1);
            var codeø1 = compile(astø1);
            var macroø1 = eval(codeø1);
            installMacro(id, macroø1);
            return void 0;
        }.call(this);
    };
installMacro(symbol(void 0, 'defmacro'), withMeta(expandDefmacro, { 'implicit': ['&form'] }));
void 0;
},{"./../../analyzer":8,"./../../ast":9,"./../../expander":14,"./../../reader":32,"./../../runtime":33,"./../../sequence":34,"./../../string":35,"./writer":11,"base64-encode":15,"escodegen":16,"fs":2,"path":5}],11:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.backend.escodegen.writer',
            doc: void 0
        };
    var wisp_reader = require('./../../reader');
    var readFromString = wisp_reader.readFromString;
    var wisp_ast = require('./../../ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var symbol = wisp_ast.symbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var namespace = wisp_ast.namespace;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var isQuote = wisp_ast.isQuote;
    var isSyntaxQuote = wisp_ast.isSyntaxQuote;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var prStr = wisp_ast.prStr;
    var wisp_sequence = require('./../../sequence');
    var isEmpty = wisp_sequence.isEmpty;
    var count = wisp_sequence.count;
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var cons = wisp_sequence.cons;
    var conj = wisp_sequence.conj;
    var butlast = wisp_sequence.butlast;
    var reverse = wisp_sequence.reverse;
    var reduce = wisp_sequence.reduce;
    var vec = wisp_sequence.vec;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var filter = wisp_sequence.filter;
    var take = wisp_sequence.take;
    var concat = wisp_sequence.concat;
    var partition = wisp_sequence.partition;
    var repeat = wisp_sequence.repeat;
    var interleave = wisp_sequence.interleave;
    var assoc = wisp_sequence.assoc;
    var wisp_runtime = require('./../../runtime');
    var isOdd = wisp_runtime.isOdd;
    var isDictionary = wisp_runtime.isDictionary;
    var dictionary = wisp_runtime.dictionary;
    var merge = wisp_runtime.merge;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isContainsVector = wisp_runtime.isContainsVector;
    var mapDictionary = wisp_runtime.mapDictionary;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isVector = wisp_runtime.isVector;
    var isBoolean = wisp_runtime.isBoolean;
    var subs = wisp_runtime.subs;
    var reFind = wisp_runtime.reFind;
    var isTrue = wisp_runtime.isTrue;
    var isFalse = wisp_runtime.isFalse;
    var isNil = wisp_runtime.isNil;
    var isRePattern = wisp_runtime.isRePattern;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var str = wisp_runtime.str;
    var char = wisp_runtime.char;
    var int = wisp_runtime.int;
    var isEqual = wisp_runtime.isEqual;
    var isStrictEqual = wisp_runtime.isStrictEqual;
    var wisp_string = require('./../../string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var upperCase = wisp_string.upperCase;
    var replace = wisp_string.replace;
    var wisp_expander = require('./../../expander');
    var installMacro = wisp_expander.installMacro;
    var escodegen = require('escodegen');
    var generate = escodegen.generate;
}
var __uniqueChar__ = exports.__uniqueChar__ = '\xF8';
var toCamelJoin = exports.toCamelJoin = function toCamelJoin(prefix, key) {
        return '' + prefix + (!isEmpty(prefix) && !isEmpty(key) ? '' + upperCase((key || 0)[0]) + subs(key, 1) : key);
    };
var translateIdentifierWord = exports.translateIdentifierWord = function translateIdentifierWord(form) {
        var id = name(form);
        id = id === '*' ? 'multiply' : id === '/' ? 'divide' : id === '+' ? 'sum' : id === '-' ? 'subtract' : id === '=' ? 'equal?' : id === '==' ? 'strict-equal?' : id === '<=' ? 'not-greater-than' : id === '>=' ? 'not-less-than' : id === '>' ? 'greater-than' : id === '<' ? 'less-than' : 'else' ? id : void 0;
        id = join('_', split(id, '*'));
        id = join('-to-', split(id, '->'));
        id = join(split(id, '!'));
        id = join('$', split(id, '%'));
        id = join('-equal-', split(id, '='));
        id = join('-plus-', split(id, '+'));
        id = join('-and-', split(id, '&'));
        id = last(id) === '?' ? '' + 'is-' + subs(id, 0, dec(count(id))) : id;
        id = reduce(toCamelJoin, '', split(id, '-'));
        return id;
    };
var translateIdentifier = exports.translateIdentifier = function translateIdentifier(form) {
        return join('.', map(translateIdentifierWord, split(name(form), '.')));
    };
var errorArgCount = exports.errorArgCount = function errorArgCount(callee, n) {
        return (function () {
            throw SyntaxError('' + 'Wrong number of arguments (' + n + ') passed to: ' + callee);
        })();
    };
var inheritLocation = exports.inheritLocation = function inheritLocation(body) {
        return function () {
            var startø1 = ((first(body) || 0)['loc'] || 0)['start'];
            var endø1 = ((last(body) || 0)['loc'] || 0)['end'];
            return !(isNil(startø1) || isNil(endø1)) ? {
                'start': startø1,
                'end': endø1
            } : void 0;
        }.call(this);
    };
var writeLocation = exports.writeLocation = function writeLocation(form, original) {
        return function () {
            var dataø1 = meta(form);
            var inheritedø1 = meta(original);
            var startø1 = (form || 0)['start'] || (dataø1 || 0)['start'] || (inheritedø1 || 0)['start'];
            var endø1 = (form || 0)['end'] || (dataø1 || 0)['end'] || (inheritedø1 || 0)['end'];
            return !isNil(startø1) ? {
                'loc': {
                    'start': {
                        'line': inc((startø1 || 0)['line']),
                        'column': (startø1 || 0)['column']
                    },
                    'end': {
                        'line': inc((endø1 || 0)['line']),
                        'column': (endø1 || 0)['column']
                    }
                }
            } : {};
        }.call(this);
    };
var __writers__ = exports.__writers__ = {};
var installWriter = exports.installWriter = function installWriter(op, writer) {
        return (__writers__ || 0)[op] = writer;
    };
var writeOp = exports.writeOp = function writeOp(op, form) {
        return function () {
            var writerø1 = (__writers__ || 0)[op];
            !writerø1 ? (function () {
                throw Error('' + 'Assert failed: ' + ('' + 'Unsupported operation: ' + op) + 'writer');
            })() : void 0;
            return conj(writeLocation((form || 0)['form'], (form || 0)['original-form']), writerø1(form));
        }.call(this);
    };
var __specials__ = exports.__specials__ = {};
var installSpecial = exports.installSpecial = function installSpecial(op, writer) {
        return (__specials__ || 0)[name(op)] = writer;
    };
var writeSpecial = exports.writeSpecial = function writeSpecial(writer, form) {
        return conj(writeLocation((form || 0)['form'], (form || 0)['original-form']), writer.apply(void 0, (form || 0)['params']));
    };
var writeNil = exports.writeNil = function writeNil(form) {
        return {
            'type': 'UnaryExpression',
            'operator': 'void',
            'argument': {
                'type': 'Literal',
                'value': 0
            },
            'prefix': true
        };
    };
installWriter('nil', writeNil);
var writeLiteral = exports.writeLiteral = function writeLiteral(form) {
        return {
            'type': 'Literal',
            'value': form
        };
    };
var writeList = exports.writeList = function writeList(form) {
        return {
            'type': 'CallExpression',
            'callee': write({
                'op': 'var',
                'form': symbol(void 0, 'list')
            }),
            'arguments': map(write, (form || 0)['items'])
        };
    };
installWriter('list', writeList);
var writeSymbol = exports.writeSymbol = function writeSymbol(form) {
        return {
            'type': 'CallExpression',
            'callee': write({
                'op': 'var',
                'form': symbol(void 0, 'symbol')
            }),
            'arguments': [
                writeConstant((form || 0)['namespace']),
                writeConstant((form || 0)['name'])
            ]
        };
    };
installWriter('symbol', writeSymbol);
var writeConstant = exports.writeConstant = function writeConstant(form) {
        return isNil(form) ? writeNil(form) : isKeyword(form) ? writeLiteral(name(form)) : isNumber(form) ? writeNumber(form.valueOf()) : isString(form) ? writeString(form) : 'else' ? writeLiteral(form) : void 0;
    };
installWriter('constant', function ($1) {
    return writeConstant(($1 || 0)['form']);
});
var writeString = exports.writeString = function writeString(form) {
        return {
            'type': 'Literal',
            'value': '' + form
        };
    };
var writeNumber = exports.writeNumber = function writeNumber(form) {
        return form < 0 ? {
            'type': 'UnaryExpression',
            'operator': '-',
            'prefix': true,
            'argument': writeNumber(form * -1)
        } : writeLiteral(form);
    };
var writeKeyword = exports.writeKeyword = function writeKeyword(form) {
        return {
            'type': 'Literal',
            'value': (form || 0)['form']
        };
    };
installWriter('keyword', writeKeyword);
var toIdentifier = exports.toIdentifier = function toIdentifier(form) {
        return {
            'type': 'Identifier',
            'name': translateIdentifier(form)
        };
    };
var writeBindingVar = exports.writeBindingVar = function writeBindingVar(form) {
        return function () {
            var idø1 = name((form || 0)['id']);
            return conj(toIdentifier((form || 0)['shadow'] ? '' + translateIdentifier(idø1) + __uniqueChar__ + (form || 0)['depth'] : idø1), writeLocation((form || 0)['id']));
        }.call(this);
    };
var writeVar = exports.writeVar = function writeVar(node) {
        return isEqual('binding', ((node || 0)['binding'] || 0)['type']) ? conj(writeBindingVar((node || 0)['binding']), writeLocation((node || 0)['form'])) : conj(writeLocation((node || 0)['form']), toIdentifier(name((node || 0)['form'])));
    };
installWriter('var', writeVar);
installWriter('param', writeVar);
var writeInvoke = exports.writeInvoke = function writeInvoke(form) {
        return {
            'type': 'CallExpression',
            'callee': write((form || 0)['callee']),
            'arguments': map(write, (form || 0)['params'])
        };
    };
installWriter('invoke', writeInvoke);
var writeVector = exports.writeVector = function writeVector(form) {
        return {
            'type': 'ArrayExpression',
            'elements': map(write, (form || 0)['items'])
        };
    };
installWriter('vector', writeVector);
var writeDictionary = exports.writeDictionary = function writeDictionary(form) {
        return function () {
            var propertiesø1 = partition(2, interleave((form || 0)['keys'], (form || 0)['values']));
            return {
                'type': 'ObjectExpression',
                'properties': map(function (pair) {
                    return function () {
                        var keyø1 = first(pair);
                        var valueø1 = second(pair);
                        return {
                            'kind': 'init',
                            'type': 'Property',
                            'key': isEqual('symbol', (keyø1 || 0)['op']) ? writeConstant('' + (keyø1 || 0)['form']) : write(keyø1),
                            'value': write(valueø1)
                        };
                    }.call(this);
                }, propertiesø1)
            };
        }.call(this);
    };
installWriter('dictionary', writeDictionary);
var writeExport = exports.writeExport = function writeExport(form) {
        return write({
            'op': 'set!',
            'target': {
                'op': 'member-expression',
                'computed': false,
                'target': {
                    'op': 'var',
                    'form': withMeta(symbol(void 0, 'exports'), meta(((form || 0)['id'] || 0)['form']))
                },
                'property': (form || 0)['id'],
                'form': ((form || 0)['id'] || 0)['form']
            },
            'value': (form || 0)['init'],
            'form': ((form || 0)['id'] || 0)['form']
        });
    };
var writeDef = exports.writeDef = function writeDef(form) {
        return conj({
            'type': 'VariableDeclaration',
            'kind': 'var',
            'declarations': [conj({
                    'type': 'VariableDeclarator',
                    'id': write((form || 0)['id']),
                    'init': conj((form || 0)['export'] ? writeExport(form) : write((form || 0)['init']))
                }, writeLocation(((form || 0)['id'] || 0)['form']))]
        }, writeLocation((form || 0)['form'], (form || 0)['original-form']));
    };
installWriter('def', writeDef);
var writeBinding = exports.writeBinding = function writeBinding(form) {
        return function () {
            var idø1 = writeBindingVar(form);
            var initø1 = write((form || 0)['init']);
            return {
                'type': 'VariableDeclaration',
                'kind': 'var',
                'loc': inheritLocation([
                    idø1,
                    initø1
                ]),
                'declarations': [{
                        'type': 'VariableDeclarator',
                        'id': idø1,
                        'init': initø1
                    }]
            };
        }.call(this);
    };
installWriter('binding', writeBinding);
var writeThrow = exports.writeThrow = function writeThrow(form) {
        return toExpression(conj({
            'type': 'ThrowStatement',
            'argument': write((form || 0)['throw'])
        }, writeLocation((form || 0)['form'], (form || 0)['original-form'])));
    };
installWriter('throw', writeThrow);
var writeNew = exports.writeNew = function writeNew(form) {
        return {
            'type': 'NewExpression',
            'callee': write((form || 0)['constructor']),
            'arguments': map(write, (form || 0)['params'])
        };
    };
installWriter('new', writeNew);
var writeSet = exports.writeSet = function writeSet(form) {
        return {
            'type': 'AssignmentExpression',
            'operator': '=',
            'left': write((form || 0)['target']),
            'right': write((form || 0)['value'])
        };
    };
installWriter('set!', writeSet);
var writeAget = exports.writeAget = function writeAget(form) {
        return {
            'type': 'MemberExpression',
            'computed': (form || 0)['computed'],
            'object': write((form || 0)['target']),
            'property': write((form || 0)['property'])
        };
    };
installWriter('member-expression', writeAget);
var __statements__ = exports.__statements__ = {
        'EmptyStatement': true,
        'BlockStatement': true,
        'ExpressionStatement': true,
        'IfStatement': true,
        'LabeledStatement': true,
        'BreakStatement': true,
        'ContinueStatement': true,
        'SwitchStatement': true,
        'ReturnStatement': true,
        'ThrowStatement': true,
        'TryStatement': true,
        'WhileStatement': true,
        'DoWhileStatement': true,
        'ForStatement': true,
        'ForInStatement': true,
        'ForOfStatement': true,
        'LetStatement': true,
        'VariableDeclaration': true,
        'FunctionDeclaration': true
    };
var writeStatement = exports.writeStatement = function writeStatement(form) {
        return toStatement(write(form));
    };
var toStatement = exports.toStatement = function toStatement(node) {
        return (__statements__ || 0)[(node || 0)['type']] ? node : {
            'type': 'ExpressionStatement',
            'expression': node,
            'loc': (node || 0)['loc']
        };
    };
var toReturn = exports.toReturn = function toReturn(form) {
        return conj({
            'type': 'ReturnStatement',
            'argument': write(form)
        }, writeLocation((form || 0)['form'], (form || 0)['original-form']));
    };
var writeBody = exports.writeBody = function writeBody(form) {
        return function () {
            var statementsø1 = map(writeStatement, (form || 0)['statements'] || []);
            var resultø1 = (form || 0)['result'] ? toReturn((form || 0)['result']) : void 0;
            return resultø1 ? conj(statementsø1, resultø1) : statementsø1;
        }.call(this);
    };
var toBlock = exports.toBlock = function toBlock(body) {
        return isVector(body) ? {
            'type': 'BlockStatement',
            'body': body,
            'loc': inheritLocation(body)
        } : {
            'type': 'BlockStatement',
            'body': [body],
            'loc': (body || 0)['loc']
        };
    };
var toExpression = exports.toExpression = function toExpression() {
        var body = Array.prototype.slice.call(arguments, 0);
        return {
            'type': 'CallExpression',
            'arguments': [],
            'loc': inheritLocation(body),
            'callee': toSequence([{
                    'type': 'FunctionExpression',
                    'id': void 0,
                    'params': [],
                    'defaults': [],
                    'expression': false,
                    'generator': false,
                    'rest': void 0,
                    'body': toBlock(body)
                }])
        };
    };
var writeDo = exports.writeDo = function writeDo(form) {
        return (meta(first((form || 0)['form'])) || 0)['block'] ? toBlock(writeBody(conj(form, {
            'result': void 0,
            'statements': conj((form || 0)['statements'], (form || 0)['result'])
        }))) : toExpression.apply(void 0, writeBody(form));
    };
installWriter('do', writeDo);
var writeIf = exports.writeIf = function writeIf(form) {
        return {
            'type': 'ConditionalExpression',
            'test': write((form || 0)['test']),
            'consequent': write((form || 0)['consequent']),
            'alternate': write((form || 0)['alternate'])
        };
    };
installWriter('if', writeIf);
var writeTry = exports.writeTry = function writeTry(form) {
        return function () {
            var handlerø1 = (form || 0)['handler'];
            var finalizerø1 = (form || 0)['finalizer'];
            return toExpression(conj({
                'type': 'TryStatement',
                'guardedHandlers': [],
                'block': toBlock(writeBody((form || 0)['body'])),
                'handlers': handlerø1 ? [{
                        'type': 'CatchClause',
                        'param': write((handlerø1 || 0)['name']),
                        'body': toBlock(writeBody(handlerø1))
                    }] : [],
                'finalizer': finalizerø1 ? toBlock(writeBody(finalizerø1)) : !handlerø1 ? toBlock([]) : 'else' ? void 0 : void 0
            }, writeLocation((form || 0)['form'], (form || 0)['original-form'])));
        }.call(this);
    };
installWriter('try', writeTry);
var writeBindingValue = function writeBindingValue(form) {
    return write((form || 0)['init']);
};
var writeBindingParam = function writeBindingParam(form) {
    return writeVar({ 'form': (form || 0)['name'] });
};
var writeBinding = exports.writeBinding = function writeBinding(form) {
        return write({
            'op': 'def',
            'var': form,
            'init': (form || 0)['init'],
            'form': form
        });
    };
var writeLet = exports.writeLet = function writeLet(form) {
        return function () {
            var bodyø1 = conj(form, { 'statements': vec(concat((form || 0)['bindings'], (form || 0)['statements'])) });
            return toIife(toBlock(writeBody(bodyø1)));
        }.call(this);
    };
installWriter('let', writeLet);
var toRebind = exports.toRebind = function toRebind(form) {
        return function loop() {
            var recur = loop;
            var resultø1 = [];
            var bindingsø1 = (form || 0)['bindings'];
            do {
                recur = isEmpty(bindingsø1) ? resultø1 : (loop[0] = conj(resultø1, {
                    'type': 'AssignmentExpression',
                    'operator': '=',
                    'left': writeBindingVar(first(bindingsø1)),
                    'right': {
                        'type': 'MemberExpression',
                        'computed': true,
                        'object': {
                            'type': 'Identifier',
                            'name': 'loop'
                        },
                        'property': {
                            'type': 'Literal',
                            'value': count(resultø1)
                        }
                    }
                }), loop[1] = rest(bindingsø1), loop);
            } while (resultø1 = loop[0], bindingsø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var toSequence = exports.toSequence = function toSequence(expressions) {
        return {
            'type': 'SequenceExpression',
            'expressions': expressions
        };
    };
var toIife = exports.toIife = function toIife(body, id) {
        return {
            'type': 'CallExpression',
            'arguments': [{ 'type': 'ThisExpression' }],
            'callee': {
                'type': 'MemberExpression',
                'computed': false,
                'object': {
                    'type': 'FunctionExpression',
                    'id': id,
                    'params': [],
                    'defaults': [],
                    'expression': false,
                    'generator': false,
                    'rest': void 0,
                    'body': body
                },
                'property': {
                    'type': 'Identifier',
                    'name': 'call'
                }
            }
        };
    };
var toLoopInit = exports.toLoopInit = function toLoopInit() {
        return {
            'type': 'VariableDeclaration',
            'kind': 'var',
            'declarations': [{
                    'type': 'VariableDeclarator',
                    'id': {
                        'type': 'Identifier',
                        'name': 'recur'
                    },
                    'init': {
                        'type': 'Identifier',
                        'name': 'loop'
                    }
                }]
        };
    };
var toDoWhile = exports.toDoWhile = function toDoWhile(body, test) {
        return {
            'type': 'DoWhileStatement',
            'body': body,
            'test': test
        };
    };
var toSetRecur = exports.toSetRecur = function toSetRecur(form) {
        return {
            'type': 'AssignmentExpression',
            'operator': '=',
            'left': {
                'type': 'Identifier',
                'name': 'recur'
            },
            'right': write(form)
        };
    };
var toLoop = exports.toLoop = function toLoop(form) {
        return toSequence(conj(toRebind(form), {
            'type': 'BinaryExpression',
            'operator': '===',
            'left': {
                'type': 'Identifier',
                'name': 'recur'
            },
            'right': {
                'type': 'Identifier',
                'name': 'loop'
            }
        }));
    };
var writeLoop = exports.writeLoop = function writeLoop(form) {
        return function () {
            var statementsø1 = (form || 0)['statements'];
            var resultø1 = (form || 0)['result'];
            var bindingsø1 = (form || 0)['bindings'];
            var loopBodyø1 = conj(map(writeStatement, statementsø1), toStatement(toSetRecur(resultø1)));
            var bodyø1 = concat([toLoopInit()], map(write, bindingsø1), [toDoWhile(toBlock(vec(loopBodyø1)), toLoop(form))], [{
                        'type': 'ReturnStatement',
                        'argument': {
                            'type': 'Identifier',
                            'name': 'recur'
                        }
                    }]);
            return toIife(toBlock(vec(bodyø1)), symbol(void 0, 'loop'));
        }.call(this);
    };
installWriter('loop', writeLoop);
var toRecur = exports.toRecur = function toRecur(form) {
        return function loop() {
            var recur = loop;
            var resultø1 = [];
            var paramsø1 = (form || 0)['params'];
            do {
                recur = isEmpty(paramsø1) ? resultø1 : (loop[0] = conj(resultø1, {
                    'type': 'AssignmentExpression',
                    'operator': '=',
                    'right': write(first(paramsø1)),
                    'left': {
                        'type': 'MemberExpression',
                        'computed': true,
                        'object': {
                            'type': 'Identifier',
                            'name': 'loop'
                        },
                        'property': {
                            'type': 'Literal',
                            'value': count(resultø1)
                        }
                    }
                }), loop[1] = rest(paramsø1), loop);
            } while (resultø1 = loop[0], paramsø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var writeRecur = exports.writeRecur = function writeRecur(form) {
        return toSequence(conj(toRecur(form), {
            'type': 'Identifier',
            'name': 'loop'
        }));
    };
installWriter('recur', writeRecur);
var fallbackOverload = exports.fallbackOverload = function fallbackOverload() {
        return {
            'type': 'SwitchCase',
            'test': void 0,
            'consequent': [{
                    'type': 'ThrowStatement',
                    'argument': {
                        'type': 'CallExpression',
                        'callee': {
                            'type': 'Identifier',
                            'name': 'RangeError'
                        },
                        'arguments': [{
                                'type': 'Literal',
                                'value': 'Wrong number of arguments passed'
                            }]
                    }
                }]
        };
    };
var spliceBinding = exports.spliceBinding = function spliceBinding(form) {
        return {
            'op': 'def',
            'id': last((form || 0)['params']),
            'init': {
                'op': 'invoke',
                'callee': {
                    'op': 'var',
                    'form': symbol(void 0, 'Array.prototype.slice.call')
                },
                'params': [
                    {
                        'op': 'var',
                        'form': symbol(void 0, 'arguments')
                    },
                    {
                        'op': 'constant',
                        'form': (form || 0)['arity'],
                        'type': 'number'
                    }
                ]
            }
        };
    };
var writeOverloadingParams = exports.writeOverloadingParams = function writeOverloadingParams(params) {
        return reduce(function (forms, param) {
            return conj(forms, {
                'op': 'def',
                'id': param,
                'init': {
                    'op': 'member-expression',
                    'computed': true,
                    'target': {
                        'op': 'var',
                        'form': symbol(void 0, 'arguments')
                    },
                    'property': {
                        'op': 'constant',
                        'type': 'number',
                        'form': count(forms)
                    }
                }
            });
        }, [], params);
    };
var writeOverloadingFn = exports.writeOverloadingFn = function writeOverloadingFn(form) {
        return function () {
            var overloadsø1 = map(writeFnOverload, (form || 0)['methods']);
            return {
                'params': [],
                'body': toBlock({
                    'type': 'SwitchStatement',
                    'discriminant': {
                        'type': 'MemberExpression',
                        'computed': false,
                        'object': {
                            'type': 'Identifier',
                            'name': 'arguments'
                        },
                        'property': {
                            'type': 'Identifier',
                            'name': 'length'
                        }
                    },
                    'cases': (form || 0)['variadic'] ? overloadsø1 : conj(overloadsø1, fallbackOverload())
                })
            };
        }.call(this);
    };
var writeFnOverload = exports.writeFnOverload = function writeFnOverload(form) {
        return function () {
            var paramsø1 = (form || 0)['params'];
            var bindingsø1 = (form || 0)['variadic'] ? conj(writeOverloadingParams(butlast(paramsø1)), spliceBinding(form)) : writeOverloadingParams(paramsø1);
            var statementsø1 = vec(concat(bindingsø1, (form || 0)['statements']));
            return {
                'type': 'SwitchCase',
                'test': !(form || 0)['variadic'] ? {
                    'type': 'Literal',
                    'value': (form || 0)['arity']
                } : void 0,
                'consequent': writeBody(conj(form, { 'statements': statementsø1 }))
            };
        }.call(this);
    };
var writeSimpleFn = exports.writeSimpleFn = function writeSimpleFn(form) {
        return function () {
            var methodø1 = first((form || 0)['methods']);
            var paramsø1 = (methodø1 || 0)['variadic'] ? butlast((methodø1 || 0)['params']) : (methodø1 || 0)['params'];
            var bodyø1 = (methodø1 || 0)['variadic'] ? conj(methodø1, { 'statements': vec(cons(spliceBinding(methodø1), (methodø1 || 0)['statements'])) }) : methodø1;
            return {
                'params': map(writeVar, paramsø1),
                'body': toBlock(writeBody(bodyø1))
            };
        }.call(this);
    };
var resolve = exports.resolve = function resolve(from, to) {
        return function () {
            var requirerø1 = split(name(from), '.');
            var requirementø1 = split(name(to), '.');
            var isRelativeø1 = !(name(from) === name(to)) && first(requirerø1) === first(requirementø1);
            return isRelativeø1 ? function loop() {
                var recur = loop;
                var fromø2 = requirerø1;
                var toø2 = requirementø1;
                do {
                    recur = first(fromø2) === first(toø2) ? (loop[0] = rest(fromø2), loop[1] = rest(toø2), loop) : join('/', concat(['.'], repeat(dec(count(fromø2)), '..'), toø2));
                } while (fromø2 = loop[0], toø2 = loop[1], recur === loop);
                return recur;
            }.call(this) : join('/', requirementø1);
        }.call(this);
    };
var idToNs = exports.idToNs = function idToNs(id) {
        return symbol(void 0, join('*', split(name(id), '.')));
    };
var writeRequire = exports.writeRequire = function writeRequire(form, requirer) {
        return function () {
            var nsBindingø1 = {
                    'op': 'def',
                    'id': {
                        'op': 'var',
                        'type': 'identifier',
                        'form': idToNs((form || 0)['ns'])
                    },
                    'init': {
                        'op': 'invoke',
                        'callee': {
                            'op': 'var',
                            'type': 'identifier',
                            'form': symbol(void 0, 'require')
                        },
                        'params': [{
                                'op': 'constant',
                                'form': resolve(requirer, (form || 0)['ns'])
                            }]
                    }
                };
            var nsAliasø1 = (form || 0)['alias'] ? {
                    'op': 'def',
                    'id': {
                        'op': 'var',
                        'type': 'identifier',
                        'form': idToNs((form || 0)['alias'])
                    },
                    'init': (nsBindingø1 || 0)['id']
                } : void 0;
            var referencesø1 = reduce(function (references, form) {
                    return conj(references, {
                        'op': 'def',
                        'id': {
                            'op': 'var',
                            'type': 'identifier',
                            'form': (form || 0)['rename'] || (form || 0)['name']
                        },
                        'init': {
                            'op': 'member-expression',
                            'computed': false,
                            'target': (nsBindingø1 || 0)['id'],
                            'property': {
                                'op': 'var',
                                'type': 'identifier',
                                'form': (form || 0)['name']
                            }
                        }
                    });
                }, [], (form || 0)['refer']);
            return vec(cons(nsBindingø1, nsAliasø1 ? cons(nsAliasø1, referencesø1) : referencesø1));
        }.call(this);
    };
var writeNs = exports.writeNs = function writeNs(form) {
        return function () {
            var nodeø1 = (form || 0)['form'];
            var requirerø1 = (form || 0)['name'];
            var nsBindingø1 = {
                    'op': 'def',
                    'original-form': nodeø1,
                    'id': {
                        'op': 'var',
                        'type': 'identifier',
                        'original-form': first(nodeø1),
                        'form': symbol(void 0, '*ns*')
                    },
                    'init': {
                        'op': 'dictionary',
                        'form': nodeø1,
                        'keys': [
                            {
                                'op': 'var',
                                'type': 'identifier',
                                'original-form': nodeø1,
                                'form': symbol(void 0, 'id')
                            },
                            {
                                'op': 'var',
                                'type': 'identifier',
                                'original-form': nodeø1,
                                'form': symbol(void 0, 'doc')
                            }
                        ],
                        'values': [
                            {
                                'op': 'constant',
                                'type': 'identifier',
                                'original-form': (form || 0)['name'],
                                'form': name((form || 0)['name'])
                            },
                            {
                                'op': 'constant',
                                'original-form': nodeø1,
                                'form': (form || 0)['doc']
                            }
                        ]
                    }
                };
            var requirementsø1 = vec(concat.apply(void 0, map(function ($1) {
                    return writeRequire($1, requirerø1);
                }, (form || 0)['require'])));
            return toBlock(map(write, vec(cons(nsBindingø1, requirementsø1))));
        }.call(this);
    };
installWriter('ns', writeNs);
var writeFn = exports.writeFn = function writeFn(form) {
        return function () {
            var baseø1 = count((form || 0)['methods']) > 1 ? writeOverloadingFn(form) : writeSimpleFn(form);
            return conj(baseø1, {
                'type': 'FunctionExpression',
                'id': (form || 0)['id'] ? writeVar((form || 0)['id']) : void 0,
                'defaults': void 0,
                'rest': void 0,
                'generator': false,
                'expression': false
            });
        }.call(this);
    };
installWriter('fn', writeFn);
var write = exports.write = function write(form) {
        return function () {
            var opø1 = (form || 0)['op'];
            var writerø1 = isEqual('invoke', (form || 0)['op']) && isEqual('var', ((form || 0)['callee'] || 0)['op']) && (__specials__ || 0)[name(((form || 0)['callee'] || 0)['form'])];
            return writerø1 ? writeSpecial(writerø1, form) : writeOp((form || 0)['op'], form);
        }.call(this);
    };
var write_ = exports.write_ = function write_() {
        var forms = Array.prototype.slice.call(arguments, 0);
        return function () {
            var bodyø1 = map(writeStatement, forms);
            return {
                'type': 'Program',
                'body': bodyø1,
                'loc': inheritLocation(bodyø1)
            };
        }.call(this);
    };
var compile = exports.compile = function compile() {
        switch (arguments.length) {
        case 1:
            var form = arguments[0];
            return compile({}, form);
        default:
            var options = arguments[0];
            var forms = Array.prototype.slice.call(arguments, 1);
            return generate(write_.apply(void 0, forms), options);
        }
    };
var getMacro = exports.getMacro = function getMacro(target, property) {
        return list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, 'or')].concat([target], [0]))], [property]));
    };
installMacro('get', getMacro);
var installLogicalOperator = exports.installLogicalOperator = function installLogicalOperator(callee, operator, fallback) {
        var writeLogicalOperator = function writeLogicalOperator() {
            var operands = Array.prototype.slice.call(arguments, 0);
            return function () {
                var nø1 = count(operands);
                return isEqual(nø1, 0) ? writeConstant(fallback) : isEqual(nø1, 1) ? write(first(operands)) : 'else' ? reduce(function (left, right) {
                    return {
                        'type': 'LogicalExpression',
                        'operator': operator,
                        'left': left,
                        'right': write(right)
                    };
                }, write(first(operands)), rest(operands)) : void 0;
            }.call(this);
        };
        return installSpecial(callee, writeLogicalOperator);
    };
installLogicalOperator('or', '||', void 0);
installLogicalOperator('and', '&&', true);
var installUnaryOperator = exports.installUnaryOperator = function installUnaryOperator(callee, operator, isPrefix) {
        var writeUnaryOperator = function writeUnaryOperator() {
            var params = Array.prototype.slice.call(arguments, 0);
            return count(params) === 1 ? {
                'type': 'UnaryExpression',
                'operator': operator,
                'argument': write(first(params)),
                'prefix': isPrefix
            } : errorArgCount(callee, count(params));
        };
        return installSpecial(callee, writeUnaryOperator);
    };
installUnaryOperator('not', '!');
installUnaryOperator('bit-not', '~');
var installBinaryOperator = exports.installBinaryOperator = function installBinaryOperator(callee, operator) {
        var writeBinaryOperator = function writeBinaryOperator() {
            var params = Array.prototype.slice.call(arguments, 0);
            return count(params) < 2 ? errorArgCount(callee, count(params)) : reduce(function (left, right) {
                return {
                    'type': 'BinaryExpression',
                    'operator': operator,
                    'left': left,
                    'right': write(right)
                };
            }, write(first(params)), rest(params));
        };
        return installSpecial(callee, writeBinaryOperator);
    };
installBinaryOperator('bit-and', '&');
installBinaryOperator('bit-or', '|');
installBinaryOperator('bit-xor', '^');
installBinaryOperator('bit-shift-left', '<<');
installBinaryOperator('bit-shift-right', '>>');
installBinaryOperator('bit-shift-right-zero-fil', '>>>');
var installArithmeticOperator = exports.installArithmeticOperator = function installArithmeticOperator(callee, operator, isValid, fallback) {
        var writeBinaryOperator = function writeBinaryOperator(left, right) {
            return {
                'type': 'BinaryExpression',
                'operator': name(operator),
                'left': left,
                'right': write(right)
            };
        };
        var writeArithmeticOperator = function writeArithmeticOperator() {
            var params = Array.prototype.slice.call(arguments, 0);
            return function () {
                var nø1 = count(params);
                return isValid && !isValid(nø1) ? errorArgCount(name(callee), nø1) : nø1 == 0 ? writeLiteral(fallback) : nø1 == 1 ? reduce(writeBinaryOperator, writeLiteral(fallback), params) : 'else' ? reduce(writeBinaryOperator, write(first(params)), rest(params)) : void 0;
            }.call(this);
        };
        return installSpecial(callee, writeArithmeticOperator);
    };
installArithmeticOperator('+', '+', void 0, 0);
installArithmeticOperator('-', '-', function ($1) {
    return $1 >= 1;
}, 0);
installArithmeticOperator('*', '*', void 0, 1);
installArithmeticOperator(keyword('/'), keyword('/'), function ($1) {
    return $1 >= 1;
}, 1);
installArithmeticOperator('mod', keyword('%'), function ($1) {
    return $1 == 2;
}, 1);
var installComparisonOperator = exports.installComparisonOperator = function installComparisonOperator(callee, operator, fallback) {
        var writeComparisonOperator = function writeComparisonOperator() {
            switch (arguments.length) {
            case 0:
                return errorArgCount(callee, 0);
            case 1:
                var form = arguments[0];
                return toSequence([
                    write(form),
                    writeLiteral(fallback)
                ]);
            case 2:
                var left = arguments[0];
                var right = arguments[1];
                return {
                    'type': 'BinaryExpression',
                    'operator': operator,
                    'left': write(left),
                    'right': write(right)
                };
            default:
                var left = arguments[0];
                var right = arguments[1];
                var more = Array.prototype.slice.call(arguments, 2);
                return reduce(function (left, right) {
                    return {
                        'type': 'LogicalExpression',
                        'operator': '&&',
                        'left': left,
                        'right': {
                            'type': 'BinaryExpression',
                            'operator': operator,
                            'left': isEqual('LogicalExpression', (left || 0)['type']) ? ((left || 0)['right'] || 0)['right'] : (left || 0)['right'],
                            'right': write(right)
                        }
                    };
                }, writeComparisonOperator(left, right), more);
            }
        };
        return installSpecial(callee, writeComparisonOperator);
    };
installComparisonOperator('==', '==', true);
installComparisonOperator('>', '>', true);
installComparisonOperator('>=', '>=', true);
installComparisonOperator('<', '<', true);
installComparisonOperator('<=', '<=', true);
var isWriteIdentical = exports.isWriteIdentical = function isWriteIdentical() {
        var params = Array.prototype.slice.call(arguments, 0);
        return count(params) === 2 ? {
            'type': 'BinaryExpression',
            'operator': '===',
            'left': write(first(params)),
            'right': write(second(params))
        } : errorArgCount('identical?', count(params));
    };
installSpecial('identical?', isWriteIdentical);
var isWriteInstance = exports.isWriteInstance = function isWriteInstance() {
        var params = Array.prototype.slice.call(arguments, 0);
        return function () {
            var constructorø1 = first(params);
            var instanceø1 = second(params);
            return count(params) < 1 ? errorArgCount('instance?', count(params)) : {
                'type': 'BinaryExpression',
                'operator': 'instanceof',
                'left': instanceø1 ? write(instanceø1) : writeConstant(instanceø1),
                'right': write(constructorø1)
            };
        }.call(this);
    };
installSpecial('instance?', isWriteInstance);
var expandApply = exports.expandApply = function expandApply(f) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var prefixø1 = vec(butlast(params));
            return isEmpty(prefixø1) ? list.apply(void 0, [symbol(void 0, '.apply')].concat([f], [void 0], vec(params))) : list.apply(void 0, [symbol(void 0, '.apply')].concat([f], [void 0], [list.apply(void 0, [symbol(void 0, '.concat')].concat([prefixø1], [last(params)]))]));
        }.call(this);
    };
installMacro('apply', expandApply);
var expandPrint = exports.expandPrint = function expandPrint(andForm) {
        var more = Array.prototype.slice.call(arguments, 1);
        'Prints the object(s) to the output for human consumption.';
        return function () {
            var opø1 = withMeta(symbol(void 0, 'console.log'), meta(andForm));
            return list.apply(void 0, [opø1].concat(vec(more)));
        }.call(this);
    };
installMacro('print', withMeta(expandPrint, { 'implicit': ['&form'] }));
var expandStr = exports.expandStr = function expandStr() {
        var forms = Array.prototype.slice.call(arguments, 0);
        return list.apply(void 0, [symbol(void 0, '+')].concat([''], vec(forms)));
    };
installMacro('str', expandStr);
var expandDebug = exports.expandDebug = function expandDebug() {
        return symbol(void 0, 'debugger');
    };
installMacro('debugger!', expandDebug);
var expandAssert = exports.expandAssert = function expandAssert() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return expandAssert(x, '');
        case 2:
            var x = arguments[0];
            var message = arguments[1];
            return function () {
                var formø1 = prStr(x);
                return list.apply(void 0, [symbol(void 0, 'if')].concat([list.apply(void 0, [symbol(void 0, 'not')].concat([x]))], [list.apply(void 0, [symbol(void 0, 'throw')].concat([list.apply(void 0, [symbol(void 0, 'Error')].concat([list.apply(void 0, [symbol(void 0, 'str')].concat(['Assert failed: '], [message], [formø1]))]))]))]));
            }.call(this);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
installMacro('assert', expandAssert);
var expandDefprotocol = exports.expandDefprotocol = function expandDefprotocol(andEnv, id) {
        var forms = Array.prototype.slice.call(arguments, 2);
        return function () {
            var nsø1 = (((andEnv || 0)['ns'] || 0)['name'] || 0)['name'];
            var protocolNameø1 = name(id);
            var specø1 = reduce(function (spec, form) {
                    return function () {
                        var signaturesø1 = (spec || 0)['signatures'];
                        var methodNameø1 = first(form);
                        var paramsø1 = map(name, second(form));
                        var idø2 = idToNs('' + nsø1 + '$' + protocolNameø1 + '$' + name(methodNameø1));
                        var methodIdø1 = translateIdentifierWord(idø2);
                        return conj(spec, {
                            'signatures': assoc(signaturesø1, methodNameø1, paramsø1),
                            'methods': assoc((spec || 0)['methods'], methodNameø1, methodIdø1),
                            'fns': conj((spec || 0)['fns'], list.apply(void 0, [symbol(void 0, 'defn')].concat([methodNameø1], [[symbol(void 0, 'instance')].concat()], [list.apply(void 0, [symbol(void 0, '.apply')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([symbol(void 0, 'instance')], [list.apply(void 0, [symbol(void 0, 'quote')].concat([idø2]))]))], [symbol(void 0, 'instance')], [symbol(void 0, 'arguments')]))])))
                        });
                    }.call(this);
                }, {
                    'fns': [],
                    'methods': {},
                    'signatures': {}
                }, forms);
            var fnsø1 = (specø1 || 0)['fns'];
            var protocolø1 = {
                    'id': '' + nsø1 + '/' + protocolNameø1,
                    'methods': (specø1 || 0)['methods'],
                    'signatures': (specø1 || 0)['signatures']
                };
            return list.apply(void 0, [withMeta(symbol(void 0, 'do'), { 'block': true })].concat([list.apply(void 0, [symbol(void 0, 'def')].concat([id], [protocolø1]))], vec(fnsø1)));
        }.call(this);
    };
installMacro('defprotocol', withMeta(expandDefprotocol, { 'implicit': ['&env'] }));
var expandDeftype = exports.expandDeftype = function expandDeftype(name, fields) {
        var forms = Array.prototype.slice.call(arguments, 2);
        return function () {
            var typeInitø1 = map(function (field) {
                    return list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([symbol(void 0, 'this')], [list.apply(void 0, [symbol(void 0, 'quote')].concat([field]))]))], [field]));
                }, fields);
            var constructorø1 = conj(typeInitø1, symbol(void 0, 'this'));
            var methodInitø1 = map(function (field) {
                    return list.apply(void 0, [symbol(void 0, 'def')].concat([field], [list.apply(void 0, [symbol(void 0, 'aget')].concat([symbol(void 0, 'this')], [list.apply(void 0, [symbol(void 0, 'quote')].concat([field]))]))]));
                }, fields);
            var makeMethodø1 = function (protocol, form) {
                return function () {
                    var methodNameø1 = first(form);
                    var paramsø1 = second(form);
                    var bodyø1 = rest(rest(form));
                    return list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, '.-prototype')].concat([name]))], [list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, '.-methods')].concat([protocol]))], [list.apply(void 0, [symbol(void 0, 'quote')].concat([methodNameø1]))]))]))], [list.apply(void 0, [symbol(void 0, 'fn')].concat([paramsø1], vec(methodInitø1), vec(bodyø1)))]));
                }.call(this);
            };
            var satisfyø1 = function (protocol) {
                return list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, '.-prototype')].concat([name]))], [list.apply(void 0, [symbol(void 0, 'aget')].concat([protocol], [list.apply(void 0, [symbol(void 0, 'quote')].concat([symbol(void 0, 'id')]))]))]))], [true]));
            };
            var bodyø1 = reduce(function (type, form) {
                    console.log(form, type);
                    return isList(form) ? conj(type, { 'body': conj((type || 0)['body'], makeMethodø1((type || 0)['protocol'], form)) }) : conj(type, {
                        'protocol': form,
                        'body': conj((type || 0)['body'], satisfyø1(form))
                    });
                }, {
                    'protocol': void 0,
                    'body': []
                }, forms);
            var methodsø1 = (bodyø1 || 0)['body'];
            return list.apply(void 0, [symbol(void 0, 'def')].concat([name], [list.apply(void 0, [symbol(void 0, 'do')].concat([list.apply(void 0, [symbol(void 0, 'defn-')].concat([name], [fields], vec(constructorø1)))], vec(methodsø1), [name]))]));
        }.call(this);
    };
installMacro('deftype', expandDeftype);
installMacro('defrecord', expandDeftype);
},{"./../../ast":9,"./../../expander":14,"./../../reader":32,"./../../runtime":33,"./../../sequence":34,"./../../string":35,"escodegen":16}],12:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.compiler',
            doc: void 0
        };
    var wisp_analyzer = require('./analyzer');
    var analyze = wisp_analyzer.analyze;
    var wisp_reader = require('./reader');
    var read_ = wisp_reader.read_;
    var read = wisp_reader.read;
    var pushBackReader = wisp_reader.pushBackReader;
    var wisp_string = require('./string');
    var replace = wisp_string.replace;
    var wisp_sequence = require('./sequence');
    var map = wisp_sequence.map;
    var conj = wisp_sequence.conj;
    var cons = wisp_sequence.cons;
    var vec = wisp_sequence.vec;
    var first = wisp_sequence.first;
    var rest = wisp_sequence.rest;
    var isEmpty = wisp_sequence.isEmpty;
    var count = wisp_sequence.count;
    var wisp_runtime = require('./runtime');
    var isError = wisp_runtime.isError;
    var isEqual = wisp_runtime.isEqual;
    var wisp_ast = require('./ast');
    var name = wisp_ast.name;
    var wisp_backend_escodegen_generator = require('./backend/escodegen/generator');
    var generateJs = wisp_backend_escodegen_generator.generate;
    var base64Encode = require('base64-encode');
    var btoa = base64Encode;
}
var generate = exports.generate = generateJs;
var readForm = exports.readForm = function readForm(reader, eof) {
        return (function () {
            try {
                return read(reader, false, eof, false);
            } catch (error) {
                return error;
            }
        })();
    };
var readForms = exports.readForms = function readForms(source, uri) {
        return function () {
            var readerø1 = pushBackReader(source, uri);
            var eofø1 = {};
            return function loop() {
                var recur = loop;
                var formsø1 = [];
                var formø1 = readForm(readerø1, eofø1);
                do {
                    recur = isError(formø1) ? {
                        'forms': formsø1,
                        'error': formø1
                    } : formø1 === eofø1 ? { 'forms': formsø1 } : 'else' ? (loop[0] = conj(formsø1, formø1), loop[1] = readForm(readerø1, eofø1), loop) : void 0;
                } while (formsø1 = loop[0], formø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var analyzeForm = exports.analyzeForm = function analyzeForm(env, form) {
        return (function () {
            try {
                return analyze(env, form);
            } catch (error) {
                return error;
            }
        })();
    };
var analyzeForms = exports.analyzeForms = function analyzeForms(forms) {
        return function loop() {
            var recur = loop;
            var nodesø1 = [];
            var formsø2 = forms;
            var envø1 = {
                    'locals': {},
                    'bindings': [],
                    'top': true
                };
            do {
                recur = function () {
                    var nodeø1 = analyzeForm(envø1, first(formsø2));
                    var nsø1 = isEqual((nodeø1 || 0)['op'], 'ns') ? nodeø1 : void 0;
                    return isError(nodeø1) ? {
                        'ast': nodesø1,
                        'error': nodeø1
                    } : count(formsø2) <= 1 ? { 'ast': conj(nodesø1, nodeø1) } : 'else' ? (loop[0] = conj(nodesø1, nodeø1), loop[1] = rest(formsø2), loop[2] = conj(envø1, { 'ns': nsø1 }), loop) : void 0;
                }.call(this);
            } while (nodesø1 = loop[0], formsø2 = loop[1], envø1 = loop[2], recur === loop);
            return recur;
        }.call(this);
    };
var compile = exports.compile = function compile() {
        switch (arguments.length) {
        case 1:
            var source = arguments[0];
            return compile(source, {});
        case 2:
            var source = arguments[0];
            var options = arguments[1];
            return function () {
                var sourceUriø1 = (options || 0)['source-uri'] || name('anonymous.wisp');
                var formsø1 = readForms(source, sourceUriø1);
                var astø1 = (formsø1 || 0)['error'] ? formsø1 : analyzeForms((formsø1 || 0)['forms']);
                var outputø1 = (astø1 || 0)['error'] ? astø1 : (function () {
                        try {
                            return generate.apply(void 0, vec(cons(conj(options, {
                                'source': source,
                                'source-uri': sourceUriø1
                            }), (astø1 || 0)['ast'])));
                        } catch (error) {
                            return { 'error': error };
                        }
                    })();
                var resultø1 = {
                        'source-uri': sourceUriø1,
                        'ast': (astø1 || 0)['ast'],
                        'forms': (formsø1 || 0)['forms']
                    };
                return conj(options, outputø1, resultø1);
            }.call(this);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var evaluate = exports.evaluate = function evaluate(source) {
        return function () {
            var outputø1 = compile(source);
            return (outputø1 || 0)['error'] ? (function () {
                throw (outputø1 || 0)['error'];
            })() : eval((outputø1 || 0)['code']);
        }.call(this);
    };
},{"./analyzer":8,"./ast":9,"./backend/escodegen/generator":10,"./reader":32,"./runtime":33,"./sequence":34,"./string":35,"base64-encode":15}],13:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.engine.browser',
            doc: void 0
        };
    var wisp_runtime = require('./../runtime');
    var str = wisp_runtime.str;
    var wisp_sequence = require('./../sequence');
    var rest = wisp_sequence.rest;
    var wisp_reader = require('./../reader');
    var read_ = wisp_reader.read_;
    var readFromString = wisp_reader.readFromString;
    var wisp_compiler = require('./../compiler');
    var compile_ = wisp_compiler.compile_;
}
var evaluate = exports.evaluate = function evaluate(code, url) {
        return eval(compile_(read_(code, url)));
    };
var run = exports.run = function run(code, url) {
        return Function(compile_(read_(code, url)))();
    };
var load = exports.load = function load(url, callback) {
        var request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
        request.open('GET', url, true);
        request.overrideMimeType ? request.overrideMimeType('application/wisp') : void 0;
        request.onreadystatechange = function () {
            return request.readyState === 4 ? request.status === 0 || request.status === 200 ? callback(run(request.responseText, url)) : callback('Could not load') : void 0;
        };
        return request.send(null);
    };
var runScripts = exports.runScripts = function runScripts() {
        var scripts = Array.prototype.filter.call(document.getElementsByTagName('script'), function (script) {
                return script.type === 'application/wisp';
            });
        var next = function next() {
            return scripts.length ? function () {
                var scriptø1 = scripts.shift();
                return scriptø1.src ? load(scriptø1.src, next) : next(run(scriptø1.innerHTML));
            }.call(this) : void 0;
        };
        return next();
    };
document.readyState === 'complete' || document.readyState === 'interactive' ? runScripts() : window.addEventListener ? window.addEventListener('DOMContentLoaded', runScripts, false) : window.attachEvent('onload', runScripts);
},{"./../compiler":12,"./../reader":32,"./../runtime":33,"./../sequence":34}],14:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.expander',
            doc: 'wisp syntax and macro expander module'
        };
    var wisp_ast = require('./ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var isKeyword = wisp_ast.isKeyword;
    var isQuote = wisp_ast.isQuote;
    var symbol = wisp_ast.symbol;
    var namespace = wisp_ast.namespace;
    var name = wisp_ast.name;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var conj = wisp_sequence.conj;
    var partition = wisp_sequence.partition;
    var seq = wisp_sequence.seq;
    var isEmpty = wisp_sequence.isEmpty;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var isEvery = wisp_sequence.isEvery;
    var concat = wisp_sequence.concat;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var last = wisp_sequence.last;
    var butlast = wisp_sequence.butlast;
    var interleave = wisp_sequence.interleave;
    var cons = wisp_sequence.cons;
    var count = wisp_sequence.count;
    var some = wisp_sequence.some;
    var assoc = wisp_sequence.assoc;
    var reduce = wisp_sequence.reduce;
    var filter = wisp_sequence.filter;
    var isSeq = wisp_sequence.isSeq;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isDictionary = wisp_runtime.isDictionary;
    var isVector = wisp_runtime.isVector;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isBoolean = wisp_runtime.isBoolean;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isEven = wisp_runtime.isEven;
    var isEqual = wisp_runtime.isEqual;
    var max = wisp_runtime.max;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var dictionary = wisp_runtime.dictionary;
    var subs = wisp_runtime.subs;
    var wisp_string = require('./string');
    var split = wisp_string.split;
}
var __macros__ = exports.__macros__ = {};
var expand = function expand(expander, form, env) {
    return function () {
        var metadataø1 = meta(form) || {};
        var parmasø1 = rest(form);
        var implicitø1 = map(function ($1) {
                return isEqual('&form', $1) ? form : isEqual('&env', $1) ? env : 'else' ? $1 : void 0;
            }, (meta(expander) || 0)['implicit'] || []);
        var paramsø1 = vec(concat(implicitø1, vec(rest(form))));
        var expansionø1 = expander.apply(void 0, paramsø1);
        return expansionø1 ? withMeta(expansionø1, conj(metadataø1, meta(expansionø1))) : expansionø1;
    }.call(this);
};
var installMacro = exports.installMacro = function installMacro(op, expander) {
        return (__macros__ || 0)[name(op)] = expander;
    };
var macro = function macro(op) {
    return isSymbol(op) && (__macros__ || 0)[name(op)];
};
var isMethodSyntax = exports.isMethodSyntax = function isMethodSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === first(idø1) && !('-' === second(idø1)) && !('.' === idø1);
        }.call(this);
    };
var isFieldSyntax = exports.isFieldSyntax = function isFieldSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === first(idø1) && '-' === second(idø1);
        }.call(this);
    };
var isNewSyntax = exports.isNewSyntax = function isNewSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === last(idø1) && !('.' === idø1);
        }.call(this);
    };
var methodSyntax = exports.methodSyntax = function methodSyntax(op, target) {
        var params = Array.prototype.slice.call(arguments, 2);
        return function () {
            var opMetaø1 = meta(op);
            var formStartø1 = (opMetaø1 || 0)['start'];
            var targetMetaø1 = meta(target);
            var memberø1 = withMeta(symbol(subs(name(op), 1)), conj(opMetaø1, {
                    'start': {
                        'line': (formStartø1 || 0)['line'],
                        'column': inc((formStartø1 || 0)['column'])
                    }
                }));
            var agetø1 = withMeta(symbol(void 0, 'aget'), conj(opMetaø1, {
                    'end': {
                        'line': (formStartø1 || 0)['line'],
                        'column': inc((formStartø1 || 0)['column'])
                    }
                }));
            var methodø1 = withMeta(list.apply(void 0, [agetø1].concat([target], [list.apply(void 0, [symbol(void 0, 'quote')].concat([memberø1]))])), conj(opMetaø1, { 'end': (meta(target) || 0)['end'] }));
            return isNil(target) ? (function () {
                throw Error('Malformed method expression, expecting (.method object ...)');
            })() : list.apply(void 0, [methodø1].concat(vec(params)));
        }.call(this);
    };
var fieldSyntax = exports.fieldSyntax = function fieldSyntax(field, target) {
        var more = Array.prototype.slice.call(arguments, 2);
        return function () {
            var metadataø1 = meta(field);
            var startø1 = (metadataø1 || 0)['start'];
            var endø1 = (metadataø1 || 0)['end'];
            var memberø1 = withMeta(symbol(subs(name(field), 2)), conj(metadataø1, {
                    'start': {
                        'line': (startø1 || 0)['line'],
                        'column': (startø1 || 0)['column'] + 2
                    }
                }));
            return isNil(target) || count(more) ? (function () {
                throw Error('Malformed member expression, expecting (.-member target)');
            })() : list.apply(void 0, [symbol(void 0, 'aget')].concat([target], [list.apply(void 0, [symbol(void 0, 'quote')].concat([memberø1]))]));
        }.call(this);
    };
var newSyntax = exports.newSyntax = function newSyntax(op) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var idø1 = name(op);
            var idMetaø1 = (idø1 || 0)['meta'];
            var renameø1 = subs(idø1, 0, dec(count(idø1)));
            var constructorø1 = withMeta(symbol(renameø1), conj(idMetaø1, {
                    'end': {
                        'line': ((idMetaø1 || 0)['end'] || 0)['line'],
                        'column': dec(((idMetaø1 || 0)['end'] || 0)['column'])
                    }
                }));
            var operatorø1 = withMeta(symbol(void 0, 'new'), conj(idMetaø1, {
                    'start': {
                        'line': ((idMetaø1 || 0)['end'] || 0)['line'],
                        'column': dec(((idMetaø1 || 0)['end'] || 0)['column'])
                    }
                }));
            return list.apply(void 0, [symbol(void 0, 'new')].concat([constructorø1], vec(params)));
        }.call(this);
    };
var keywordInvoke = exports.keywordInvoke = function keywordInvoke(keyword, target) {
        return list.apply(void 0, [symbol(void 0, 'get')].concat([target], [keyword]));
    };
var desugar = function desugar(expander, form) {
    return function () {
        var desugaredø1 = expander.apply(void 0, vec(form));
        var metadataø1 = conj({}, meta(form), meta(desugaredø1));
        return withMeta(desugaredø1, metadataø1);
    }.call(this);
};
var macroexpand1 = exports.macroexpand1 = function macroexpand1(form, env) {
        return function () {
            var opø1 = isList(form) && first(form);
            var expanderø1 = macro(opø1);
            return expanderø1 ? expand(expanderø1, form, env) : isKeyword(opø1) ? desugar(keywordInvoke, form) : isFieldSyntax(opø1) ? desugar(fieldSyntax, form) : isMethodSyntax(opø1) ? desugar(methodSyntax, form) : isNewSyntax(opø1) ? desugar(newSyntax, form) : 'else' ? form : void 0;
        }.call(this);
    };
var macroexpand = exports.macroexpand = function macroexpand(form, env) {
        return function loop() {
            var recur = loop;
            var originalø1 = form;
            var expandedø1 = macroexpand1(form, env);
            do {
                recur = originalø1 === expandedø1 ? originalø1 : (loop[0] = expandedø1, loop[1] = macroexpand1(expandedø1, env), loop);
            } while (originalø1 = loop[0], expandedø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var syntaxQuote = exports.syntaxQuote = function syntaxQuote(form) {
        return isSymbol(form) ? list(symbol(void 0, 'quote'), form) : isKeyword(form) ? list(symbol(void 0, 'quote'), form) : isNumber(form) || isString(form) || isBoolean(form) || isNil(form) || isRePattern(form) ? form : isUnquote(form) ? second(form) : isUnquoteSplicing(form) ? readerError('Illegal use of `~@` expression, can only be present in a list') : isEmpty(form) ? form : isDictionary(form) ? list(symbol(void 0, 'apply'), symbol(void 0, 'dictionary'), cons(symbol(void 0, '.concat'), sequenceExpand(concat.apply(void 0, seq(form))))) : isVector(form) ? cons(symbol(void 0, '.concat'), sequenceExpand(form)) : isList(form) ? isEmpty(form) ? cons(symbol(void 0, 'list'), void 0) : list(symbol(void 0, 'apply'), symbol(void 0, 'list'), cons(symbol(void 0, '.concat'), sequenceExpand(form))) : 'else' ? readerError('Unknown Collection type') : void 0;
    };
var syntaxQuoteExpand = exports.syntaxQuoteExpand = syntaxQuote;
var unquoteSplicingExpand = exports.unquoteSplicingExpand = function unquoteSplicingExpand(form) {
        return isVector(form) ? form : list(symbol(void 0, 'vec'), form);
    };
var sequenceExpand = exports.sequenceExpand = function sequenceExpand(forms) {
        return map(function (form) {
            return isUnquote(form) ? [second(form)] : isUnquoteSplicing(form) ? unquoteSplicingExpand(second(form)) : 'else' ? [syntaxQuoteExpand(form)] : void 0;
        }, forms);
    };
installMacro('syntax-quote', syntaxQuote);
var notEqual = exports.notEqual = function notEqual() {
        var body = Array.prototype.slice.call(arguments, 0);
        return list.apply(void 0, [symbol(void 0, 'not')].concat([list.apply(void 0, [symbol(void 0, '=')].concat(vec(body)))]));
    };
installMacro('not=', notEqual);
var expandCond = exports.expandCond = function expandCond() {
        var clauses = Array.prototype.slice.call(arguments, 0);
        return !isEmpty(clauses) ? list(symbol(void 0, 'if'), first(clauses), isEmpty(rest(clauses)) ? (function () {
            throw Error('cond requires an even number of forms');
        })() : second(clauses), cons(symbol(void 0, 'cond'), rest(rest(clauses)))) : void 0;
    };
installMacro('cond', expandCond);
var expandDefn = exports.expandDefn = function expandDefn(andForm, name) {
        var docPlusMetaPlusBody = Array.prototype.slice.call(arguments, 2);
        return function () {
            var docø1 = isString(first(docPlusMetaPlusBody)) ? first(docPlusMetaPlusBody) : void 0;
            var metaPlusBodyø1 = docø1 ? rest(docPlusMetaPlusBody) : docPlusMetaPlusBody;
            var metadataø1 = isDictionary(first(metaPlusBodyø1)) ? conj({ 'doc': docø1 }, first(metaPlusBodyø1)) : void 0;
            var bodyø1 = metadataø1 ? rest(metaPlusBodyø1) : metaPlusBodyø1;
            var idø1 = withMeta(name, conj(meta(name) || {}, metadataø1));
            var fnø1 = withMeta(list.apply(void 0, [symbol(void 0, 'fn')].concat([idø1], vec(bodyø1))), meta(andForm));
            return list.apply(void 0, [symbol(void 0, 'def')].concat([idø1], [fnø1]));
        }.call(this);
    };
installMacro('defn', withMeta(expandDefn, { 'implicit': ['&form'] }));
var expandPrivateDefn = exports.expandPrivateDefn = function expandPrivateDefn(name) {
        var body = Array.prototype.slice.call(arguments, 1);
        return function () {
            var metadataø1 = conj(meta(name) || {}, { 'private': true });
            var idø1 = withMeta(name, metadataø1);
            return list.apply(void 0, [symbol(void 0, 'defn')].concat([idø1], vec(body)));
        }.call(this);
    };
installMacro('defn-', expandPrivateDefn);
},{"./ast":9,"./runtime":33,"./sequence":34,"./string":35}],15:[function(require,module,exports){
var Buffer=require("__browserify_Buffer");module.exports = encode;
function encode(input) {
  return new Buffer(input).toString('base64')
}
},{"__browserify_Buffer":3}],16:[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, generateStatement:true, generateExpression:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'

    };

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false
            },
            moz: {
                starlessGenerator: false,
                parenthesizedComprehensionBlock: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            verbatim: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    // Fallback for the non SourceMap environment
    function SourceNodeMock(line, column, filename, chunk) {
        var result = [];

        function flatten(input) {
            var i, iz;
            if (isArray(input)) {
                for (i = 0, iz = input.length; i < iz; ++i) {
                    flatten(input[i]);
                }
            } else if (input instanceof SourceNodeMock) {
                result.push(input);
            } else if (typeof input === 'string' && input) {
                result.push(input);
            }
        }

        flatten(chunk);
        this.children = result;
    }

    SourceNodeMock.prototype.toString = function toString() {
        var res = '', i, iz, node;
        for (i = 0, iz = this.children.length; i < iz; ++i) {
            node = this.children[i];
            if (node instanceof SourceNodeMock) {
                res += node.toString();
            } else {
                res += node;
            }
        }
        return res;
    };

    SourceNodeMock.prototype.replaceRight = function replaceRight(pattern, replacement) {
        var last = this.children[this.children.length - 1];
        if (last instanceof SourceNodeMock) {
            last.replaceRight(pattern, replacement);
        } else if (typeof last === 'string') {
            this.children[this.children.length - 1] = last.replace(pattern, replacement);
        } else {
            this.children.push(''.replace(pattern, replacement));
        }
        return this;
    };

    SourceNodeMock.prototype.join = function join(sep) {
        var i, iz, result;
        result = [];
        iz = this.children.length;
        if (iz > 0) {
            --iz;
            for (i = 0; i < iz; ++i) {
                result.push(this.children[i], sep);
            }
            result.push(this.children[iz]);
            this.children = result;
        }
        return this;
    };

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex, result = '\\';

        switch (code) {
        case 0x08  /* \b */:
            result += 'b';
            break;
        case 0x0C  /* \f */:
            result += 'f';
            break;
        case 0x09  /* \t */:
            result += 't';
            break;
        default:
            hex = code.toString(16).toUpperCase();
            if (json || code > 0xFF) {
                result += 'u' + '0000'.slice(hex.length) + hex;
            } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
                result += '0';
            } else if (code === 0x000B  /* \v */) { // '\v'
                result += 'x0B';
            } else {
                result += 'x' + '00'.slice(hex.length) + hex;
            }
            break;
        }

        return result;
    }

    function escapeDisallowedCharacter(code) {
        var result = '\\';
        switch (code) {
        case 0x5C  /* \ */:
            result += '\\';
            break;
        case 0x0A  /* \n */:
            result += 'n';
            break;
        case 0x0D  /* \r */:
            result += 'r';
            break;
        case 0x2028:
            result += 'u2028';
            break;
        case 0x2029:
            result += 'u2029';
            break;
        default:
            throw new Error('Incorrectly classified character');
        }

        return result;
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if ((json && code < 0x20  /* SP */) || !(json || escapeless || (code >= 0x20  /* SP */ && code <= 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    function toSourceNode(generated, node) {
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource = toSourceNode(left).toString(),
            rightSource = toSourceNode(right).toString(),
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1),
            rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
        esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) ||
        leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            array[i] = toSourceNode(addIndent(array[i].slice(spaces))).join('');
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                return '//' + comment.value + '\n';
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addCommentsToStatement(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                result.push('\n');
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push('\n');
            }

            for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                comment = stmt.leadingComments[i];
                fragment = [generateComment(comment)];
                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                    fragment.push('\n');
                }
                result.push(addIndent(fragment));
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {
            tailingToStatement = !endsWithLineTerminator(toSourceNode(result).toString());
            specialBase = stringRepeat(' ', calculateSpaces(toSourceNode([base, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                comment = stmt.trailingComments[i];
                if (tailingToStatement) {
                    // We assume target like following script
                    //
                    // var t = 20;  /**
                    //               * This is comment of t
                    //               */
                    if (i === 0) {
                        // first case
                        result = [result, indent];
                    } else {
                        result = [result, specialBase];
                    }
                    result.push(generateComment(comment, specialBase));
                } else {
                    result = [result, addIndent(generateComment(comment))];
                }
                if (i !== len - 1 && !endsWithLineTerminator(toSourceNode(result).toString())) {
                    result = [result, '\n'];
                }
            }
        }

        return result;
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, generateStatement(stmt, { functionBody: functionBody })];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [newline, addIndent(generateStatement(stmt, { semicolonOptional: semicolonOptional, functionBody: functionBody }))];
        });

        return result;
    }

    function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNode(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    }

    function generateVerbatim(expr, option) {
        var i, result;
        result = expr[extra.verbatim].split(/\r\n|\n/);
        for (i = 1; i < result.length; i++) {
            result[i] = newline + base + result[i];
        }

        result = parenthesize(result, Precedence.Sequence, option.precedence);
        return toSourceNode(result, expr);
    }

    function generateIdentifier(node) {
        return toSourceNode(node.name, node);
    }

    function generateFunctionBody(node) {
        var result, i, len, expr, arrow;

        arrow = node.type === Syntax.ArrowFunctionExpression;

        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateIdentifier(node.params[0])];
        } else {
            result = ['('];
            for (i = 0, len = node.params.length; i < len; ++i) {
                result.push(generateIdentifier(node.params[i]));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');
        }

        if (arrow) {
            result.push(space, '=>');
        }

        if (node.expression) {
            result.push(space);
            expr = generateExpression(node.body, {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
            });
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(maybeBlock(node.body, false, true));
        }
        return result;
    }

    function generateExpression(expr, option) {
        var result,
            precedence,
            type,
            currentPrecedence,
            i,
            len,
            raw,
            fragment,
            multiline,
            leftCharCode,
            leftSource,
            rightCharCode,
            allowIn,
            allowCall,
            allowUnparenthesizedNew,
            property;

        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, option);
        }

        switch (type) {
        case Syntax.SequenceExpression:
            result = [];
            allowIn |= (Precedence.Sequence < precedence);
            for (i = 0, len = expr.expressions.length; i < len; ++i) {
                result.push(generateExpression(expr.expressions[i], {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result = parenthesize(result, Precedence.Sequence, precedence);
            break;

        case Syntax.AssignmentExpression:
            allowIn |= (Precedence.Assignment < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.left, {
                        precedence: Precedence.Call,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + expr.operator + space,
                    generateExpression(expr.right, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Assignment,
                precedence
            );
            break;

        case Syntax.ArrowFunctionExpression:
            allowIn |= (Precedence.ArrowFunction < precedence);
            result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
            break;

        case Syntax.ConditionalExpression:
            allowIn |= (Precedence.Conditional < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.test, {
                        precedence: Precedence.LogicalOR,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + '?' + space,
                    generateExpression(expr.consequent, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + ':' + space,
                    generateExpression(expr.alternate, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Conditional,
                precedence
            );
            break;

        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
            currentPrecedence = BinaryPrecedence[expr.operator];

            allowIn |= (currentPrecedence < precedence);

            fragment = generateExpression(expr.left, {
                precedence: currentPrecedence,
                allowIn: allowIn,
                allowCall: true
            });

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = generateExpression(expr.right, {
                precedence: currentPrecedence + 1,
                allowIn: allowIn,
                allowCall: true
            });

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace(), fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !allowIn) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, currentPrecedence, precedence);
            }

            break;

        case Syntax.CallExpression:
            result = [generateExpression(expr.callee, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: false
            })];

            result.push('(');
            for (i = 0, len = expr['arguments'].length; i < len; ++i) {
                result.push(generateExpression(expr['arguments'][i], {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!allowCall) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, Precedence.Call, precedence);
            }
            break;

        case Syntax.NewExpression:
            len = expr['arguments'].length;
            allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;

            result = join(
                'new',
                generateExpression(expr.callee, {
                    precedence: Precedence.New,
                    allowIn: true,
                    allowCall: false,
                    allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                })
            );

            if (!allowUnparenthesizedNew || parentheses || len > 0) {
                result.push('(');
                for (i = 0; i < len; ++i) {
                    result.push(generateExpression(expr['arguments'][i], {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            result = parenthesize(result, Precedence.New, precedence);
            break;

        case Syntax.MemberExpression:
            result = [generateExpression(expr.object, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: allowCall,
                allowUnparenthesizedNew: false
            })];

            if (expr.computed) {
                result.push('[', generateExpression(expr.property, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: allowCall
                }), ']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNode(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.', generateIdentifier(expr.property));
            }

            result = parenthesize(result, Precedence.Member, precedence);
            break;

        case Syntax.UnaryExpression:
            fragment = generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
            });

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNode(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode))) {
                        result.push(noEmptySpace(), fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            result = parenthesize(result, Precedence.Unary, precedence);
            break;

        case Syntax.YieldExpression:
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    generateExpression(expr.argument, {
                        precedence: Precedence.Yield,
                        allowIn: true,
                        allowCall: true
                    })
                );
            }
            result = parenthesize(result, Precedence.Yield, precedence);
            break;

        case Syntax.UpdateExpression:
            if (expr.prefix) {
                result = parenthesize(
                    [
                        expr.operator,
                        generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        })
                    ],
                    Precedence.Unary,
                    precedence
                );
            } else {
                result = parenthesize(
                    [
                        generateExpression(expr.argument, {
                            precedence: Precedence.Postfix,
                            allowIn: true,
                            allowCall: true
                        }),
                        expr.operator
                    ],
                    Precedence.Postfix,
                    precedence
                );
            }
            break;

        case Syntax.FunctionExpression:
            result = 'function';

            if (expr.id) {
                result = [result, noEmptySpace(),
                          generateIdentifier(expr.id),
                          generateFunctionBody(expr)];
            } else {
                result = [result + space, generateFunctionBody(expr)];
            }

            break;

        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
            if (!expr.elements.length) {
                result = '[]';
                break;
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                for (i = 0, len = expr.elements.length; i < len; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === len) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '', generateExpression(expr.elements[i], {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        }));
                    }
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '', ']');
            break;

        case Syntax.Property:
            if (expr.kind === 'get' || expr.kind === 'set') {
                result = [
                    expr.kind, noEmptySpace(),
                    generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    generateFunctionBody(expr.value)
                ];
            } else {
                if (expr.shorthand) {
                    result = generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                } else if (expr.method) {
                    result = [];
                    if (expr.value.generator) {
                        result.push('*');
                    }
                    result.push(generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), generateFunctionBody(expr.value));
                } else {
                    result = [
                        generateExpression(expr.key, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }),
                        ':' + space,
                        generateExpression(expr.value, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        })
                    ];
                }
            }
            break;

        case Syntax.ObjectExpression:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = generateExpression(expr.properties[0], {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true,
                    type: Syntax.Property
                });
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNode(fragment).toString())) {
                    result = [ '{', space, fragment, space, '}' ];
                    break;
                }
            }

            withIndent(function (indent) {
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, len = expr.properties.length; i < len; ++i) {
                        result.push(indent, generateExpression(expr.properties[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true,
                            type: Syntax.Property
                        }));
                        if (i + 1 < len) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(base, '}');
            break;

        case Syntax.ObjectPattern:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    result.push(multiline ? indent : '', generateExpression(expr.properties[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '', '}');
            break;

        case Syntax.ThisExpression:
            result = 'this';
            break;

        case Syntax.Identifier:
            result = generateIdentifier(expr);
            break;

        case Syntax.Literal:
            if (expr.hasOwnProperty('raw') && parse) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            result = expr.raw;
                            break;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                result = 'null';
                break;
            }

            if (typeof expr.value === 'string') {
                result = escapeString(expr.value);
                break;
            }

            if (typeof expr.value === 'number') {
                result = generateNumber(expr.value);
                break;
            }

            if (typeof expr.value === 'boolean') {
                result = expr.value ? 'true' : 'false';
                break;
            }

            result = generateRegExp(expr.value);
            break;

        case Syntax.ComprehensionExpression:
            result = [
                '[',
                generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                })
            ];

            if (expr.blocks) {
                for (i = 0, len = expr.blocks.length; i < len; ++i) {
                    fragment = generateExpression(expr.blocks[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                    result = join(result, fragment);
                }
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = generateExpression(expr.filter, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                });
                if (extra.moz.parenthesizedComprehensionBlock) {
                    result = join(result, [ '(', fragment, ')' ]);
                } else {
                    result = join(result, fragment);
                }
            }
            result.push(']');
            break;

        case Syntax.ComprehensionBlock:
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    generateStatement(expr.left.declarations[0], {
                        allowIn: false
                    })
                ];
            } else {
                fragment = generateExpression(expr.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                });
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, generateExpression(expr.right, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            }));

            if (extra.moz.parenthesizedComprehensionBlock) {
                result = [ 'for' + space + '(', fragment, ')' ];
            } else {
                result = join('for' + space, fragment);
            }
            break;

        default:
            throw new Error('Unknown expression type: ' + expr.type);
        }

        return toSourceNode(result, expr);
    }

    function generateStatement(stmt, option) {
        var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon;

        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
            allowIn = option.allowIn === undefined || option.allowIn;
            if (!semicolons && option.semicolonOptional === true) {
                semicolon = '';
            }
            functionBody = option.functionBody;
            directiveContext = option.directiveContext;
        }

        switch (stmt.type) {
        case Syntax.BlockStatement:
            result = ['{', newline];

            withIndent(function () {
                for (i = 0, len = stmt.body.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.body[i], {
                        semicolonOptional: i === len - 1,
                        directiveContext: functionBody
                    }));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });

            result.push(addIndent('}'));
            break;

        case Syntax.BreakStatement:
            if (stmt.label) {
                result = 'break ' + stmt.label.name + semicolon;
            } else {
                result = 'break' + semicolon;
            }
            break;

        case Syntax.ContinueStatement:
            if (stmt.label) {
                result = 'continue ' + stmt.label.name + semicolon;
            } else {
                result = 'continue' + semicolon;
            }
            break;

        case Syntax.DirectiveStatement:
            if (stmt.raw) {
                result = stmt.raw + semicolon;
            } else {
                result = escapeDirective(stmt.directive) + semicolon;
            }
            break;

        case Syntax.DoWhileStatement:
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            result = join('do', maybeBlock(stmt.body));
            result = maybeBlockSuffix(stmt.body, result);
            result = join(result, [
                'while' + space + '(',
                generateExpression(stmt.test, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                }),
                ')' + semicolon
            ]);
            break;

        case Syntax.CatchClause:
            withIndent(function () {
                result = [
                    'catch' + space + '(',
                    generateExpression(stmt.param, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body));
            break;

        case Syntax.DebuggerStatement:
            result = 'debugger' + semicolon;
            break;

        case Syntax.EmptyStatement:
            result = ';';
            break;

        case Syntax.ExpressionStatement:
            result = [generateExpression(stmt.expression, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            })];
            // 12.4 '{', 'function' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNode(result).toString();
            if (fragment.charAt(0) === '{' || (fragment.slice(0, 8) === 'function' && ' ('.indexOf(fragment.charAt(8)) >= 0) || (directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + semicolon];
            } else {
                result.push(semicolon);
            }
            break;

        case Syntax.VariableDeclarator:
            if (stmt.init) {
                result = [
                    generateExpression(stmt.id, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space,
                    '=',
                    space,
                    generateExpression(stmt.init, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ];
            } else {
                result = generateIdentifier(stmt.id);
            }
            break;

        case Syntax.VariableDeclaration:
            result = [stmt.kind];
            // special path for
            // var x = function () {
            // };
            if (stmt.declarations.length === 1 && stmt.declarations[0].init &&
                    stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                result.push(noEmptySpace(), generateStatement(stmt.declarations[0], {
                    allowIn: allowIn
                }));
            } else {
                // VariableDeclarator is typed as Statement,
                // but joined with comma (not LineTerminator).
                // So if comment is attached to target node, we should specialize.
                withIndent(function () {
                    node = stmt.declarations[0];
                    if (extra.comment && node.leadingComments) {
                        result.push('\n', addIndent(generateStatement(node, {
                            allowIn: allowIn
                        })));
                    } else {
                        result.push(noEmptySpace(), generateStatement(node, {
                            allowIn: allowIn
                        }));
                    }

                    for (i = 1, len = stmt.declarations.length; i < len; ++i) {
                        node = stmt.declarations[i];
                        if (extra.comment && node.leadingComments) {
                            result.push(',' + newline, addIndent(generateStatement(node, {
                                allowIn: allowIn
                            })));
                        } else {
                            result.push(',' + space, generateStatement(node, {
                                allowIn: allowIn
                            }));
                        }
                    }
                });
            }
            result.push(semicolon);
            break;

        case Syntax.ThrowStatement:
            result = [join(
                'throw',
                generateExpression(stmt.argument, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), semicolon];
            break;

        case Syntax.TryStatement:
            result = ['try', maybeBlock(stmt.block)];
            result = maybeBlockSuffix(stmt.block, result);
            if (stmt.handlers) {
                // old interface
                for (i = 0, len = stmt.handlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.handlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                // new interface
                if (stmt.handler) {
                    result = join(result, generateStatement(stmt.handler));
                    if (stmt.finalizer || stmt.guardedHandlers.length > 0) {
                        result = maybeBlockSuffix(stmt.handler.body, result);
                    }
                }

                for (i = 0, len = stmt.guardedHandlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.guardedHandlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', maybeBlock(stmt.finalizer)]);
            }
            break;

        case Syntax.SwitchStatement:
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    generateExpression(stmt.discriminant, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                for (i = 0, len = stmt.cases.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.cases[i], {semicolonOptional: i === len - 1}));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            break;

        case Syntax.SwitchCase:
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', generateExpression(stmt.test, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        })),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                len = stmt.consequent.length;
                if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = maybeBlock(stmt.consequent[0]);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== len && !endsWithLineTerminator(toSourceNode(result).toString())) {
                    result.push(newline);
                }

                for (; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.consequent[i], {semicolonOptional: i === len - 1 && semicolon === ''}));
                    result.push(fragment);
                    if (i + 1 !== len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            break;

        case Syntax.IfStatement:
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            if (stmt.alternate) {
                result.push(maybeBlock(stmt.consequent));
                result = maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', generateStatement(stmt.alternate, {semicolonOptional: semicolon === ''})]);
                } else {
                    result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                }
            } else {
                result.push(maybeBlock(stmt.consequent, semicolon === ''));
            }
            break;

        case Syntax.ForStatement:
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(generateStatement(stmt.init, {allowIn: false}));
                    } else {
                        result.push(generateExpression(stmt.init, {
                            precedence: Precedence.Sequence,
                            allowIn: false,
                            allowCall: true
                        }), ';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space, generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), ';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space, generateExpression(stmt.update, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), ')');
                } else {
                    result.push(')');
                }
            });

            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.ForInStatement:
            result = ['for' + space + '('];
            withIndent(function () {
                if (stmt.left.type === Syntax.VariableDeclaration) {
                    withIndent(function () {
                        result.push(stmt.left.kind + noEmptySpace(), generateStatement(stmt.left.declarations[0], {
                            allowIn: false
                        }));
                    });
                } else {
                    result.push(generateExpression(stmt.left, {
                        precedence: Precedence.Call,
                        allowIn: true,
                        allowCall: true
                    }));
                }

                result = join(result, 'in');
                result = [join(
                    result,
                    generateExpression(stmt.right, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), ')'];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.LabeledStatement:
            result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];
            break;

        case Syntax.Program:
            len = stmt.body.length;
            result = [safeConcatenation && len > 0 ? '\n' : ''];
            for (i = 0; i < len; ++i) {
                fragment = addIndent(
                    generateStatement(stmt.body[i], {
                        semicolonOptional: !safeConcatenation && i === len - 1,
                        directiveContext: true
                    })
                );
                result.push(fragment);
                if (i + 1 < len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                    result.push(newline);
                }
            }
            break;

        case Syntax.FunctionDeclaration:
            result = [(stmt.generator && !extra.moz.starlessGenerator ? 'function* ' : 'function '),
                      generateIdentifier(stmt.id),
                      generateFunctionBody(stmt)];
            break;

        case Syntax.ReturnStatement:
            if (stmt.argument) {
                result = [join(
                    'return',
                    generateExpression(stmt.argument, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), semicolon];
            } else {
                result = ['return' + semicolon];
            }
            break;

        case Syntax.WhileStatement:
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.WithStatement:
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    generateExpression(stmt.object, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        default:
            throw new Error('Unknown statement type: ' + stmt.type);
        }

        // Attach comments

        if (extra.comment) {
            result = addCommentsToStatement(stmt, result);
        }

        fragment = toSourceNode(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = toSourceNode(result).replaceRight(/\s+$/, '');
        }

        return toSourceNode(result, stmt);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        } else {
            SourceNode = SourceNodeMock;
        }

        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
            result = generateStatement(node);
            break;

        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:

            result = generateExpression(node, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            });
            break;

        default:
            throw new Error('Unknown node type: ' + node.type);
        }

        if (!sourceMap) {
            return result.toString();
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./package.json":31,"estraverse":17,"esutils":20,"source-map":21}],17:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function (exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP;

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
    };

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                        continue;
                    }

                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if ((nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [key, current2], 'Property', null);
                        } else {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        }
                        worklist.push(element);
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (!isArray(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                    continue;
                }

                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                        element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                    } else {
                        element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                    }
                    worklist.push(element);
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.3.3-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],18:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex;

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) || (97 <= ch && ch <= 102) || (65 <= ch && ch <= 70);
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],19:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":18}],20:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":18,"./keyword":19}],21:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":26,"./source-map/source-map-generator":27,"./source-map/source-node":28}],22:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":29,"amdefine":30}],23:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":24,"amdefine":30}],24:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":30}],25:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":30}],26:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":22,"./base64-vlq":23,"./binary-search":25,"./util":29,"amdefine":30}],27:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. To create a new one, you must pass an object
   * with the following properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: An optional root for all URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    this._file = util.getArg(aArgs, 'file');
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, original.source);
            } else {
              mapping.source = original.source;
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          orginal: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":22,"./base64-vlq":23,"./util":29,"amdefine":30}],28:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n');

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping === null) {
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + "\n");
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
        } else {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate full lines with "lastMapping"
            do {
              code += remainingLines.shift() + "\n";
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } while (lastGeneratedLine < mapping.generatedLine);
            // When we reached the correct line, we add code until we
            // reach the correct column too.
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              code += nextLine.substr(0, mapping.generatedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            // Create the SourceNode.
            addMappingWithCode(lastMapping, code);
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
          }
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      // Associate the remaining code in the current line with "lastMapping"
      // and add the remaining lines without any mapping
      addMappingWithCode(lastMapping, remainingLines.join("\n"));

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split('').forEach(function (ch) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":27,"./util":29,"amdefine":30}],29:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
  var dataUrlRegexp = /^data:.+\,.+/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[3],
      host: match[4],
      port: match[6],
      path: match[7]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = aParsedUrl.scheme + "://";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@"
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  function join(aRoot, aPath) {
    var url;

    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
      url.path = aPath;
      return urlGenerate(url);
    }

    return aRoot.replace(/\/$/, '') + '/' + aPath;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":30}],30:[function(require,module,exports){
var process=require("__browserify_process"),__filename="/node_modules/wisp/node_modules/escodegen/node_modules/source-map/node_modules/amdefine/amdefine.js";/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

},{"__browserify_process":4,"path":5}],31:[function(require,module,exports){
module.exports={
  "name": "escodegen",
  "description": "ECMAScript code generator",
  "homepage": "http://github.com/Constellation/escodegen",
  "main": "escodegen.js",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "version": "1.0.2-dev",
  "engines": {
    "node": ">=0.4.0"
  },
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/Constellation/escodegen.git"
  },
  "dependencies": {
    "esprima": "~1.0.4",
    "estraverse": "~1.5.0",
    "esutils": "~1.0.0",
    "source-map": "~0.1.30"
  },
  "optionalDependencies": {
    "source-map": "~0.1.30"
  },
  "devDependencies": {
    "esprima-moz": "*",
    "commonjs-everywhere": "~0.8.0",
    "q": "*",
    "bower": "*",
    "semver": "*",
    "chai": "~1.7.2",
    "grunt-contrib-jshint": "~0.5.0",
    "grunt-cli": "~0.1.9",
    "grunt": "~0.4.1",
    "grunt-mocha-test": "~0.6.2"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "grunt travis",
    "unit-test": "grunt test",
    "lint": "grunt lint",
    "release": "node tools/release.js",
    "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "build": "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
  },
  "readme": "\n### Escodegen [![Build Status](https://secure.travis-ci.org/Constellation/escodegen.png)](http://travis-ci.org/Constellation/escodegen) [![Build Status](https://drone.io/github.com/Constellation/escodegen/status.png)](https://drone.io/github.com/Constellation/escodegen/latest)\n\nEscodegen ([escodegen](http://github.com/Constellation/escodegen)) is\n[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n(also popularly known as [JavaScript](http://en.wikipedia.org/wiki/JavaScript>JavaScript))\ncode generator from [Parser API](https://developer.mozilla.org/en/SpiderMonkey/Parser_API) AST.\nSee [online generator demo](http://constellation.github.com/escodegen/demo/index.html).\n\n\n### Install\n\nEscodegen can be used in a web browser:\n\n    <script src=\"escodegen.browser.js\"></script>\n\nescodegen.browser.js is found in tagged-revision. See Tags on GitHub.\n\nOr in a Node.js application via the package manager:\n\n    npm install escodegen\n\n### Usage\n\nA simple example: the program\n\n    escodegen.generate({\n        type: 'BinaryExpression',\n        operator: '+',\n        left: { type: 'Literal', value: 40 },\n        right: { type: 'Literal', value: 2 }\n    });\n\nproduces the string `'40 + 2'`\n\nSee the [API page](https://github.com/Constellation/escodegen/wiki/API) for\noptions. To run the tests, execute `npm test` in the root directory.\n\n### License\n\n#### Escodegen\n\nCopyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)\n (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#### source-map\n\nSourceNodeMocks has a limited interface of mozilla/source-map SourceNode implementations.\n\nCopyright (c) 2009-2011, Mozilla Foundation and contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the names of the Mozilla Foundation nor the names of project\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Constellation/escodegen/issues"
  },
  "_id": "escodegen@1.0.2-dev",
  "dist": {
    "shasum": "24e0bd423166af81b9eaa3ad77243ea63f1f0de0"
  },
  "_resolved": "git://github.com/Constellation/escodegen.git#efed3e21a5d2545d6050c867422ee027a0b7a9cf",
  "_from": "escodegen@git://github.com/Constellation/escodegen.git#master"
}

},{}],32:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.reader',
            doc: 'Reader module provides functions for reading text input\n  as wisp data structures'
        };
    var wisp_sequence = require('./sequence');
    var list = wisp_sequence.list;
    var isList = wisp_sequence.isList;
    var count = wisp_sequence.count;
    var isEmpty = wisp_sequence.isEmpty;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var cons = wisp_sequence.cons;
    var conj = wisp_sequence.conj;
    var rest = wisp_sequence.rest;
    var concat = wisp_sequence.concat;
    var last = wisp_sequence.last;
    var butlast = wisp_sequence.butlast;
    var sort = wisp_sequence.sort;
    var lazySeq = wisp_sequence.lazySeq;
    var reduce = wisp_sequence.reduce;
    var wisp_runtime = require('./runtime');
    var isOdd = wisp_runtime.isOdd;
    var dictionary = wisp_runtime.dictionary;
    var keys = wisp_runtime.keys;
    var isNil = wisp_runtime.isNil;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var isVector = wisp_runtime.isVector;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isBoolean = wisp_runtime.isBoolean;
    var isObject = wisp_runtime.isObject;
    var isDictionary = wisp_runtime.isDictionary;
    var rePattern = wisp_runtime.rePattern;
    var reMatches = wisp_runtime.reMatches;
    var reFind = wisp_runtime.reFind;
    var str = wisp_runtime.str;
    var subs = wisp_runtime.subs;
    var char = wisp_runtime.char;
    var vals = wisp_runtime.vals;
    var isEqual = wisp_runtime.isEqual;
    var wisp_ast = require('./ast');
    var isSymbol = wisp_ast.isSymbol;
    var symbol = wisp_ast.symbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
}
var pushBackReader = exports.pushBackReader = function pushBackReader(source, uri) {
        return {
            'lines': split(source, '\n'),
            'buffer': '',
            'uri': uri,
            'column': -1,
            'line': 0
        };
    };
var peekChar = exports.peekChar = function peekChar(reader) {
        return function () {
            var lineø1 = (reader || 0)['lines'][(reader || 0)['line']];
            var columnø1 = inc((reader || 0)['column']);
            return isNil(lineø1) ? void 0 : lineø1[columnø1] || '\n';
        }.call(this);
    };
var readChar = exports.readChar = function readChar(reader) {
        return function () {
            var chø1 = peekChar(reader);
            isNewline(peekChar(reader)) ? (function () {
                (reader || 0)['line'] = inc((reader || 0)['line']);
                return (reader || 0)['column'] = -1;
            })() : (reader || 0)['column'] = inc((reader || 0)['column']);
            return chø1;
        }.call(this);
    };
var isNewline = exports.isNewline = function isNewline(ch) {
        return '\n' === ch;
    };
var isBreakingWhitespace = exports.isBreakingWhitespace = function isBreakingWhitespace(ch) {
        return ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r';
    };
var isWhitespace = exports.isWhitespace = function isWhitespace(ch) {
        return isBreakingWhitespace(ch) || ',' === ch;
    };
var isNumeric = exports.isNumeric = function isNumeric(ch) {
        return ch === '0' || ch === '1' || ch === '2' || ch === '3' || ch === '4' || ch === '5' || ch === '6' || ch === '7' || ch === '8' || ch === '9';
    };
var isCommentPrefix = exports.isCommentPrefix = function isCommentPrefix(ch) {
        return ';' === ch;
    };
var isNumberLiteral = exports.isNumberLiteral = function isNumberLiteral(reader, initch) {
        return isNumeric(initch) || ('+' === initch || '-' === initch) && isNumeric(peekChar(reader));
    };
var readerError = exports.readerError = function readerError(reader, message) {
        return function () {
            var textø1 = '' + message + '\n' + 'line:' + (reader || 0)['line'] + '\n' + 'column:' + (reader || 0)['column'];
            var errorø1 = SyntaxError(textø1, (reader || 0)['uri']);
            errorø1.line = (reader || 0)['line'];
            errorø1.column = (reader || 0)['column'];
            errorø1.uri = (reader || 0)['uri'];
            return (function () {
                throw errorø1;
            })();
        }.call(this);
    };
var isMacroTerminating = exports.isMacroTerminating = function isMacroTerminating(ch) {
        return !(ch === '#') && !(ch === '\'') && !(ch === ':') && macros(ch);
    };
var readToken = exports.readToken = function readToken(reader, initch) {
        return function loop() {
            var recur = loop;
            var bufferø1 = initch;
            var chø1 = peekChar(reader);
            do {
                recur = isNil(chø1) || isWhitespace(chø1) || isMacroTerminating(chø1) ? bufferø1 : (loop[0] = '' + bufferø1 + readChar(reader), loop[1] = peekChar(reader), loop);
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var skipLine = exports.skipLine = function skipLine(reader, _) {
        return function loop() {
            var recur = loop;
            do {
                recur = function () {
                    var chø1 = readChar(reader);
                    return chø1 === '\n' || chø1 === '\r' || isNil(chø1) ? reader : (loop);
                }.call(this);
            } while (recur === loop);
            return recur;
        }.call(this);
    };
var intPattern = exports.intPattern = rePattern('^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$');
var ratioPattern = exports.ratioPattern = rePattern('([-+]?[0-9]+)/([0-9]+)');
var floatPattern = exports.floatPattern = rePattern('([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?');
var matchInt = exports.matchInt = function matchInt(s) {
        return function () {
            var groupsø1 = reFind(intPattern, s);
            var group3ø1 = groupsø1[2];
            return !(isNil(group3ø1) || count(group3ø1) < 1) ? 0 : function () {
                var negateø1 = '-' === groupsø1[1] ? -1 : 1;
                var aø1 = groupsø1[3] ? [
                        groupsø1[3],
                        10
                    ] : groupsø1[4] ? [
                        groupsø1[4],
                        16
                    ] : groupsø1[5] ? [
                        groupsø1[5],
                        8
                    ] : groupsø1[7] ? [
                        groupsø1[7],
                        parseInt(groupsø1[7])
                    ] : 'else' ? [
                        void 0,
                        void 0
                    ] : void 0;
                var nø1 = aø1[0];
                var radixø1 = aø1[1];
                return isNil(nø1) ? void 0 : negateø1 * parseInt(nø1, radixø1);
            }.call(this);
        }.call(this);
    };
var matchRatio = exports.matchRatio = function matchRatio(s) {
        return function () {
            var groupsø1 = reFind(ratioPattern, s);
            var numinatorø1 = groupsø1[1];
            var denominatorø1 = groupsø1[2];
            return parseInt(numinatorø1) / parseInt(denominatorø1);
        }.call(this);
    };
var matchFloat = exports.matchFloat = function matchFloat(s) {
        return parseFloat(s);
    };
var matchNumber = exports.matchNumber = function matchNumber(s) {
        return reMatches(intPattern, s) ? matchInt(s) : reMatches(ratioPattern, s) ? matchRatio(s) : reMatches(floatPattern, s) ? matchFloat(s) : void 0;
    };
var escapeCharMap = exports.escapeCharMap = function escapeCharMap(c) {
        return c === 't' ? '\t' : c === 'r' ? '\r' : c === 'n' ? '\n' : c === '\\' ? '\\' : c === '"' ? '"' : c === 'b' ? '\b' : c === 'f' ? '\f' : 'else' ? void 0 : void 0;
    };
var read2Chars = exports.read2Chars = function read2Chars(reader) {
        return '' + readChar(reader) + readChar(reader);
    };
var read4Chars = exports.read4Chars = function read4Chars(reader) {
        return '' + readChar(reader) + readChar(reader) + readChar(reader) + readChar(reader);
    };
var unicode2Pattern = exports.unicode2Pattern = rePattern('[0-9A-Fa-f]{2}');
var unicode4Pattern = exports.unicode4Pattern = rePattern('[0-9A-Fa-f]{4}');
var validateUnicodeEscape = exports.validateUnicodeEscape = function validateUnicodeEscape(unicodePattern, reader, escapeChar, unicodeStr) {
        return reMatches(unicodePattern, unicodeStr) ? unicodeStr : readerError(reader, '' + 'Unexpected unicode escape ' + '\\' + escapeChar + unicodeStr);
    };
var makeUnicodeChar = exports.makeUnicodeChar = function makeUnicodeChar(codeStr, base) {
        return function () {
            var baseø2 = base || 16;
            var codeø1 = parseInt(codeStr, baseø2);
            return char(codeø1);
        }.call(this);
    };
var escapeChar = exports.escapeChar = function escapeChar(buffer, reader) {
        return function () {
            var chø1 = readChar(reader);
            var mapresultø1 = escapeCharMap(chø1);
            return mapresultø1 ? mapresultø1 : chø1 === 'x' ? makeUnicodeChar(validateUnicodeEscape(unicode2Pattern, reader, chø1, read2Chars(reader))) : chø1 === 'u' ? makeUnicodeChar(validateUnicodeEscape(unicode4Pattern, reader, chø1, read4Chars(reader))) : isNumeric(chø1) ? char(chø1) : 'else' ? readerError(reader, '' + 'Unexpected unicode escape ' + '\\' + chø1) : void 0;
        }.call(this);
    };
var readPast = exports.readPast = function readPast(predicate, reader) {
        return function loop() {
            var recur = loop;
            var _ø1 = void 0;
            do {
                recur = predicate(peekChar(reader)) ? (loop[0] = readChar(reader), loop) : peekChar(reader);
            } while (_ø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var readDelimitedList = exports.readDelimitedList = function readDelimitedList(delim, reader, isRecursive) {
        return function loop() {
            var recur = loop;
            var formsø1 = [];
            do {
                recur = function () {
                    var _ø1 = readPast(isWhitespace, reader);
                    var chø1 = readChar(reader);
                    !chø1 ? readerError(reader, 'EOF') : void 0;
                    return delim === chø1 ? formsø1 : function () {
                        var formø1 = readForm(reader, chø1);
                        return loop[0] = formø1 === reader ? formsø1 : conj(formsø1, formø1), loop;
                    }.call(this);
                }.call(this);
            } while (formsø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var notImplemented = exports.notImplemented = function notImplemented(reader, ch) {
        return readerError(reader, '' + 'Reader for ' + ch + ' not implemented yet');
    };
var readDispatch = exports.readDispatch = function readDispatch(reader, _) {
        return function () {
            var chø1 = readChar(reader);
            var dmø1 = dispatchMacros(chø1);
            return dmø1 ? dmø1(reader, _) : function () {
                var objectø1 = maybeReadTaggedType(reader, chø1);
                return objectø1 ? objectø1 : readerError(reader, 'No dispatch macro for ', chø1);
            }.call(this);
        }.call(this);
    };
var readUnmatchedDelimiter = exports.readUnmatchedDelimiter = function readUnmatchedDelimiter(rdr, ch) {
        return readerError(rdr, 'Unmached delimiter ', ch);
    };
var readList = exports.readList = function readList(reader, _) {
        return function () {
            var formø1 = readDelimitedList(')', reader, true);
            return withMeta(list.apply(void 0, formø1), meta(formø1));
        }.call(this);
    };
var readComment = exports.readComment = function readComment(reader, _) {
        return function loop() {
            var recur = loop;
            var bufferø1 = '';
            var chø1 = readChar(reader);
            do {
                recur = isNil(chø1) || '\n' === chø1 ? reader || list(symbol(void 0, 'comment'), bufferø1) : '\\' === chø1 ? (loop[0] = '' + bufferø1 + escapeChar(bufferø1, reader), loop[1] = readChar(reader), loop) : 'else' ? (loop[0] = '' + bufferø1 + chø1, loop[1] = readChar(reader), loop) : void 0;
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readVector = exports.readVector = function readVector(reader) {
        return readDelimitedList(']', reader, true);
    };
var readMap = exports.readMap = function readMap(reader) {
        return function () {
            var formø1 = readDelimitedList('}', reader, true);
            return isOdd(count(formø1)) ? readerError(reader, 'Map literal must contain an even number of forms') : withMeta(dictionary.apply(void 0, formø1), meta(formø1));
        }.call(this);
    };
var readSet = exports.readSet = function readSet(reader, _) {
        return function () {
            var formø1 = readDelimitedList('}', reader, true);
            return withMeta(concat([symbol(void 0, 'set')], formø1), meta(formø1));
        }.call(this);
    };
var readNumber = exports.readNumber = function readNumber(reader, initch) {
        return function loop() {
            var recur = loop;
            var bufferø1 = initch;
            var chø1 = peekChar(reader);
            do {
                recur = isNil(chø1) || isWhitespace(chø1) || macros(chø1) ? (function () {
                    var match = matchNumber(bufferø1);
                    return isNil(match) ? readerError(reader, 'Invalid number format [', bufferø1, ']') : new Number(match);
                })() : (loop[0] = '' + bufferø1 + readChar(reader), loop[1] = peekChar(reader), loop);
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readString = exports.readString = function readString(reader) {
        return function loop() {
            var recur = loop;
            var bufferø1 = '';
            var chø1 = readChar(reader);
            do {
                recur = isNil(chø1) ? readerError(reader, 'EOF while reading string') : '\\' === chø1 ? (loop[0] = '' + bufferø1 + escapeChar(bufferø1, reader), loop[1] = readChar(reader), loop) : '"' === chø1 ? new String(bufferø1) : 'default' ? (loop[0] = '' + bufferø1 + chø1, loop[1] = readChar(reader), loop) : void 0;
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readCharacter = exports.readCharacter = function readCharacter(reader) {
        return new String(readChar(reader));
    };
var readUnquote = exports.readUnquote = function readUnquote(reader) {
        return function () {
            var chø1 = peekChar(reader);
            return !chø1 ? readerError(reader, 'EOF while reading character') : chø1 === '@' ? (function () {
                readChar(reader);
                return list(symbol(void 0, 'unquote-splicing'), read(reader, true, void 0, true));
            })() : list(symbol(void 0, 'unquote'), read(reader, true, void 0, true));
        }.call(this);
    };
var specialSymbols = exports.specialSymbols = function specialSymbols(text, notFound) {
        return text === 'nil' ? void 0 : text === 'true' ? true : text === 'false' ? false : 'else' ? notFound : void 0;
    };
var readSymbol = exports.readSymbol = function readSymbol(reader, initch) {
        return function () {
            var tokenø1 = readToken(reader, initch);
            var partsø1 = split(tokenø1, '/');
            var hasNsø1 = count(partsø1) > 1 && count(tokenø1) > 1;
            var nsø1 = first(partsø1);
            var nameø1 = join('/', rest(partsø1));
            return hasNsø1 ? symbol(nsø1, nameø1) : specialSymbols(tokenø1, symbol(tokenø1));
        }.call(this);
    };
var readKeyword = exports.readKeyword = function readKeyword(reader, initch) {
        return function () {
            var tokenø1 = readToken(reader, readChar(reader));
            var partsø1 = split(tokenø1, '/');
            var nameø1 = last(partsø1);
            var nsø1 = count(partsø1) > 1 ? join('/', butlast(partsø1)) : void 0;
            var issueø1 = last(nsø1) === ':' ? 'namespace can\'t ends with ":"' : last(nameø1) === ':' ? 'name can\'t end with ":"' : last(nameø1) === '/' ? 'name can\'t end with "/"' : count(split(tokenø1, '::')) > 1 ? 'name can\'t contain "::"' : void 0;
            return issueø1 ? readerError(reader, 'Invalid token (', issueø1, '): ', tokenø1) : !nsø1 && first(nameø1) === ':' ? keyword(rest(nameø1)) : keyword(nsø1, nameø1);
        }.call(this);
    };
var desugarMeta = exports.desugarMeta = function desugarMeta(form) {
        return isKeyword(form) ? dictionary(name(form), true) : isSymbol(form) ? { 'tag': form } : isString(form) ? { 'tag': form } : isDictionary(form) ? reduce(function (result, pair) {
            (result || 0)[name(first(pair))] = second(pair);
            return result;
        }, {}, form) : 'else' ? form : void 0;
    };
var wrappingReader = exports.wrappingReader = function wrappingReader(prefix) {
        return function (reader) {
            return list(prefix, read(reader, true, void 0, true));
        };
    };
var throwingReader = exports.throwingReader = function throwingReader(msg) {
        return function (reader) {
            return readerError(reader, msg);
        };
    };
var readMeta = exports.readMeta = function readMeta(reader, _) {
        return function () {
            var metadataø1 = desugarMeta(read(reader, true, void 0, true));
            !isDictionary(metadataø1) ? readerError(reader, 'Metadata must be Symbol, Keyword, String or Map') : void 0;
            return function () {
                var formø1 = read(reader, true, void 0, true);
                return isObject(formø1) ? withMeta(formø1, conj(metadataø1, meta(formø1))) : formø1;
            }.call(this);
        }.call(this);
    };
var readRegex = exports.readRegex = function readRegex(reader) {
        return function loop() {
            var recur = loop;
            var bufferø1 = '';
            var chø1 = readChar(reader);
            do {
                recur = isNil(chø1) ? readerError(reader, 'EOF while reading string') : '\\' === chø1 ? (loop[0] = '' + bufferø1 + chø1 + readChar(reader), loop[1] = readChar(reader), loop) : '"' === chø1 ? rePattern(bufferø1) : 'default' ? (loop[0] = '' + bufferø1 + chø1, loop[1] = readChar(reader), loop) : void 0;
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readParam = exports.readParam = function readParam(reader, initch) {
        return function () {
            var formø1 = readSymbol(reader, initch);
            return isEqual(formø1, symbol('%')) ? symbol('%1') : formø1;
        }.call(this);
    };
var isParam = exports.isParam = function isParam(form) {
        return isSymbol(form) && '%' === first(name(form));
    };
var lambdaParamsHash = exports.lambdaParamsHash = function lambdaParamsHash(form) {
        return isParam(form) ? dictionary(form, form) : isDictionary(form) || isVector(form) || isList(form) ? conj.apply(void 0, map(lambdaParamsHash, vec(form))) : 'else' ? {} : void 0;
    };
var lambdaParams = exports.lambdaParams = function lambdaParams(body) {
        return function () {
            var namesø1 = sort(vals(lambdaParamsHash(body)));
            var variadicø1 = isEqual(first(namesø1), symbol('%&'));
            var nø1 = variadicø1 && count(namesø1) === 1 ? 0 : parseInt(rest(name(last(namesø1))));
            var paramsø1 = function loop() {
                    var recur = loop;
                    var namesø2 = [];
                    var iø1 = 1;
                    do {
                        recur = iø1 <= nø1 ? (loop[0] = conj(namesø2, symbol('' + '%' + iø1)), loop[1] = inc(iø1), loop) : namesø2;
                    } while (namesø2 = loop[0], iø1 = loop[1], recur === loop);
                    return recur;
                }.call(this);
            return variadicø1 ? conj(paramsø1, symbol(void 0, '&'), symbol(void 0, '%&')) : namesø1;
        }.call(this);
    };
var readLambda = exports.readLambda = function readLambda(reader) {
        return function () {
            var bodyø1 = readList(reader);
            return list(symbol(void 0, 'fn'), lambdaParams(bodyø1), bodyø1);
        }.call(this);
    };
var readDiscard = exports.readDiscard = function readDiscard(reader, _) {
        read(reader, true, void 0, true);
        return reader;
    };
var macros = exports.macros = function macros(c) {
        return c === '"' ? readString : c === '\\' ? readCharacter : c === ':' ? readKeyword : c === ';' ? readComment : c === '\'' ? wrappingReader(symbol(void 0, 'quote')) : c === '@' ? wrappingReader(symbol(void 0, 'deref')) : c === '^' ? readMeta : c === '`' ? wrappingReader(symbol(void 0, 'syntax-quote')) : c === '~' ? readUnquote : c === '(' ? readList : c === ')' ? readUnmatchedDelimiter : c === '[' ? readVector : c === ']' ? readUnmatchedDelimiter : c === '{' ? readMap : c === '}' ? readUnmatchedDelimiter : c === '%' ? readParam : c === '#' ? readDispatch : 'else' ? void 0 : void 0;
    };
var dispatchMacros = exports.dispatchMacros = function dispatchMacros(s) {
        return s === '{' ? readSet : s === '(' ? readLambda : s === '<' ? throwingReader('Unreadable form') : s === '"' ? readRegex : s === '!' ? readComment : s === '_' ? readDiscard : 'else' ? void 0 : void 0;
    };
var readForm = exports.readForm = function readForm(reader, ch) {
        return function () {
            var startø1 = {
                    'line': (reader || 0)['line'],
                    'column': (reader || 0)['column']
                };
            var readMacroø1 = macros(ch);
            var formø1 = readMacroø1 ? readMacroø1(reader, ch) : isNumberLiteral(reader, ch) ? readNumber(reader, ch) : 'else' ? readSymbol(reader, ch) : void 0;
            var endø1 = {
                    'line': (reader || 0)['line'],
                    'column': inc((reader || 0)['column'])
                };
            var locationø1 = {
                    'uri': (reader || 0)['uri'],
                    'start': startø1,
                    'end': endø1
                };
            return formø1 === reader ? formø1 : !(isBoolean(formø1) || isNil(formø1) || isKeyword(formø1)) ? withMeta(formø1, conj(locationø1, meta(formø1))) : 'else' ? formø1 : void 0;
        }.call(this);
    };
var read = exports.read = function read(reader, eofIsError, sentinel, isRecursive) {
        return function loop() {
            var recur = loop;
            do {
                recur = function () {
                    var chø1 = readChar(reader);
                    var formø1 = isNil(chø1) ? eofIsError ? readerError(reader, 'EOF') : sentinel : isWhitespace(chø1) ? reader : isCommentPrefix(chø1) ? read(readComment(reader, chø1), eofIsError, sentinel, isRecursive) : 'else' ? readForm(reader, chø1) : void 0;
                    return formø1 === reader ? (loop) : formø1;
                }.call(this);
            } while (recur === loop);
            return recur;
        }.call(this);
    };
var read_ = exports.read_ = function read_(source, uri) {
        return function () {
            var readerø1 = pushBackReader(source, uri);
            var eofø1 = gensym();
            return function loop() {
                var recur = loop;
                var formsø1 = [];
                var formø1 = read(readerø1, false, eofø1, false);
                do {
                    recur = formø1 === eofø1 ? formsø1 : (loop[0] = conj(formsø1, formø1), loop[1] = read(readerø1, false, eofø1, false), loop);
                } while (formsø1 = loop[0], formø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var readFromString = exports.readFromString = function readFromString(source, uri) {
        return function () {
            var readerø1 = pushBackReader(source, uri);
            return read(readerø1, true, void 0, false);
        }.call(this);
    };
var readUuid = function readUuid(uuid) {
    return isString(uuid) ? list.apply(void 0, [symbol(void 0, 'UUID.')].concat([uuid])) : readerError(void 0, 'UUID literal expects a string as its representation.');
};
var readQueue = function readQueue(items) {
    return isVector(items) ? list.apply(void 0, [symbol(void 0, 'PersistentQueue.')].concat([items])) : readerError(void 0, 'Queue literal expects a vector for its elements.');
};
var __tagTable__ = exports.__tagTable__ = dictionary('uuid', readUuid, 'queue', readQueue);
var maybeReadTaggedType = exports.maybeReadTaggedType = function maybeReadTaggedType(reader, initch) {
        return function () {
            var tagø1 = readSymbol(reader, initch);
            var pfnø1 = (__tagTable__ || 0)[name(tagø1)];
            return pfnø1 ? pfnø1(read(reader, true, void 0, false)) : readerError(reader, '' + 'Could not find tag parser for ' + name(tagø1) + ' in ' + ('' + keys(__tagTable__)));
        }.call(this);
    };
},{"./ast":9,"./runtime":33,"./sequence":34,"./string":35}],33:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.runtime',
            doc: 'Core primitives required for runtime'
        };
}
var identity = exports.identity = function identity(x) {
        return x;
    };
var isOdd = exports.isOdd = function isOdd(n) {
        return n % 2 === 1;
    };
var isEven = exports.isEven = function isEven(n) {
        return n % 2 === 0;
    };
var isDictionary = exports.isDictionary = function isDictionary(form) {
        return isObject(form) && isObject(Object.getPrototypeOf(form)) && isNil(Object.getPrototypeOf(Object.getPrototypeOf(form)));
    };
var dictionary = exports.dictionary = function dictionary() {
        var pairs = Array.prototype.slice.call(arguments, 0);
        return function loop() {
            var recur = loop;
            var keyValuesø1 = pairs;
            var resultø1 = {};
            do {
                recur = keyValuesø1.length ? (function () {
                    resultø1[keyValuesø1[0]] = keyValuesø1[1];
                    return loop[0] = keyValuesø1.slice(2), loop[1] = resultø1, loop;
                })() : resultø1;
            } while (keyValuesø1 = loop[0], resultø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var keys = exports.keys = function keys(dictionary) {
        return Object.keys(dictionary);
    };
var vals = exports.vals = function vals(dictionary) {
        return keys(dictionary).map(function (key) {
            return (dictionary || 0)[key];
        });
    };
var keyValues = exports.keyValues = function keyValues(dictionary) {
        return keys(dictionary).map(function (key) {
            return [
                key,
                (dictionary || 0)[key]
            ];
        });
    };
var merge = exports.merge = function merge() {
        return Object.create(Object.prototype, Array.prototype.slice.call(arguments).reduce(function (descriptor, dictionary) {
            isObject(dictionary) ? Object.keys(dictionary).forEach(function (key) {
                return (descriptor || 0)[key] = Object.getOwnPropertyDescriptor(dictionary, key);
            }) : void 0;
            return descriptor;
        }, Object.create(Object.prototype)));
    };
var isContainsVector = exports.isContainsVector = function isContainsVector(vector, element) {
        return vector.indexOf(element) >= 0;
    };
var mapDictionary = exports.mapDictionary = function mapDictionary(source, f) {
        return Object.keys(source).reduce(function (target, key) {
            (target || 0)[key] = f((source || 0)[key]);
            return target;
        }, {});
    };
var toString = exports.toString = Object.prototype.toString;
var isFn = exports.isFn = typeof(/./) === 'function' ? function (x) {
        return toString.call(x) === '[object Function]';
    } : function (x) {
        return typeof(x) === 'function';
    };
var isError = exports.isError = function isError(x) {
        return x instanceof Error || toString.call(x) === '[object Error]';
    };
var isString = exports.isString = function isString(x) {
        return typeof(x) === 'string' || toString.call(x) === '[object String]';
    };
var isNumber = exports.isNumber = function isNumber(x) {
        return typeof(x) === 'number' || toString.call(x) === '[object Number]';
    };
var isVector = exports.isVector = isFn(Array.isArray) ? Array.isArray : function (x) {
        return toString.call(x) === '[object Array]';
    };
var isDate = exports.isDate = function isDate(x) {
        return toString.call(x) === '[object Date]';
    };
var isBoolean = exports.isBoolean = function isBoolean(x) {
        return x === true || x === false || toString.call(x) === '[object Boolean]';
    };
var isRePattern = exports.isRePattern = function isRePattern(x) {
        return toString.call(x) === '[object RegExp]';
    };
var isObject = exports.isObject = function isObject(x) {
        return x && typeof(x) === 'object';
    };
var isNil = exports.isNil = function isNil(x) {
        return x === void 0 || x === null;
    };
var isTrue = exports.isTrue = function isTrue(x) {
        return x === true;
    };
var isFalse = exports.isFalse = function isFalse(x) {
        return x === true;
    };
var reFind = exports.reFind = function reFind(re, s) {
        return function () {
            var matchesø1 = re.exec(s);
            return !isNil(matchesø1) ? matchesø1.length === 1 ? (matchesø1 || 0)[0] : matchesø1 : void 0;
        }.call(this);
    };
var reMatches = exports.reMatches = function reMatches(pattern, source) {
        return function () {
            var matchesø1 = pattern.exec(source);
            return !isNil(matchesø1) && (matchesø1 || 0)[0] === source ? matchesø1.length === 1 ? (matchesø1 || 0)[0] : matchesø1 : void 0;
        }.call(this);
    };
var rePattern = exports.rePattern = function rePattern(s) {
        return function () {
            var matchø1 = reFind(/^(?:\(\?([idmsux]*)\))?(.*)/, s);
            return new RegExp((matchø1 || 0)[2], (matchø1 || 0)[1]);
        }.call(this);
    };
var inc = exports.inc = function inc(x) {
        return x + 1;
    };
var dec = exports.dec = function dec(x) {
        return x - 1;
    };
var str = exports.str = function str() {
        return String.prototype.concat.apply('', arguments);
    };
var char = exports.char = function char(code) {
        return String.fromCharCode(code);
    };
var int = exports.int = function int(x) {
        return isNumber(x) ? x >= 0 ? Math.floor(x) : Math.floor(x) : x.charCodeAt(0);
    };
var subs = exports.subs = function subs(string, start, end) {
        return string.substring(start, end);
    };
var isPatternEqual = function isPatternEqual(x, y) {
    return isRePattern(x) && isRePattern(y) && x.source === y.source && x.global === y.global && x.multiline === y.multiline && x.ignoreCase === y.ignoreCase;
};
var isDateEqual = function isDateEqual(x, y) {
    return isDate(x) && isDate(y) && Number(x) === Number(y);
};
var isDictionaryEqual = function isDictionaryEqual(x, y) {
    return isObject(x) && isObject(y) && function () {
        var xKeysø1 = keys(x);
        var yKeysø1 = keys(y);
        var xCountø1 = xKeysø1.length;
        var yCountø1 = yKeysø1.length;
        return xCountø1 === yCountø1 && function loop() {
            var recur = loop;
            var indexø1 = 0;
            var countø1 = xCountø1;
            var keysø1 = xKeysø1;
            do {
                recur = indexø1 < countø1 ? isEquivalent((x || 0)[(keysø1 || 0)[indexø1]], (y || 0)[(keysø1 || 0)[indexø1]]) ? (loop[0] = inc(indexø1), loop[1] = countø1, loop[2] = keysø1, loop) : false : true;
            } while (indexø1 = loop[0], countø1 = loop[1], keysø1 = loop[2], recur === loop);
            return recur;
        }.call(this);
    }.call(this);
};
var isVectorEqual = function isVectorEqual(x, y) {
    return isVector(x) && isVector(y) && x.length === y.length && function loop() {
        var recur = loop;
        var xsø1 = x;
        var ysø1 = y;
        var indexø1 = 0;
        var countø1 = x.length;
        do {
            recur = indexø1 < countø1 ? isEquivalent((xsø1 || 0)[indexø1], (ysø1 || 0)[indexø1]) ? (loop[0] = xsø1, loop[1] = ysø1, loop[2] = inc(indexø1), loop[3] = countø1, loop) : false : true;
        } while (xsø1 = loop[0], ysø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
        return recur;
    }.call(this);
};
var isEquivalent = function isEquivalent() {
    switch (arguments.length) {
    case 1:
        var x = arguments[0];
        return true;
    case 2:
        var x = arguments[0];
        var y = arguments[1];
        return x === y || (isNil(x) ? isNil(y) : isNil(y) ? isNil(x) : isString(x) ? isString(y) && x.toString() === y.toString() : isNumber(x) ? isNumber(y) && x.valueOf() === y.valueOf() : isFn(x) ? false : isBoolean(x) ? false : isDate(x) ? isDateEqual(x, y) : isVector(x) ? isVectorEqual(x, y, [], []) : isRePattern(x) ? isPatternEqual(x, y) : 'else' ? isDictionaryEqual(x, y) : void 0);
    default:
        var x = arguments[0];
        var y = arguments[1];
        var more = Array.prototype.slice.call(arguments, 2);
        return function loop() {
            var recur = loop;
            var previousø1 = x;
            var currentø1 = y;
            var indexø1 = 0;
            var countø1 = more.length;
            do {
                recur = isEquivalent(previousø1, currentø1) && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
            } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
            return recur;
        }.call(this);
    }
};
var isEqual = exports.isEqual = isEquivalent;
var isStrictEqual = exports.isStrictEqual = function isStrictEqual() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x === y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 == currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var greaterThan = exports.greaterThan = function greaterThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x > y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 > currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var notLessThan = exports.notLessThan = function notLessThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x >= y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 >= currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var lessThan = exports.lessThan = function lessThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x < y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 < currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var notGreaterThan = exports.notGreaterThan = function notGreaterThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x <= y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 <= currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var sum = exports.sum = function sum() {
        switch (arguments.length) {
        case 0:
            return 0;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a + b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a + b + c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a + b + c + d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a + b + c + d + e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a + b + c + d + e + f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a + b + c + d + e + f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 + (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var subtract = exports.subtract = function subtract() {
        switch (arguments.length) {
        case 0:
            return (function () {
                throw TypeError('Wrong number of args passed to: -');
            })();
        case 1:
            var a = arguments[0];
            return 0 - a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a - b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a - b - c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a - b - c - d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a - b - c - d - e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a - b - c - d - e - f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a - b - c - d - e - f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 - (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var divide = exports.divide = function divide() {
        switch (arguments.length) {
        case 0:
            return (function () {
                throw TypeError('Wrong number of args passed to: /');
            })();
        case 1:
            var a = arguments[0];
            return 1 / a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a / b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a / b / c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a / b / c / d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a / b / c / d / e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a / b / c / d / e / f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a / b / c / d / e / f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 / (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var multiply = exports.multiply = function multiply() {
        switch (arguments.length) {
        case 0:
            return 1;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a * b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a * b * c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a * b * c * d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a * b * c * d * e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a * b * c * d * e * f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a * b * c * d * e * f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 * (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var and = exports.and = function and() {
        switch (arguments.length) {
        case 0:
            return true;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a && b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a && b && c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a && b && c && d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a && b && c && d && e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a && b && c && d && e && f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a && b && c && d && e && f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 && (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var or = exports.or = function or() {
        switch (arguments.length) {
        case 0:
            return void 0;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a || b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a || b || c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a || b || c || d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a || b || c || d || e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a || b || c || d || e || f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a || b || c || d || e || f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 || (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var print = exports.print = function print() {
        var more = Array.prototype.slice.call(arguments, 0);
        return console.log.apply(void 0, more);
    };
var max = exports.max = Math.max;
var min = exports.min = Math.min;
},{}],34:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.sequence',
            doc: void 0
        };
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isVector = wisp_runtime.isVector;
    var isFn = wisp_runtime.isFn;
    var isNumber = wisp_runtime.isNumber;
    var isString = wisp_runtime.isString;
    var isDictionary = wisp_runtime.isDictionary;
    var keyValues = wisp_runtime.keyValues;
    var str = wisp_runtime.str;
    var dec = wisp_runtime.dec;
    var inc = wisp_runtime.inc;
    var merge = wisp_runtime.merge;
    var dictionary = wisp_runtime.dictionary;
}
var List = function List(head, tail) {
    this.head = head;
    this.tail = tail || list();
    this.length = inc(count(this.tail));
    return this;
};
List.prototype.length = 0;
List.type = 'wisp.list';
List.prototype.type = List.type;
List.prototype.tail = Object.create(List.prototype);
List.prototype.toString = function () {
    return function loop() {
        var recur = loop;
        var resultø1 = '';
        var listø1 = this;
        do {
            recur = isEmpty(listø1) ? '' + '(' + resultø1.substr(1) + ')' : (loop[0] = '' + resultø1 + ' ' + (isVector(first(listø1)) ? '' + '[' + first(listø1).join(' ') + ']' : isNil(first(listø1)) ? 'nil' : isString(first(listø1)) ? JSON.stringify(first(listø1)) : isNumber(first(listø1)) ? JSON.stringify(first(listø1)) : first(listø1)), loop[1] = rest(listø1), loop);
        } while (resultø1 = loop[0], listø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var lazySeqValue = function lazySeqValue(lazySeq) {
    return !lazySeq.realized ? (lazySeq.realized = true) && (lazySeq.x = lazySeq.x()) : lazySeq.x;
};
var LazySeq = function LazySeq(realized, x) {
    this.realized = realized || false;
    this.x = x;
    return this;
};
LazySeq.type = 'wisp.lazy.seq';
LazySeq.prototype.type = LazySeq.type;
var lazySeq = exports.lazySeq = function lazySeq(realized, body) {
        return new LazySeq(realized, body);
    };
var isLazySeq = exports.isLazySeq = function isLazySeq(value) {
        return value && LazySeq.type === value.type;
    };
void 0;
var isList = exports.isList = function isList(value) {
        return value && List.type === value.type;
    };
var list = exports.list = function list() {
        return arguments.length === 0 ? Object.create(List.prototype) : Array.prototype.slice.call(arguments).reduceRight(function (tail, head) {
            return cons(head, tail);
        }, list());
    };
var cons = exports.cons = function cons(head, tail) {
        return new List(head, tail);
    };
var reverseList = function reverseList(sequence) {
    return function loop() {
        var recur = loop;
        var itemsø1 = [];
        var sourceø1 = sequence;
        do {
            recur = isEmpty(sourceø1) ? list.apply(void 0, itemsø1) : (loop[0] = [first(sourceø1)].concat(itemsø1), loop[1] = rest(sourceø1), loop);
        } while (itemsø1 = loop[0], sourceø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var isSequential = exports.isSequential = function isSequential(x) {
        return isList(x) || isVector(x) || isLazySeq(x) || isDictionary(x) || isString(x);
    };
var reverse = exports.reverse = function reverse(sequence) {
        return isList(sequence) ? reverseList(sequence) : isVector(sequence) ? sequence.reverse() : isNil(sequence) ? list() : 'else' ? reverse(seq(sequence)) : void 0;
    };
var map = exports.map = function map(f, sequence) {
        return isVector(sequence) ? sequence.map(function ($1) {
            return f($1);
        }) : isList(sequence) ? mapList(f, sequence) : isNil(sequence) ? list() : 'else' ? map(f, seq(sequence)) : void 0;
    };
var mapList = function mapList(f, sequence) {
    return function loop() {
        var recur = loop;
        var resultø1 = list();
        var itemsø1 = sequence;
        do {
            recur = isEmpty(itemsø1) ? reverse(resultø1) : (loop[0] = cons(f(first(itemsø1)), resultø1), loop[1] = rest(itemsø1), loop);
        } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var filter = exports.filter = function filter(isF, sequence) {
        return isVector(sequence) ? sequence.filter(isF) : isList(sequence) ? filterList(isF, sequence) : isNil(sequence) ? list() : 'else' ? filter(isF, seq(sequence)) : void 0;
    };
var filterList = function filterList(isF, sequence) {
    return function loop() {
        var recur = loop;
        var resultø1 = list();
        var itemsø1 = sequence;
        do {
            recur = isEmpty(itemsø1) ? reverse(resultø1) : (loop[0] = isF(first(itemsø1)) ? cons(first(itemsø1), resultø1) : resultø1, loop[1] = rest(itemsø1), loop);
        } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var reduce = exports.reduce = function reduce(f) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var hasInitialø1 = count(params) >= 2;
            var initialø1 = hasInitialø1 ? first(params) : void 0;
            var sequenceø1 = hasInitialø1 ? second(params) : first(params);
            return isNil(sequenceø1) ? initialø1 : isVector(sequenceø1) ? hasInitialø1 ? sequenceø1.reduce(f, initialø1) : sequenceø1.reduce(f) : isList(sequenceø1) ? hasInitialø1 ? reduceList(f, initialø1, sequenceø1) : reduceList(f, first(sequenceø1), rest(sequenceø1)) : 'else' ? reduce(f, initialø1, seq(sequenceø1)) : void 0;
        }.call(this);
    };
var reduceList = function reduceList(f, initial, sequence) {
    return function loop() {
        var recur = loop;
        var resultø1 = initial;
        var itemsø1 = sequence;
        do {
            recur = isEmpty(itemsø1) ? resultø1 : (loop[0] = f(resultø1, first(itemsø1)), loop[1] = rest(itemsø1), loop);
        } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var count = exports.count = function count(sequence) {
        return isNil(sequence) ? 0 : seq(sequence).length;
    };
var isEmpty = exports.isEmpty = function isEmpty(sequence) {
        return count(sequence) === 0;
    };
var first = exports.first = function first(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? sequence.head : isVector(sequence) || isString(sequence) ? (sequence || 0)[0] : isLazySeq(sequence) ? first(lazySeqValue(sequence)) : 'else' ? first(seq(sequence)) : void 0;
    };
var second = exports.second = function second(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? first(rest(sequence)) : isVector(sequence) || isString(sequence) ? (sequence || 0)[1] : isLazySeq(sequence) ? second(lazySeqValue(sequence)) : 'else' ? first(rest(seq(sequence))) : void 0;
    };
var third = exports.third = function third(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? first(rest(rest(sequence))) : isVector(sequence) || isString(sequence) ? (sequence || 0)[2] : isLazySeq(sequence) ? third(lazySeqValue(sequence)) : 'else' ? second(rest(seq(sequence))) : void 0;
    };
var rest = exports.rest = function rest(sequence) {
        return isNil(sequence) ? list() : isList(sequence) ? sequence.tail : isVector(sequence) || isString(sequence) ? sequence.slice(1) : isLazySeq(sequence) ? rest(lazySeqValue(sequence)) : 'else' ? rest(seq(sequence)) : void 0;
    };
var lastOfList = function lastOfList(list) {
    return function loop() {
        var recur = loop;
        var itemø1 = first(list);
        var itemsø1 = rest(list);
        do {
            recur = isEmpty(itemsø1) ? itemø1 : (loop[0] = first(itemsø1), loop[1] = rest(itemsø1), loop);
        } while (itemø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var last = exports.last = function last(sequence) {
        return isVector(sequence) || isString(sequence) ? (sequence || 0)[dec(count(sequence))] : isList(sequence) ? lastOfList(sequence) : isNil(sequence) ? void 0 : isLazySeq(sequence) ? last(lazySeqValue(sequence)) : 'else' ? last(seq(sequence)) : void 0;
    };
var butlast = exports.butlast = function butlast(sequence) {
        return function () {
            var itemsø1 = isNil(sequence) ? void 0 : isString(sequence) ? subs(sequence, 0, dec(count(sequence))) : isVector(sequence) ? sequence.slice(0, dec(count(sequence))) : isList(sequence) ? list.apply(void 0, butlast(vec(sequence))) : isLazySeq(sequence) ? butlast(lazySeqValue(sequence)) : 'else' ? butlast(seq(sequence)) : void 0;
            return !(isNil(itemsø1) || isEmpty(itemsø1)) ? itemsø1 : void 0;
        }.call(this);
    };
var take = exports.take = function take(n, sequence) {
        return isNil(sequence) ? list() : isVector(sequence) ? takeFromVector(n, sequence) : isList(sequence) ? takeFromList(n, sequence) : isLazySeq(sequence) ? take(n, lazySeqValue(sequence)) : 'else' ? take(n, seq(sequence)) : void 0;
    };
var takeVectorWhile = function takeVectorWhile(predicate, vector) {
    return function loop() {
        var recur = loop;
        var resultø1 = [];
        var tailø1 = vector;
        var headø1 = first(vector);
        do {
            recur = !isEmpty(tailø1) && predicate(headø1) ? (loop[0] = conj(resultø1, headø1), loop[1] = rest(tailø1), loop[2] = first(tailø1), loop) : resultø1;
        } while (resultø1 = loop[0], tailø1 = loop[1], headø1 = loop[2], recur === loop);
        return recur;
    }.call(this);
};
var takeListWhile = function takeListWhile(predicate, items) {
    return function loop() {
        var recur = loop;
        var resultø1 = [];
        var tailø1 = items;
        var headø1 = first(items);
        do {
            recur = !isEmpty(tailø1) && isPredicate(headø1) ? (loop[0] = conj(resultø1, headø1), loop[1] = rest(tailø1), loop[2] = first(tailø1), loop) : list.apply(void 0, resultø1);
        } while (resultø1 = loop[0], tailø1 = loop[1], headø1 = loop[2], recur === loop);
        return recur;
    }.call(this);
};
var takeWhile = exports.takeWhile = function takeWhile(predicate, sequence) {
        return isNil(sequence) ? list() : isVector(sequence) ? takeVectorWhile(predicate, sequence) : isList(sequence) ? takeVectorWhile(predicate, sequence) : 'else' ? takeWhile(predicate, lazySeqValue(sequence)) : void 0;
    };
var takeFromVector = function takeFromVector(n, vector) {
    return vector.slice(0, n);
};
var takeFromList = function takeFromList(n, sequence) {
    return function loop() {
        var recur = loop;
        var takenø1 = list();
        var itemsø1 = sequence;
        var nø2 = n;
        do {
            recur = nø2 === 0 || isEmpty(itemsø1) ? reverse(takenø1) : (loop[0] = cons(first(itemsø1), takenø1), loop[1] = rest(itemsø1), loop[2] = dec(nø2), loop);
        } while (takenø1 = loop[0], itemsø1 = loop[1], nø2 = loop[2], recur === loop);
        return recur;
    }.call(this);
};
var dropFromList = function dropFromList(n, sequence) {
    return function loop() {
        var recur = loop;
        var leftø1 = n;
        var itemsø1 = sequence;
        do {
            recur = leftø1 < 1 || isEmpty(itemsø1) ? itemsø1 : (loop[0] = dec(leftø1), loop[1] = rest(itemsø1), loop);
        } while (leftø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var drop = exports.drop = function drop(n, sequence) {
        return n <= 0 ? sequence : isString(sequence) ? sequence.substr(n) : isVector(sequence) ? sequence.slice(n) : isList(sequence) ? dropFromList(n, sequence) : isNil(sequence) ? list() : isLazySeq(sequence) ? drop(n, lazySeqValue(sequence)) : 'else' ? drop(n, seq(sequence)) : void 0;
    };
var conjList = function conjList(sequence, items) {
    return reduce(function (result, item) {
        return cons(item, result);
    }, sequence, items);
};
var conj = exports.conj = function conj(sequence) {
        var items = Array.prototype.slice.call(arguments, 1);
        return isVector(sequence) ? sequence.concat(items) : isString(sequence) ? '' + sequence + str.apply(void 0, items) : isNil(sequence) ? list.apply(void 0, reverse(items)) : isList(sequence) || isLazySeq() ? conjList(sequence, items) : isDictionary(sequence) ? merge(sequence, merge.apply(void 0, items)) : 'else' ? (function () {
            throw TypeError('' + 'Type can\'t be conjoined ' + sequence);
        })() : void 0;
    };
var assoc = exports.assoc = function assoc(source) {
        var keyValues = Array.prototype.slice.call(arguments, 1);
        return conj(source, dictionary.apply(void 0, keyValues));
    };
var concat = exports.concat = function concat() {
        var sequences = Array.prototype.slice.call(arguments, 0);
        return reverse(reduce(function (result, sequence) {
            return reduce(function (result, item) {
                return cons(item, result);
            }, result, seq(sequence));
        }, list(), sequences));
    };
var seq = exports.seq = function seq(sequence) {
        return isNil(sequence) ? void 0 : isVector(sequence) || isList(sequence) || isLazySeq(sequence) ? sequence : isString(sequence) ? Array.prototype.slice.call(sequence) : isDictionary(sequence) ? keyValues(sequence) : 'default' ? (function () {
            throw TypeError('' + 'Can not seq ' + sequence);
        })() : void 0;
    };
var isSeq = exports.isSeq = function isSeq(sequence) {
        return isList(sequence) || isLazySeq(sequence);
    };
var listToVector = function listToVector(source) {
    return function loop() {
        var recur = loop;
        var resultø1 = [];
        var listø1 = source;
        do {
            recur = isEmpty(listø1) ? resultø1 : (loop[0] = (function () {
                resultø1.push(first(listø1));
                return resultø1;
            })(), loop[1] = rest(listø1), loop);
        } while (resultø1 = loop[0], listø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var vec = exports.vec = function vec(sequence) {
        return isNil(sequence) ? [] : isVector(sequence) ? sequence : isList(sequence) ? listToVector(sequence) : 'else' ? vec(seq(sequence)) : void 0;
    };
var sort = exports.sort = function sort(f, items) {
        return function () {
            var hasComparatorø1 = isFn(f);
            var itemsø2 = !hasComparatorø1 && isNil(items) ? f : items;
            var compareø1 = hasComparatorø1 ? function (a, b) {
                    return f(a, b) ? 0 : 1;
                } : void 0;
            return isNil(itemsø2) ? list() : isVector(itemsø2) ? itemsø2.sort(compareø1) : isList(itemsø2) ? list.apply(void 0, vec(itemsø2).sort(compareø1)) : isDictionary(itemsø2) ? seq(itemsø2).sort(compareø1) : 'else' ? sort(f, seq(itemsø2)) : void 0;
        }.call(this);
    };
var repeat = exports.repeat = function repeat(n, x) {
        return function loop() {
            var recur = loop;
            var nø2 = n;
            var resultø1 = [];
            do {
                recur = nø2 <= 0 ? resultø1 : (loop[0] = dec(nø2), loop[1] = conj(resultø1, x), loop);
            } while (nø2 = loop[0], resultø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var isEvery = exports.isEvery = function isEvery(predicate, sequence) {
        return vec(sequence).every(function ($1) {
            return predicate($1);
        });
    };
var some = exports.some = function some(predicate, sequence) {
        return function loop() {
            var recur = loop;
            var itemsø1 = sequence;
            do {
                recur = isEmpty(itemsø1) ? false : predicate(first(itemsø1)) ? true : 'else' ? (loop[0] = rest(itemsø1), loop) : void 0;
            } while (itemsø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var partition = exports.partition = function partition() {
        switch (arguments.length) {
        case 2:
            var n = arguments[0];
            var coll = arguments[1];
            return partition(n, n, coll);
        case 3:
            var n = arguments[0];
            var step = arguments[1];
            var coll = arguments[2];
            return partition(n, step, [], coll);
        case 4:
            var n = arguments[0];
            var step = arguments[1];
            var pad = arguments[2];
            var coll = arguments[3];
            return function loop() {
                var recur = loop;
                var resultø1 = [];
                var itemsø1 = seq(coll);
                do {
                    recur = function () {
                        var chunkø1 = take(n, itemsø1);
                        var sizeø1 = count(chunkø1);
                        return sizeø1 === n ? (loop[0] = conj(resultø1, chunkø1), loop[1] = drop(step, itemsø1), loop) : 0 === sizeø1 ? resultø1 : n > sizeø1 + count(pad) ? resultø1 : 'else' ? conj(resultø1, take(n, vec(concat(chunkø1, pad)))) : void 0;
                    }.call(this);
                } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var interleave = exports.interleave = function interleave() {
        switch (arguments.length) {
        case 2:
            var ax = arguments[0];
            var bx = arguments[1];
            return function loop() {
                var recur = loop;
                var cxø1 = [];
                var axø2 = ax;
                var bxø2 = bx;
                do {
                    recur = isEmpty(axø2) || isEmpty(bxø2) ? seq(cxø1) : (loop[0] = conj(cxø1, first(axø2), first(bxø2)), loop[1] = rest(axø2), loop[2] = rest(bxø2), loop);
                } while (cxø1 = loop[0], axø2 = loop[1], bxø2 = loop[2], recur === loop);
                return recur;
            }.call(this);
        default:
            var sequences = Array.prototype.slice.call(arguments, 0);
            return function loop() {
                var recur = loop;
                var resultø1 = [];
                var sequencesø2 = sequences;
                do {
                    recur = some(isEmpty, sequencesø2) ? resultø1 : (loop[0] = concat(resultø1, map(first, sequencesø2)), loop[1] = map(rest, sequencesø2), loop);
                } while (resultø1 = loop[0], sequencesø2 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }
    };
var nth = exports.nth = function nth(sequence, index, notFound) {
        return isNil(sequence) ? notFound : isList(sequence) ? index < count(sequence) ? first(drop(index, sequence)) : notFound : isVector(sequence) || isString(sequence) ? index < count(sequence) ? sequence[index] : notFound : isLazySeq(sequence) ? nth(lazySeqValue(sequence), index, notFound) : 'else' ? (function () {
            throw TypeError('Unsupported type');
        })() : void 0;
    };
},{"./runtime":33}],35:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.string',
            doc: void 0
        };
    var wisp_runtime = require('./runtime');
    var str = wisp_runtime.str;
    var subs = wisp_runtime.subs;
    var reMatches = wisp_runtime.reMatches;
    var isNil = wisp_runtime.isNil;
    var isString = wisp_runtime.isString;
    var wisp_sequence = require('./sequence');
    var vec = wisp_sequence.vec;
    var isEmpty = wisp_sequence.isEmpty;
}
var split = exports.split = function split(string, pattern, limit) {
        return string.split(pattern, limit);
    };
var join = exports.join = function join() {
        switch (arguments.length) {
        case 1:
            var coll = arguments[0];
            return str.apply(void 0, vec(coll));
        case 2:
            var separator = arguments[0];
            var coll = arguments[1];
            return vec(coll).join(separator);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var upperCase = exports.upperCase = function upperCase(string) {
        return string.toUpperCase();
    };
var upperCase = exports.upperCase = function upperCase(string) {
        return string.toUpperCase();
    };
var lowerCase = exports.lowerCase = function lowerCase(string) {
        return string.toLowerCase();
    };
var capitalize = exports.capitalize = function capitalize(string) {
        return count(string) < 2 ? upperCase(string) : '' + upperCase(subs(s, 0, 1)) + lowerCase(subs(s, 1));
    };
var replace = exports.replace = function replace(string, match, replacement) {
        return string.replace(match, replacement);
    };
var __LEFTSPACES__ = exports.__LEFTSPACES__ = /^\s\s*/;
var __RIGHTSPACES__ = exports.__RIGHTSPACES__ = /\s\s*$/;
var __SPACES__ = exports.__SPACES__ = /^\s\s*$/;
var triml = exports.triml = isNil(''.trimLeft) ? function (string) {
        return string.replace(__LEFTSPACES__, '');
    } : function (string) {
        return string.trimLeft();
    };
var trimr = exports.trimr = isNil(''.trimRight) ? function (string) {
        return string.replace(__RIGHTSPACES__, '');
    } : function (string) {
        return string.trimRight();
    };
var trim = exports.trim = isNil(''.trim) ? function (string) {
        return string.replace(__LEFTSPACES__).replace(__RIGHTSPACES__);
    } : function (string) {
        return string.trim();
    };
var isBlank = exports.isBlank = function isBlank(string) {
        return isNil(string) || isEmpty(string) || reMatches(__SPACES__, string);
    };
},{"./runtime":33,"./sequence":34}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL21haW4uanMiLCIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L19lbXB0eS5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9idWZmZXIuanMiLCIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItYWN0aXZpbmUvY29yZS5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItcGVyc2lzdC9jb3JlLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9hbmFseXplci5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3AvYXN0LmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9iYWNrZW5kL2VzY29kZWdlbi9nZW5lcmF0b3IuanMiLCIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL25vZGVfbW9kdWxlcy93aXNwL2JhY2tlbmQvZXNjb2RlZ2VuL3dyaXRlci5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3AvY29tcGlsZXIuanMiLCIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL25vZGVfbW9kdWxlcy93aXNwL2VuZ2luZS9icm93c2VyLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9leHBhbmRlci5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3Avbm9kZV9tb2R1bGVzL2Jhc2U2NC1lbmNvZGUvc2VydmVyLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL2VzY29kZWdlbi5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3Avbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvZXN0cmF2ZXJzZS9lc3RyYXZlcnNlLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi9jb2RlLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi9rZXl3b3JkLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi91dGlscy5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3Avbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3Avbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9hcnJheS1zZXQuanMiLCIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL25vZGVfbW9kdWxlcy93aXNwL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LXZscS5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3Avbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanMiLCIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL25vZGVfbW9kdWxlcy93aXNwL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmluYXJ5LXNlYXJjaC5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3Avbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3V0aWwuanMiLCIvVXNlcnMvZ296YWxhL1Byb2plY3RzL3RyeS13aXNwL25vZGVfbW9kdWxlcy93aXNwL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL2FtZGVmaW5lL2FtZGVmaW5lLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL3BhY2thZ2UuanNvbiIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3AvcmVhZGVyLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9ydW50aW1lLmpzIiwiL1VzZXJzL2dvemFsYS9Qcm9qZWN0cy90cnktd2lzcC9ub2RlX21vZHVsZXMvd2lzcC9zZXF1ZW5jZS5qcyIsIi9Vc2Vycy9nb3phbGEvUHJvamVjdHMvdHJ5LXdpc3Avbm9kZV9tb2R1bGVzL3dpc3Avc3RyaW5nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ256REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNpRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNockJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsie1xuICAgIHZhciBfbnNfID0ge1xuICAgICAgICAgICAgaWQ6ICd0cnktd2lzcC5tYWluJyxcbiAgICAgICAgICAgIGRvYzogdm9pZCAwXG4gICAgICAgIH07XG4gICAgdmFyIGNvZGVtaXJyb3JBY3RpdmluZSA9IHJlcXVpcmUoJ2NvZGVtaXJyb3ItYWN0aXZpbmUnKTtcbiAgICB2YXIgYWN0aXZpbmUgPSBjb2RlbWlycm9yQWN0aXZpbmU7XG4gICAgdmFyIGNvZGVtaXJyb3JQZXJzaXN0ID0gcmVxdWlyZSgnY29kZW1pcnJvci1wZXJzaXN0Jyk7XG4gICAgdmFyIHBlcnNpc3QgPSBjb2RlbWlycm9yUGVyc2lzdDtcbiAgICB2YXIgd2lzcF9lbmdpbmVfYnJvd3NlciA9IHJlcXVpcmUoJ3dpc3AvZW5naW5lL2Jyb3dzZXInKTtcbiAgICB2YXIgd2lzcF9zZXF1ZW5jZSA9IHJlcXVpcmUoJ3dpc3Avc2VxdWVuY2UnKTtcbiAgICB2YXIgcmVzdCA9IHdpc3Bfc2VxdWVuY2UucmVzdDtcbiAgICB2YXIgY29ucyA9IHdpc3Bfc2VxdWVuY2UuY29ucztcbiAgICB2YXIgdmVjID0gd2lzcF9zZXF1ZW5jZS52ZWM7XG4gICAgdmFyIHdpc3BfcnVudGltZSA9IHJlcXVpcmUoJ3dpc3AvcnVudGltZScpO1xuICAgIHZhciBzdHIgPSB3aXNwX3J1bnRpbWUuc3RyO1xuICAgIHZhciB3aXNwX3JlYWRlciA9IHJlcXVpcmUoJ3dpc3AvcmVhZGVyJyk7XG4gICAgdmFyIHJlYWRfID0gd2lzcF9yZWFkZXIucmVhZF87XG4gICAgdmFyIHdpc3BfY29tcGlsZXIgPSByZXF1aXJlKCd3aXNwL2NvbXBpbGVyJyk7XG4gICAgdmFyIGNvbXBpbGUgPSB3aXNwX2NvbXBpbGVyLmNvbXBpbGU7XG59XG5wZXJzaXN0KENvZGVNaXJyb3IpO1xudmFyIHRocm90dGxlID0gZXhwb3J0cy50aHJvdHRsZSA9IGZ1bmN0aW9uIHRocm90dGxlKGxhbWJkYSwgbXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZMO4MSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZMO4MSwgdGhyb3R0bGVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWTDuDEgPSBzZXRUaW1lb3V0LmFwcGx5KHdpbmRvdywgdmVjKGNvbnMobGFtYmRhLCBjb25zKG1zLCBwYXJhbXMpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgdG9vZ2xlUHJldmlldyA9IGV4cG9ydHMudG9vZ2xlUHJldmlldyA9IGZ1bmN0aW9uIHRvb2dsZVByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0w7gxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ291dHB1dCcpO1xuICAgICAgICAgICAgdmFyIGlucHV0w7gxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBvdXRwdXTDuDEuaGlkZGVuID0gIW91dHB1dMO4MS5oaWRkZW47XG4gICAgICAgICAgICByZXR1cm4gaW5wdXTDuDEuc3R5bGUud2lkdGggPSBvdXRwdXTDuDEuaGlkZGVuID8gJzEwMCUnIDogJzUwJSc7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIF9lcnJvck1hcmtlcl8gPSBleHBvcnRzLl9lcnJvck1hcmtlcl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2aWV3w7gxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB2aWV3w7gxLnRleHRDb250ZW50ID0gJ1xcdTI1Q0YnO1xuICAgICAgICB2aWV3w7gxLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgdmlld8O4MS5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIHJldHVybiB2aWV3w7gxO1xuICAgIH0uY2FsbCh0aGlzKTtcbnZhciB1cGRhdGVQcmV2aWV3ID0gZXhwb3J0cy51cGRhdGVQcmV2aWV3ID0gdGhyb3R0bGUoZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBlZGl0b3IuY2xlYXJHdXR0ZXIoJ2Vycm9yLWd1dHRlcicpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvZGXDuDEgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHTDuDEgPSBjb21waWxlKGNvZGXDuDEsIHsgJ3NvdXJjZS11cmknOiAnc2NyYXRjaCcgfSk7XG4gICAgICAgICAgICB2YXIgZXJyb3LDuDEgPSAocmVzdWx0w7gxIHx8IDApWydlcnJvciddO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmJ1ZmZlciA9IGNvZGXDuDE7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3LDuDEgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5idWZmZXIgPSBjb2Rlw7gxO1xuICAgICAgICAgICAgICAgIF9lcnJvck1hcmtlcl8uc2V0QXR0cmlidXRlKCd0aXRsZScsIGVycm9yw7gxLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3Iuc2V0R3V0dGVyTWFya2VyKGVycm9yw7gxLmxpbmUgfHwgMCwgJ2Vycm9yLWd1dHRlcicsIF9lcnJvck1hcmtlcl8pO1xuICAgICAgICAgICAgfSkoKSA6IG91dHB1dC5zZXRWYWx1ZSgocmVzdWx0w7gxIHx8IDApWydjb2RlJ10pO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfSwgMjAwKTtcbnZhciBpbnB1dCA9IGV4cG9ydHMuaW5wdXQgPSBDb2RlTWlycm9yKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnB1dCcpLCB7XG4gICAgICAgICdsaW5lTnVtYmVycyc6IHRydWUsXG4gICAgICAgICdtYXRjaEJyYWNrZXRzJzogdHJ1ZSxcbiAgICAgICAgJ2VsZWN0cmljQ2hhcnMnOiB0cnVlLFxuICAgICAgICAncGVyc2lzdCc6IHRydWUsXG4gICAgICAgICdzdHlsZUFjdGl2ZUxpbmUnOiB0cnVlLFxuICAgICAgICAnYXV0b2ZvY3VzJzogdHJ1ZSxcbiAgICAgICAgJ3ZhbHVlJzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGVzJykuaW5uZXJIVE1MLFxuICAgICAgICAndGhlbWUnOiAnc29sYXJpemVkIGRhcmsnLFxuICAgICAgICAnbW9kZSc6ICdjbG9qdXJlJyxcbiAgICAgICAgJ2F1dG9DbGVhckVtcHR5TGluZXMnOiB0cnVlLFxuICAgICAgICAnZml4ZWRHdXR0ZXInOiB0cnVlLFxuICAgICAgICAnZ3V0dGVycyc6IFsnZXJyb3ItZ3V0dGVyJ10sXG4gICAgICAgICdleHRyYUtleXMnOiB7ICdUYWInOiAnaW5kZW50U2VsZWN0aW9uJyB9LFxuICAgICAgICAnb25DaGFuZ2UnOiB1cGRhdGVQcmV2aWV3LFxuICAgICAgICAnb25HdXR0ZXJDbGljayc6IHRvb2dsZVByZXZpZXdcbiAgICB9KTtcbmlucHV0Lm9uKCdjaGFuZ2UnLCB1cGRhdGVQcmV2aWV3KTtcbmlucHV0Lm9uKCdndXR0ZXJDbGljaycsIHRvb2dsZVByZXZpZXcpO1xudXBkYXRlUHJldmlldyhpbnB1dCk7XG52YXIgb3V0cHV0ID0gZXhwb3J0cy5vdXRwdXQgPSBDb2RlTWlycm9yKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdXRwdXQnKSwge1xuICAgICAgICAnbGluZU51bWJlcnMnOiB0cnVlLFxuICAgICAgICAnZml4ZWRHdXR0ZXInOiB0cnVlLFxuICAgICAgICAnbWF0Y2hCcmFja2V0cyc6IHRydWUsXG4gICAgICAgICdtb2RlJzogJ2phdmFzY3JpcHQnLFxuICAgICAgICAndGhlbWUnOiAnc29sYXJpemVkIGRhcmsnLFxuICAgICAgICAncmVhZE9ubHknOiB0cnVlXG4gICAgfSk7IixudWxsLCJyZXF1aXJlPShmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHtcIlBjWmo5TFwiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBUQSA9IHJlcXVpcmUoJ3R5cGVkYXJyYXknKVxudmFyIHhEYXRhVmlldyA9IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCdcbiAgPyBUQS5EYXRhVmlldyA6IERhdGFWaWV3XG52YXIgeEFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJ1xuICA/IFRBLkFycmF5QnVmZmVyIDogQXJyYXlCdWZmZXJcbnZhciB4VWludDhBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJ1xuICA/IFRBLlVpbnQ4QXJyYXkgOiBVaW50OEFycmF5XG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG52YXIgYnJvd3NlclN1cHBvcnRcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKlxuICogRmlyZWZveCBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIGl0IGRvZXNuJ3QgYWxsb3cgYXVnbWVudGluZyBcIm5hdGl2ZVwiIG9iamVjdFxuICogaW5zdGFuY2VzLiBTZWUgYFByb3h5QnVmZmVyYCBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrLWFyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvblxuICAvLyBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5ncyB3aGlsZSBiYXNlNjQtanNcbiAgLy8gZG9lcyBub3QuLlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gQXNzdW1lIG9iamVjdCBpcyBhbiBhcnJheVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZiA9IGF1Z21lbnQobmV3IHhVaW50OEFycmF5KGxlbmd0aCkpXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSBVaW50OEFycmF5XG4gICAgYnVmLnNldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgc3dpdGNoICgoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWVcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAmJiBiLl9pc0J1ZmZlclxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMlxuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoXG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcbiAgfVxuXG4gIHZhciBpXG4gIHZhciBidWZcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZiA9IGxpc3RbaV1cbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBidWYgPSBsaXN0W2ldXG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8vIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvc1xuICByZXR1cm4gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3NcbiAgcmV0dXJuIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3NcbiAgcmV0dXJuIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbn1cblxuZnVuY3Rpb24gQnVmZmVyVG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gKHRoaXMgaW5zdGFuY2VvZiBQcm94eUJ1ZmZlcilcbiAgICA/IHRoaXMuX3Byb3h5XG4gICAgOiB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gX2hleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIF9iaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5mdW5jdGlvbiBCdWZmZXJDb3B5ICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIC8vIGNvcHkhXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7IGkrKylcbiAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHJldHVybiByZXF1aXJlKCdiYXNlNjQtanMnKS5mcm9tQnl0ZUFycmF5KGJ5dGVzKVxufVxuXG5mdW5jdGlvbiBfdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBieXRlc1tpXS50b1N0cmluZygxNilcbiAgICB9XG5cbiAgICBpKytcbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXQgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8vIFRPRE86IGFkZCB0ZXN0IHRoYXQgbW9kaWZ5aW5nIHRoZSBuZXcgYnVmZmVyIHNsaWNlIHdpbGwgbW9kaWZ5IG1lbW9yeSBpbiB0aGVcbi8vIG9yaWdpbmFsIGJ1ZmZlciEgVXNlIGNvZGUgZnJvbTpcbi8vIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmX3NsaWNlX3N0YXJ0X2VuZFxuZnVuY3Rpb24gQnVmZmVyU2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcbiAgcmV0dXJuIGF1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSkgLy8gVWludDhBcnJheSBidWlsdC1pbiBtZXRob2Rcbn1cblxuZnVuY3Rpb24gQnVmZmVyUmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWYgPSB0aGlzXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWYubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiBidWZbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgKGxpdHRsZUVuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pIHtcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChvZmZzZXQgKyAxID09PSBsZW4pIHtcbiAgICB2YXIgZHYgPSBuZXcgeERhdGFWaWV3KG5ldyB4QXJyYXlCdWZmZXIoMikpXG4gICAgZHYuc2V0VWludDgoMCwgYnVmW2xlbiAtIDFdKVxuICAgIHJldHVybiBkdi5nZXRVaW50MTYoMCwgbGl0dGxlRW5kaWFuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYuX2RhdGF2aWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgfVxufVxuXG5mdW5jdGlvbiBCdWZmZXJSZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiAobGl0dGxlRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbikge1xuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKG9mZnNldCArIDMgPj0gbGVuKSB7XG4gICAgdmFyIGR2ID0gbmV3IHhEYXRhVmlldyhuZXcgeEFycmF5QnVmZmVyKDQpKVxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgb2Zmc2V0IDwgbGVuOyBpKyspIHtcbiAgICAgIGR2LnNldFVpbnQ4KGksIGJ1ZltpICsgb2Zmc2V0XSlcbiAgICB9XG4gICAgcmV0dXJuIGR2LmdldFVpbnQzMigwLCBsaXR0bGVFbmRpYW4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1Zi5fZGF0YXZpZXcuZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICB9XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gQnVmZmVyUmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gQnVmZmVyUmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZiA9IHRoaXNcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1Zi5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIGJ1Zi5fZGF0YXZpZXcuZ2V0SW50OChvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIChsaXR0bGVFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKSB7XG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAob2Zmc2V0ICsgMSA9PT0gbGVuKSB7XG4gICAgdmFyIGR2ID0gbmV3IHhEYXRhVmlldyhuZXcgeEFycmF5QnVmZmVyKDIpKVxuICAgIGR2LnNldFVpbnQ4KDAsIGJ1ZltsZW4gLSAxXSlcbiAgICByZXR1cm4gZHYuZ2V0SW50MTYoMCwgbGl0dGxlRW5kaWFuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYuX2RhdGF2aWV3LmdldEludDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICB9XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiAobGl0dGxlRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbikge1xuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKG9mZnNldCArIDMgPj0gbGVuKSB7XG4gICAgdmFyIGR2ID0gbmV3IHhEYXRhVmlldyhuZXcgeEFycmF5QnVmZmVyKDQpKVxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgb2Zmc2V0IDwgbGVuOyBpKyspIHtcbiAgICAgIGR2LnNldFVpbnQ4KGksIGJ1ZltpICsgb2Zmc2V0XSlcbiAgICB9XG4gICAgcmV0dXJuIGR2LmdldEludDMyKDAsIGxpdHRsZUVuZGlhbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmLl9kYXRhdmlldy5nZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgfVxufVxuXG5mdW5jdGlvbiBCdWZmZXJSZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBCdWZmZXJSZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgKGxpdHRsZUVuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBidWYuX2RhdGF2aWV3LmdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgKGxpdHRsZUVuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBidWYuX2RhdGF2aWV3LmdldEZsb2F0NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlclJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gQnVmZmVyUmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gQnVmZmVyV3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZiA9IHRoaXNcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWYubGVuZ3RoKSByZXR1cm5cblxuICBidWZbb2Zmc2V0XSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgKGxpdHRsZUVuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKSB7XG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAob2Zmc2V0ICsgMSA9PT0gbGVuKSB7XG4gICAgdmFyIGR2ID0gbmV3IHhEYXRhVmlldyhuZXcgeEFycmF5QnVmZmVyKDIpKVxuICAgIGR2LnNldFVpbnQxNigwLCB2YWx1ZSwgbGl0dGxlRW5kaWFuKVxuICAgIGJ1ZltvZmZzZXRdID0gZHYuZ2V0VWludDgoMClcbiAgfSBlbHNlIHtcbiAgICBidWYuX2RhdGF2aWV3LnNldFVpbnQxNihvZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pXG4gIH1cbn1cblxuZnVuY3Rpb24gQnVmZmVyV3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBCdWZmZXJXcml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIChsaXR0bGVFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pIHtcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChvZmZzZXQgKyAzID49IGxlbikge1xuICAgIHZhciBkdiA9IG5ldyB4RGF0YVZpZXcobmV3IHhBcnJheUJ1ZmZlcig0KSlcbiAgICBkdi5zZXRVaW50MzIoMCwgdmFsdWUsIGxpdHRsZUVuZGlhbilcbiAgICBmb3IgKHZhciBpID0gMDsgaSArIG9mZnNldCA8IGxlbjsgaSsrKSB7XG4gICAgICBidWZbaSArIG9mZnNldF0gPSBkdi5nZXRVaW50OChpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuX2RhdGF2aWV3LnNldFVpbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pXG4gIH1cbn1cblxuZnVuY3Rpb24gQnVmZmVyV3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBCdWZmZXJXcml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBCdWZmZXJXcml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWYgPSB0aGlzXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1Zi5sZW5ndGgpIHJldHVyblxuXG4gIGJ1Zi5fZGF0YXZpZXcuc2V0SW50OChvZmZzZXQsIHZhbHVlKVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgKGxpdHRsZUVuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKSB7XG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAob2Zmc2V0ICsgMSA9PT0gbGVuKSB7XG4gICAgdmFyIGR2ID0gbmV3IHhEYXRhVmlldyhuZXcgeEFycmF5QnVmZmVyKDIpKVxuICAgIGR2LnNldEludDE2KDAsIHZhbHVlLCBsaXR0bGVFbmRpYW4pXG4gICAgYnVmW29mZnNldF0gPSBkdi5nZXRVaW50OCgwKVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5fZGF0YXZpZXcuc2V0SW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKVxuICB9XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgKGxpdHRsZUVuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pIHtcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChvZmZzZXQgKyAzID49IGxlbikge1xuICAgIHZhciBkdiA9IG5ldyB4RGF0YVZpZXcobmV3IHhBcnJheUJ1ZmZlcig0KSlcbiAgICBkdi5zZXRJbnQzMigwLCB2YWx1ZSwgbGl0dGxlRW5kaWFuKVxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgb2Zmc2V0IDwgbGVuOyBpKyspIHtcbiAgICAgIGJ1ZltpICsgb2Zmc2V0XSA9IGR2LmdldFVpbnQ4KGkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5fZGF0YXZpZXcuc2V0SW50MzIob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKVxuICB9XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgKGxpdHRsZUVuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pIHtcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChvZmZzZXQgKyAzID49IGxlbikge1xuICAgIHZhciBkdiA9IG5ldyB4RGF0YVZpZXcobmV3IHhBcnJheUJ1ZmZlcig0KSlcbiAgICBkdi5zZXRGbG9hdDMyKDAsIHZhbHVlLCBsaXR0bGVFbmRpYW4pXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyBvZmZzZXQgPCBsZW47IGkrKykge1xuICAgICAgYnVmW2kgKyBvZmZzZXRdID0gZHYuZ2V0VWludDgoaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLl9kYXRhdmlldy5zZXRGbG9hdDMyKG9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbilcbiAgfVxufVxuXG5mdW5jdGlvbiBCdWZmZXJXcml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBCdWZmZXJXcml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiAobGl0dGxlRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKSB7XG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAob2Zmc2V0ICsgNyA+PSBsZW4pIHtcbiAgICB2YXIgZHYgPSBuZXcgeERhdGFWaWV3KG5ldyB4QXJyYXlCdWZmZXIoOCkpXG4gICAgZHYuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgbGl0dGxlRW5kaWFuKVxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgb2Zmc2V0IDwgbGVuOyBpKyspIHtcbiAgICAgIGJ1ZltpICsgb2Zmc2V0XSA9IGR2LmdldFVpbnQ4KGkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5fZGF0YXZpZXcuc2V0RmxvYXQ2NChvZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pXG4gIH1cbn1cblxuZnVuY3Rpb24gQnVmZmVyV3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBCdWZmZXJXcml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbmZ1bmN0aW9uIEJ1ZmZlckZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckluc3BlY3QgKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vLyBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4vLyBBZGRlZCBpbiBOb2RlIDAuMTIuXG5mdW5jdGlvbiBCdWZmZXJUb0FycmF5QnVmZmVyICgpIHtcbiAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbn1cblxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1Z21lbnRpbmcgYSBgVWludDhBcnJheWAgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBfYnJvd3NlclN1cHBvcnQgKCkge1xuICB2YXIgYXJyID0gbmV3IHhVaW50OEFycmF5KDApXG4gIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gKDQyID09PSBhcnIuZm9vKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzOiBQcm94eUJ1ZmZlclxuICogPT09PT09PT09PT09PT09PT09XG4gKlxuICogT25seSB1c2VkIGluIEZpcmVmb3gsIHNpbmNlIEZpcmVmb3ggZG9lcyBub3QgYWxsb3cgYXVnbWVudGluZyBcIm5hdGl2ZVwiXG4gKiBvYmplY3RzIChsaWtlIFVpbnQ4QXJyYXkgaW5zdGFuY2VzKSB3aXRoIG5ldyBwcm9wZXJ0aWVzIGZvciBzb21lIHVua25vd25cbiAqIChwcm9iYWJseSBzaWxseSkgcmVhc29uLiBTbyB3ZSdsbMKgdXNlIGFuIEVTNiBQcm94eSAoc3VwcG9ydGVkIHNpbmNlXG4gKiBGaXJlZm94IDE4KSB0byB3cmFwIHRoZSBVaW50OEFycmF5IGluc3RhbmNlIHdpdGhvdXQgYWN0dWFsbHkgYWRkaW5nIGFueVxuICogcHJvcGVydGllcyB0byBpdC5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBcImZha2VcIiBCdWZmZXIgY2xhc3MgYXJlIHRoZSBcInRhcmdldFwiIG9mIHRoZVxuICogRVM2IFByb3h5IChzZWUgYGF1Z21lbnRgIGZ1bmN0aW9uKS5cbiAqXG4gKiBXZSBjb3VsZG4ndCBqdXN0IHVzZSB0aGUgYFVpbnQ4QXJyYXlgIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGBQcm94eWAgYmVjYXVzZVxuICogUHJveGllcyBoYXZlIGFuIGltcG9ydGFudCBsaW1pdGF0aW9uIG9uIHRyYXBwaW5nIHRoZSBgdG9TdHJpbmdgIG1ldGhvZC5cbiAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJveHkpYCBnZXRzIGNhbGxlZCB3aGVuZXZlciBzb21ldGhpbmcgaXNcbiAqIGltcGxpY2l0bHkgY2FzdCB0byBhIFN0cmluZy4gVW5mb3J0dW5hdGVseSwgd2l0aCBhIGBQcm94eWAgdGhpc1xuICogdW5jb25kaXRpb25hbGx5IHJldHVybnMgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXQpYCB3aGljaCB3b3VsZFxuICogYWx3YXlzIHJldHVybiBcIltvYmplY3QgVWludDhBcnJheV1cIiBpZiB3ZSB1c2VkIHRoZSBgVWludDhBcnJheWAgaW5zdGFuY2UgYXNcbiAqIHRoZSB0YXJnZXQuIEFuZCwgcmVtZW1iZXIsIGluIEZpcmVmb3ggd2UgY2Fubm90IHJlZGVmaW5lIHRoZSBgVWludDhBcnJheWBcbiAqIGluc3RhbmNlJ3MgYHRvU3RyaW5nYCBtZXRob2QuXG4gKlxuICogU28sIHdlIHVzZSB0aGlzIGBQcm94eUJ1ZmZlcmAgY2xhc3MgYXMgdGhlIHByb3h5J3MgXCJ0YXJnZXRcIi4gU2luY2UgdGhpcyBjbGFzc1xuICogaGFzIGl0cyBvd24gY3VzdG9tIGB0b1N0cmluZ2AgbWV0aG9kLCBpdCB3aWxsIGdldCBjYWxsZWQgd2hlbmV2ZXIgYHRvU3RyaW5nYFxuICogZ2V0cyBjYWxsZWQsIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSwgb24gdGhlIGBQcm94eWAgaW5zdGFuY2UuXG4gKlxuICogV2UgYWxzbyBoYXZlIHRvIGRlZmluZSB0aGUgVWludDhBcnJheSBtZXRob2RzIGBzdWJhcnJheWAgYW5kIGBzZXRgIG9uXG4gKiBgUHJveHlCdWZmZXJgIGJlY2F1c2UgaWYgd2UgZGlkbid0IHRoZW4gYHByb3h5LnN1YmFycmF5KDApYCB3b3VsZCBoYXZlIGl0c1xuICogYHRoaXNgIHNldCB0byBgcHJveHlgIChhIGBQcm94eWAgaW5zdGFuY2UpIHdoaWNoIHRocm93cyBhbiBleGNlcHRpb24gaW5cbiAqIEZpcmVmb3ggd2hpY2ggZXhwZWN0cyBpdCB0byBiZSBhIGBUeXBlZEFycmF5YCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gUHJveHlCdWZmZXIgKGFycikge1xuICB0aGlzLl9hcnIgPSBhcnJcblxuICBpZiAoYXJyLmJ5dGVMZW5ndGggIT09IDApXG4gICAgdGhpcy5fZGF0YXZpZXcgPSBuZXcgeERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aClcbn1cblxuUHJveHlCdWZmZXIucHJvdG90eXBlLndyaXRlID0gQnVmZmVyV3JpdGVcblByb3h5QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IEJ1ZmZlclRvU3RyaW5nXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXJUb1N0cmluZ1xuUHJveHlCdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IEJ1ZmZlclRvSlNPTlxuUHJveHlCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBCdWZmZXJDb3B5XG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBCdWZmZXJTbGljZVxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IEJ1ZmZlclJlYWRVSW50OFxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlclJlYWRVSW50MTZMRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlclJlYWRVSW50MTZCRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IEJ1ZmZlclJlYWRVSW50MzJMRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlclJlYWRVSW50MzJCRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyUmVhZEludDhcblByb3h5QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IEJ1ZmZlclJlYWRJbnQxNkxFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXJSZWFkSW50MTZCRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyUmVhZEludDMyTEVcblByb3h5QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IEJ1ZmZlclJlYWRJbnQzMkJFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXJSZWFkRmxvYXRMRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyUmVhZEZsb2F0QkVcblByb3h5QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBCdWZmZXJSZWFkRG91YmxlTEVcblByb3h5QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXJSZWFkRG91YmxlQkVcblByb3h5QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyV3JpdGVVSW50OFxuUHJveHlCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBCdWZmZXJXcml0ZVVJbnQxNkxFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlcldyaXRlVUludDE2QkVcblByb3h5QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyV3JpdGVVSW50MzJMRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBCdWZmZXJXcml0ZVVJbnQzMkJFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyV3JpdGVJbnQ4XG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyV3JpdGVJbnQxNkxFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gQnVmZmVyV3JpdGVJbnQxNkJFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyV3JpdGVJbnQzMkxFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyV3JpdGVJbnQzMkJFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gQnVmZmVyV3JpdGVGbG9hdExFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyV3JpdGVGbG9hdEJFXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlcldyaXRlRG91YmxlTEVcblByb3h5QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gQnVmZmVyV3JpdGVEb3VibGVCRVxuUHJveHlCdWZmZXIucHJvdG90eXBlLmZpbGwgPSBCdWZmZXJGaWxsXG5Qcm94eUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IEJ1ZmZlckluc3BlY3RcblByb3h5QnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gQnVmZmVyVG9BcnJheUJ1ZmZlclxuUHJveHlCdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblByb3h5QnVmZmVyLnByb3RvdHlwZS5zdWJhcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Fyci5zdWJhcnJheS5hcHBseSh0aGlzLl9hcnIsIGFyZ3VtZW50cylcbn1cblByb3h5QnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9hcnIuc2V0LmFwcGx5KHRoaXMuX2FyciwgYXJndW1lbnRzKVxufVxuXG52YXIgUHJveHlIYW5kbGVyID0ge1xuICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiB0YXJnZXQpIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICBlbHNlIHJldHVybiB0YXJnZXQuX2FycltuYW1lXVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdGFyZ2V0Ll9hcnJbbmFtZV0gPSB2YWx1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnQgKGFycikge1xuICBpZiAoYnJvd3NlclN1cHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIGJyb3dzZXJTdXBwb3J0ID0gX2Jyb3dzZXJTdXBwb3J0KClcbiAgfVxuXG4gIGlmIChicm93c2VyU3VwcG9ydCkge1xuICAgIC8vIEF1Z21lbnQgdGhlIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAgICBhcnIud3JpdGUgPSBCdWZmZXJXcml0ZVxuICAgIGFyci50b1N0cmluZyA9IEJ1ZmZlclRvU3RyaW5nXG4gICAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyVG9TdHJpbmdcbiAgICBhcnIudG9KU09OID0gQnVmZmVyVG9KU09OXG4gICAgYXJyLmNvcHkgPSBCdWZmZXJDb3B5XG4gICAgYXJyLnNsaWNlID0gQnVmZmVyU2xpY2VcbiAgICBhcnIucmVhZFVJbnQ4ID0gQnVmZmVyUmVhZFVJbnQ4XG4gICAgYXJyLnJlYWRVSW50MTZMRSA9IEJ1ZmZlclJlYWRVSW50MTZMRVxuICAgIGFyci5yZWFkVUludDE2QkUgPSBCdWZmZXJSZWFkVUludDE2QkVcbiAgICBhcnIucmVhZFVJbnQzMkxFID0gQnVmZmVyUmVhZFVJbnQzMkxFXG4gICAgYXJyLnJlYWRVSW50MzJCRSA9IEJ1ZmZlclJlYWRVSW50MzJCRVxuICAgIGFyci5yZWFkSW50OCA9IEJ1ZmZlclJlYWRJbnQ4XG4gICAgYXJyLnJlYWRJbnQxNkxFID0gQnVmZmVyUmVhZEludDE2TEVcbiAgICBhcnIucmVhZEludDE2QkUgPSBCdWZmZXJSZWFkSW50MTZCRVxuICAgIGFyci5yZWFkSW50MzJMRSA9IEJ1ZmZlclJlYWRJbnQzMkxFXG4gICAgYXJyLnJlYWRJbnQzMkJFID0gQnVmZmVyUmVhZEludDMyQkVcbiAgICBhcnIucmVhZEZsb2F0TEUgPSBCdWZmZXJSZWFkRmxvYXRMRVxuICAgIGFyci5yZWFkRmxvYXRCRSA9IEJ1ZmZlclJlYWRGbG9hdEJFXG4gICAgYXJyLnJlYWREb3VibGVMRSA9IEJ1ZmZlclJlYWREb3VibGVMRVxuICAgIGFyci5yZWFkRG91YmxlQkUgPSBCdWZmZXJSZWFkRG91YmxlQkVcbiAgICBhcnIud3JpdGVVSW50OCA9IEJ1ZmZlcldyaXRlVUludDhcbiAgICBhcnIud3JpdGVVSW50MTZMRSA9IEJ1ZmZlcldyaXRlVUludDE2TEVcbiAgICBhcnIud3JpdGVVSW50MTZCRSA9IEJ1ZmZlcldyaXRlVUludDE2QkVcbiAgICBhcnIud3JpdGVVSW50MzJMRSA9IEJ1ZmZlcldyaXRlVUludDMyTEVcbiAgICBhcnIud3JpdGVVSW50MzJCRSA9IEJ1ZmZlcldyaXRlVUludDMyQkVcbiAgICBhcnIud3JpdGVJbnQ4ID0gQnVmZmVyV3JpdGVJbnQ4XG4gICAgYXJyLndyaXRlSW50MTZMRSA9IEJ1ZmZlcldyaXRlSW50MTZMRVxuICAgIGFyci53cml0ZUludDE2QkUgPSBCdWZmZXJXcml0ZUludDE2QkVcbiAgICBhcnIud3JpdGVJbnQzMkxFID0gQnVmZmVyV3JpdGVJbnQzMkxFXG4gICAgYXJyLndyaXRlSW50MzJCRSA9IEJ1ZmZlcldyaXRlSW50MzJCRVxuICAgIGFyci53cml0ZUZsb2F0TEUgPSBCdWZmZXJXcml0ZUZsb2F0TEVcbiAgICBhcnIud3JpdGVGbG9hdEJFID0gQnVmZmVyV3JpdGVGbG9hdEJFXG4gICAgYXJyLndyaXRlRG91YmxlTEUgPSBCdWZmZXJXcml0ZURvdWJsZUxFXG4gICAgYXJyLndyaXRlRG91YmxlQkUgPSBCdWZmZXJXcml0ZURvdWJsZUJFXG4gICAgYXJyLmZpbGwgPSBCdWZmZXJGaWxsXG4gICAgYXJyLmluc3BlY3QgPSBCdWZmZXJJbnNwZWN0XG4gICAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCdWZmZXJUb0FycmF5QnVmZmVyXG4gICAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAgIGlmIChhcnIuYnl0ZUxlbmd0aCAhPT0gMClcbiAgICAgIGFyci5fZGF0YXZpZXcgPSBuZXcgeERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiBhcnJcblxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IGF1Z21lbnRpbmcgdGhlIGBVaW50OEFycmF5YFxuICAgIC8vIGluc3RhbmNlICgqYWhlbSogRmlyZWZveCkgc28gdXNlIGFuIEVTNiBgUHJveHlgLlxuICAgIHZhciBwcm94eUJ1ZmZlciA9IG5ldyBQcm94eUJ1ZmZlcihhcnIpXG4gICAgdmFyIHByb3h5ID0gbmV3IFByb3h5KHByb3h5QnVmZmVyLCBQcm94eUhhbmRsZXIpXG4gICAgcHJveHlCdWZmZXIuX3Byb3h5ID0gcHJveHlcbiAgICByZXR1cm4gcHJveHlcbiAgfVxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgIGlmIChzdHIuY2hhckNvZGVBdChpKSA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJ2Jhc2U2NC1qcycpLnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3MsIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcblxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICAgIGkrK1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqXG4gKiAgICAgIHZhbHVlICAgICAgICAgICBUaGUgbnVtYmVyIHRvIGNoZWNrIGZvciB2YWxpZGl0eVxuICpcbiAqICAgICAgbWF4ICAgICAgICAgICAgIFRoZSBtYXhpbXVtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsXG4gICAgICAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG5cbn0se1wiYmFzZTY0LWpzXCI6MyxcInR5cGVkYXJyYXlcIjo0fV0sXCJuYXRpdmUtYnVmZmVyLWJyb3dzZXJpZnlcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cz1yZXF1aXJlKCdQY1pqOUwnKTtcbn0se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdW5kZWZpbmVkID0gKHZvaWQgMCk7IC8vIFBhcmFub2lhXG5cbi8vIEJleW9uZCB0aGlzIHZhbHVlLCBpbmRleCBnZXR0ZXJzL3NldHRlcnMgKGkuZS4gYXJyYXlbMF0sIGFycmF5WzFdKSBhcmUgc28gc2xvdyB0b1xuLy8gY3JlYXRlLCBhbmQgY29uc3VtZSBzbyBtdWNoIG1lbW9yeSwgdGhhdCB0aGUgYnJvd3NlciBhcHBlYXJzIGZyb3plbi5cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gMWU1O1xuXG4vLyBBcHByb3hpbWF0aW9ucyBvZiBpbnRlcm5hbCBFQ01BU2NyaXB0IGNvbnZlcnNpb24gZnVuY3Rpb25zXG52YXIgRUNNQVNjcmlwdCA9IChmdW5jdGlvbigpIHtcbiAgLy8gU3Rhc2ggYSBjb3B5IGluIGNhc2Ugb3RoZXIgc2NyaXB0cyBtb2RpZnkgdGhlc2VcbiAgdmFyIG9wdHMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgb3Bob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIHJldHVybiB7XG4gICAgLy8gQ2xhc3MgcmV0dXJucyBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHksIHVzZWQgdG8gYXZvaWQgY3Jvc3MtZnJhbWUgaW5zdGFuY2VvZiBpc3N1ZXM6XG4gICAgQ2xhc3M6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIG9wdHMuY2FsbCh2KS5yZXBsYWNlKC9eXFxbb2JqZWN0ICp8XFxdJC9nLCAnJyk7IH0sXG4gICAgSGFzUHJvcGVydHk6IGZ1bmN0aW9uKG8sIHApIHsgcmV0dXJuIHAgaW4gbzsgfSxcbiAgICBIYXNPd25Qcm9wZXJ0eTogZnVuY3Rpb24obywgcCkgeyByZXR1cm4gb3Bob3AuY2FsbChvLCBwKTsgfSxcbiAgICBJc0NhbGxhYmxlOiBmdW5jdGlvbihvKSB7IHJldHVybiB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgICBUb0ludDMyOiBmdW5jdGlvbih2KSB7IHJldHVybiB2ID4+IDA7IH0sXG4gICAgVG9VaW50MzI6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgPj4+IDA7IH1cbiAgfTtcbn0oKSk7XG5cbi8vIFNuYXBzaG90IGludHJpbnNpY3NcbnZhciBMTjIgPSBNYXRoLkxOMixcbiAgICBhYnMgPSBNYXRoLmFicyxcbiAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbG9nID0gTWF0aC5sb2csXG4gICAgbWluID0gTWF0aC5taW4sXG4gICAgcG93ID0gTWF0aC5wb3csXG4gICAgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4vLyBFUzU6IGxvY2sgZG93biBvYmplY3QgcHJvcGVydGllc1xuZnVuY3Rpb24gY29uZmlndXJlUHJvcGVydGllcyhvYmopIHtcbiAgaWYgKGdldE93blByb3BlcnR5TmFtZXMgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICB2YXIgcHJvcHMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaiksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BzW2ldLCB7XG4gICAgICAgIHZhbHVlOiBvYmpbcHJvcHNbaV1dLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gZW11bGF0ZSBFUzUgZ2V0dGVyL3NldHRlciBBUEkgdXNpbmcgbGVnYWN5IEFQSXNcbi8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llL2FyY2hpdmUvMjAxMC8wOS8wNy90cmFuc2l0aW9uaW5nLWV4aXN0aW5nLWNvZGUtdG8tdGhlLWVzNS1nZXR0ZXItc2V0dGVyLWFwaXMuYXNweFxuLy8gKHNlY29uZCBjbGF1c2UgdGVzdHMgZm9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGluIElFPDkgdGhhdCBvbmx5IHN1cHBvcnRzIGV4dGVuZGluZyBET00gcHJvdG90eXBlcywgYnV0XG4vLyBub3RlIHRoYXQgSUU8OSBkb2VzIG5vdCBzdXBwb3J0IF9fZGVmaW5lR2V0dGVyX18gb3IgX19kZWZpbmVTZXR0ZXJfXyBzbyBpdCBqdXN0IHJlbmRlcnMgdGhlIG1ldGhvZCBoYXJtbGVzcylcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbihvLCBwLCBkZXNjKSB7XG4gIGlmICghbyA9PT0gT2JqZWN0KG8pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxlZCBvbiBub24tb2JqZWN0XCIpO1xuICBpZiAoRUNNQVNjcmlwdC5IYXNQcm9wZXJ0eShkZXNjLCAnZ2V0JykgJiYgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKSB7IE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXy5jYWxsKG8sIHAsIGRlc2MuZ2V0KTsgfVxuICBpZiAoRUNNQVNjcmlwdC5IYXNQcm9wZXJ0eShkZXNjLCAnc2V0JykgJiYgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKSB7IE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG8sIHAsIGRlc2Muc2V0KTsgfVxuICBpZiAoRUNNQVNjcmlwdC5IYXNQcm9wZXJ0eShkZXNjLCAndmFsdWUnKSkgeyBvW3BdID0gZGVzYy52YWx1ZTsgfVxuICByZXR1cm4gbztcbn07XG5cbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvKSB7XG4gIGlmIChvICE9PSBPYmplY3QobykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBjYWxsZWQgb24gbm9uLW9iamVjdFwiKTtcbiAgdmFyIHByb3BzID0gW10sIHA7XG4gIGZvciAocCBpbiBvKSB7XG4gICAgaWYgKEVDTUFTY3JpcHQuSGFzT3duUHJvcGVydHkobywgcCkpIHtcbiAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn07XG5cbi8vIEVTNTogTWFrZSBvYmpbaW5kZXhdIGFuIGFsaWFzIGZvciBvYmouX2dldHRlcihpbmRleCkvb2JqLl9zZXR0ZXIoaW5kZXgsIHZhbHVlKVxuLy8gZm9yIGluZGV4IGluIDAgLi4uIG9iai5sZW5ndGhcbmZ1bmN0aW9uIG1ha2VBcnJheUFjY2Vzc29ycyhvYmopIHtcbiAgaWYgKCFkZWZpbmVQcm9wZXJ0eSkgeyByZXR1cm47IH1cblxuICBpZiAob2JqLmxlbmd0aCA+IE1BWF9BUlJBWV9MRU5HVEgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgdG9vIGxhcmdlIGZvciBwb2x5ZmlsbFwiKTtcblxuICBmdW5jdGlvbiBtYWtlQXJyYXlBY2Nlc3NvcihpbmRleCkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iaiwgaW5kZXgsIHtcbiAgICAgICdnZXQnOiBmdW5jdGlvbigpIHsgcmV0dXJuIG9iai5fZ2V0dGVyKGluZGV4KTsgfSxcbiAgICAgICdzZXQnOiBmdW5jdGlvbih2KSB7IG9iai5fc2V0dGVyKGluZGV4LCB2KTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgIG1ha2VBcnJheUFjY2Vzc29yKGkpO1xuICB9XG59XG5cbi8vIEludGVybmFsIGNvbnZlcnNpb24gZnVuY3Rpb25zOlxuLy8gICAgcGFjazxUeXBlPigpICAgLSB0YWtlIGEgbnVtYmVyIChpbnRlcnByZXRlZCBhcyBUeXBlKSwgb3V0cHV0IGEgYnl0ZSBhcnJheVxuLy8gICAgdW5wYWNrPFR5cGU+KCkgLSB0YWtlIGEgYnl0ZSBhcnJheSwgb3V0cHV0IGEgVHlwZS1saWtlIG51bWJlclxuXG5mdW5jdGlvbiBhc19zaWduZWQodmFsdWUsIGJpdHMpIHsgdmFyIHMgPSAzMiAtIGJpdHM7IHJldHVybiAodmFsdWUgPDwgcykgPj4gczsgfVxuZnVuY3Rpb24gYXNfdW5zaWduZWQodmFsdWUsIGJpdHMpIHsgdmFyIHMgPSAzMiAtIGJpdHM7IHJldHVybiAodmFsdWUgPDwgcykgPj4+IHM7IH1cblxuZnVuY3Rpb24gcGFja0k4KG4pIHsgcmV0dXJuIFtuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja0k4KGJ5dGVzKSB7IHJldHVybiBhc19zaWduZWQoYnl0ZXNbMF0sIDgpOyB9XG5cbmZ1bmN0aW9uIHBhY2tVOChuKSB7IHJldHVybiBbbiAmIDB4ZmZdOyB9XG5mdW5jdGlvbiB1bnBhY2tVOChieXRlcykgeyByZXR1cm4gYXNfdW5zaWduZWQoYnl0ZXNbMF0sIDgpOyB9XG5cbmZ1bmN0aW9uIHBhY2tVOENsYW1wZWQobikgeyBuID0gcm91bmQoTnVtYmVyKG4pKTsgcmV0dXJuIFtuIDwgMCA/IDAgOiBuID4gMHhmZiA/IDB4ZmYgOiBuICYgMHhmZl07IH1cblxuZnVuY3Rpb24gcGFja0kxNihuKSB7IHJldHVybiBbKG4gPj4gOCkgJiAweGZmLCBuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja0kxNihieXRlcykgeyByZXR1cm4gYXNfc2lnbmVkKGJ5dGVzWzBdIDw8IDggfCBieXRlc1sxXSwgMTYpOyB9XG5cbmZ1bmN0aW9uIHBhY2tVMTYobikgeyByZXR1cm4gWyhuID4+IDgpICYgMHhmZiwgbiAmIDB4ZmZdOyB9XG5mdW5jdGlvbiB1bnBhY2tVMTYoYnl0ZXMpIHsgcmV0dXJuIGFzX3Vuc2lnbmVkKGJ5dGVzWzBdIDw8IDggfCBieXRlc1sxXSwgMTYpOyB9XG5cbmZ1bmN0aW9uIHBhY2tJMzIobikgeyByZXR1cm4gWyhuID4+IDI0KSAmIDB4ZmYsIChuID4+IDE2KSAmIDB4ZmYsIChuID4+IDgpICYgMHhmZiwgbiAmIDB4ZmZdOyB9XG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHsgcmV0dXJuIGFzX3NpZ25lZChieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCAzMik7IH1cblxuZnVuY3Rpb24gcGFja1UzMihuKSB7IHJldHVybiBbKG4gPj4gMjQpICYgMHhmZiwgKG4gPj4gMTYpICYgMHhmZiwgKG4gPj4gOCkgJiAweGZmLCBuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja1UzMihieXRlcykgeyByZXR1cm4gYXNfdW5zaWduZWQoYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgMzIpOyB9XG5cbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHYsIGViaXRzLCBmYml0cykge1xuXG4gIHZhciBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMSxcbiAgICAgIHMsIGUsIGYsIGxuLFxuICAgICAgaSwgYml0cywgc3RyLCBieXRlcztcblxuICBmdW5jdGlvbiByb3VuZFRvRXZlbihuKSB7XG4gICAgdmFyIHcgPSBmbG9vcihuKSwgZiA9IG4gLSB3O1xuICAgIGlmIChmIDwgMC41KVxuICAgICAgcmV0dXJuIHc7XG4gICAgaWYgKGYgPiAwLjUpXG4gICAgICByZXR1cm4gdyArIDE7XG4gICAgcmV0dXJuIHcgJSAyID8gdyArIDEgOiB3O1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgaWYgKHYgIT09IHYpIHtcbiAgICAvLyBOYU5cbiAgICAvLyBodHRwOi8vZGV2LnczLm9yZy8yMDA2L3dlYmFwaS9XZWJJREwvI2VzLXR5cGUtbWFwcGluZ1xuICAgIGUgPSAoMSA8PCBlYml0cykgLSAxOyBmID0gcG93KDIsIGZiaXRzIC0gMSk7IHMgPSAwO1xuICB9IGVsc2UgaWYgKHYgPT09IEluZmluaXR5IHx8IHYgPT09IC1JbmZpbml0eSkge1xuICAgIGUgPSAoMSA8PCBlYml0cykgLSAxOyBmID0gMDsgcyA9ICh2IDwgMCkgPyAxIDogMDtcbiAgfSBlbHNlIGlmICh2ID09PSAwKSB7XG4gICAgZSA9IDA7IGYgPSAwOyBzID0gKDEgLyB2ID09PSAtSW5maW5pdHkpID8gMSA6IDA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IHYgPCAwO1xuICAgIHYgPSBhYnModik7XG5cbiAgICBpZiAodiA+PSBwb3coMiwgMSAtIGJpYXMpKSB7XG4gICAgICBlID0gbWluKGZsb29yKGxvZyh2KSAvIExOMiksIDEwMjMpO1xuICAgICAgZiA9IHJvdW5kVG9FdmVuKHYgLyBwb3coMiwgZSkgKiBwb3coMiwgZmJpdHMpKTtcbiAgICAgIGlmIChmIC8gcG93KDIsIGZiaXRzKSA+PSAyKSB7XG4gICAgICAgIGUgPSBlICsgMTtcbiAgICAgICAgZiA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoZSA+IGJpYXMpIHtcbiAgICAgICAgLy8gT3ZlcmZsb3dcbiAgICAgICAgZSA9ICgxIDw8IGViaXRzKSAtIDE7XG4gICAgICAgIGYgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsaXplZFxuICAgICAgICBlID0gZSArIGJpYXM7XG4gICAgICAgIGYgPSBmIC0gcG93KDIsIGZiaXRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVub3JtYWxpemVkXG4gICAgICBlID0gMDtcbiAgICAgIGYgPSByb3VuZFRvRXZlbih2IC8gcG93KDIsIDEgLSBiaWFzIC0gZmJpdHMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBQYWNrIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICBiaXRzID0gW107XG4gIGZvciAoaSA9IGZiaXRzOyBpOyBpIC09IDEpIHsgYml0cy5wdXNoKGYgJSAyID8gMSA6IDApOyBmID0gZmxvb3IoZiAvIDIpOyB9XG4gIGZvciAoaSA9IGViaXRzOyBpOyBpIC09IDEpIHsgYml0cy5wdXNoKGUgJSAyID8gMSA6IDApOyBlID0gZmxvb3IoZSAvIDIpOyB9XG4gIGJpdHMucHVzaChzID8gMSA6IDApO1xuICBiaXRzLnJldmVyc2UoKTtcbiAgc3RyID0gYml0cy5qb2luKCcnKTtcblxuICAvLyBCaXRzIHRvIGJ5dGVzXG4gIGJ5dGVzID0gW107XG4gIHdoaWxlIChzdHIubGVuZ3RoKSB7XG4gICAgYnl0ZXMucHVzaChwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIDgpLCAyKSk7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZyg4KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnl0ZXMsIGViaXRzLCBmYml0cykge1xuXG4gIC8vIEJ5dGVzIHRvIGJpdHNcbiAgdmFyIGJpdHMgPSBbXSwgaSwgaiwgYiwgc3RyLFxuICAgICAgYmlhcywgcywgZSwgZjtcblxuICBmb3IgKGkgPSBieXRlcy5sZW5ndGg7IGk7IGkgLT0gMSkge1xuICAgIGIgPSBieXRlc1tpIC0gMV07XG4gICAgZm9yIChqID0gODsgajsgaiAtPSAxKSB7XG4gICAgICBiaXRzLnB1c2goYiAlIDIgPyAxIDogMCk7IGIgPSBiID4+IDE7XG4gICAgfVxuICB9XG4gIGJpdHMucmV2ZXJzZSgpO1xuICBzdHIgPSBiaXRzLmpvaW4oJycpO1xuXG4gIC8vIFVucGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgYmlhcyA9ICgxIDw8IChlYml0cyAtIDEpKSAtIDE7XG4gIHMgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIDEpLCAyKSA/IC0xIDogMTtcbiAgZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMSwgMSArIGViaXRzKSwgMik7XG4gIGYgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDEgKyBlYml0cyksIDIpO1xuXG4gIC8vIFByb2R1Y2UgbnVtYmVyXG4gIGlmIChlID09PSAoMSA8PCBlYml0cykgLSAxKSB7XG4gICAgcmV0dXJuIGYgIT09IDAgPyBOYU4gOiBzICogSW5maW5pdHk7XG4gIH0gZWxzZSBpZiAoZSA+IDApIHtcbiAgICAvLyBOb3JtYWxpemVkXG4gICAgcmV0dXJuIHMgKiBwb3coMiwgZSAtIGJpYXMpICogKDEgKyBmIC8gcG93KDIsIGZiaXRzKSk7XG4gIH0gZWxzZSBpZiAoZiAhPT0gMCkge1xuICAgIC8vIERlbm9ybWFsaXplZFxuICAgIHJldHVybiBzICogcG93KDIsIC0oYmlhcyAtIDEpKSAqIChmIC8gcG93KDIsIGZiaXRzKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHMgPCAwID8gLTAgOiAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucGFja0Y2NChiKSB7IHJldHVybiB1bnBhY2tJRUVFNzU0KGIsIDExLCA1Mik7IH1cbmZ1bmN0aW9uIHBhY2tGNjQodikgeyByZXR1cm4gcGFja0lFRUU3NTQodiwgMTEsIDUyKTsgfVxuZnVuY3Rpb24gdW5wYWNrRjMyKGIpIHsgcmV0dXJuIHVucGFja0lFRUU3NTQoYiwgOCwgMjMpOyB9XG5mdW5jdGlvbiBwYWNrRjMyKHYpIHsgcmV0dXJuIHBhY2tJRUVFNzU0KHYsIDgsIDIzKTsgfVxuXG5cbi8vXG4vLyAzIFRoZSBBcnJheUJ1ZmZlciBUeXBlXG4vL1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICB2YXIgQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBFQ01BU2NyaXB0LlRvSW50MzIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0FycmF5QnVmZmVyIHNpemUgaXMgbm90IGEgc21hbGwgZW5vdWdoIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9ieXRlcyA9IFtdO1xuICAgIHRoaXMuX2J5dGVzLmxlbmd0aCA9IGxlbmd0aDtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmJ5dGVMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdGhpcy5fYnl0ZXNbaV0gPSAwO1xuICAgIH1cblxuICAgIGNvbmZpZ3VyZVByb3BlcnRpZXModGhpcyk7XG4gIH07XG5cbiAgZXhwb3J0cy5BcnJheUJ1ZmZlciA9IGV4cG9ydHMuQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXI7XG5cbiAgLy9cbiAgLy8gNCBUaGUgQXJyYXlCdWZmZXJWaWV3IFR5cGVcbiAgLy9cblxuICAvLyBOT1RFOiB0aGlzIGNvbnN0cnVjdG9yIGlzIG5vdCBleHBvcnRlZFxuICAvKiogQGNvbnN0cnVjdG9yICovXG4gIHZhciBBcnJheUJ1ZmZlclZpZXcgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlclZpZXcoKSB7XG4gICAgLy90aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgLy90aGlzLmJ5dGVPZmZzZXQgPSAwO1xuICAgIC8vdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgfTtcblxuICAvL1xuICAvLyA1IFRoZSBUeXBlZCBBcnJheSBWaWV3IFR5cGVzXG4gIC8vXG5cbiAgZnVuY3Rpb24gbWFrZUNvbnN0cnVjdG9yKGJ5dGVzUGVyRWxlbWVudCwgcGFjaywgdW5wYWNrKSB7XG4gICAgLy8gRWFjaCBUeXBlZEFycmF5IHR5cGUgcmVxdWlyZXMgYSBkaXN0aW5jdCBjb25zdHJ1Y3RvciBpbnN0YW5jZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGxvZ2ljLCB3aGljaCB0aGlzIHByb2R1Y2VzLlxuXG4gICAgdmFyIGN0b3I7XG4gICAgY3RvciA9IGZ1bmN0aW9uKGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgYXJyYXksIHNlcXVlbmNlLCBpLCBzO1xuXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0b3IodW5zaWduZWQgbG9uZyBsZW5ndGgpXG4gICAgICAgIHRoaXMubGVuZ3RoID0gRUNNQVNjcmlwdC5Ub0ludDMyKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXJyYXlCdWZmZXJWaWV3IHNpemUgaXMgbm90IGEgc21hbGwgZW5vdWdoIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmxlbmd0aCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnICYmIGFyZ3VtZW50c1swXS5jb25zdHJ1Y3RvciA9PT0gY3Rvcikge1xuICAgICAgICAvLyBDb25zdHJ1Y3RvcihUeXBlZEFycmF5IGFycmF5KVxuICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5sZW5ndGggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5fc2V0dGVyKGksIGFycmF5Ll9nZXR0ZXIoaSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICEoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgRUNNQVNjcmlwdC5DbGFzcyhhcmd1bWVudHNbMF0pID09PSAnQXJyYXlCdWZmZXInKSkge1xuICAgICAgICAvLyBDb25zdHJ1Y3RvcihzZXF1ZW5jZTx0eXBlPiBhcnJheSlcbiAgICAgICAgc2VxdWVuY2UgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgdGhpcy5sZW5ndGggPSBFQ01BU2NyaXB0LlRvVWludDMyKHNlcXVlbmNlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMubGVuZ3RoICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHMgPSBzZXF1ZW5jZVtpXTtcbiAgICAgICAgICB0aGlzLl9zZXR0ZXIoaSwgTnVtYmVyKHMpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgRUNNQVNjcmlwdC5DbGFzcyhhcmd1bWVudHNbMF0pID09PSAnQXJyYXlCdWZmZXInKSkge1xuICAgICAgICAvLyBDb25zdHJ1Y3RvcihBcnJheUJ1ZmZlciBidWZmZXIsXG4gICAgICAgIC8vICAgICAgICAgICAgIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgYnl0ZU9mZnNldCwgb3B0aW9uYWwgdW5zaWduZWQgbG9uZyBsZW5ndGgpXG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYnl0ZU9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJ5dGVPZmZzZXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJieXRlT2Zmc2V0IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJ5dGVPZmZzZXQgJSB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UKSB7XG4gICAgICAgICAgLy8gVGhlIGdpdmVuIGJ5dGVPZmZzZXQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAgLy8gc2l6ZSBvZiB0aGUgc3BlY2lmaWMgdHlwZSwgb3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiBpcyByYWlzZWQuXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcnJheUJ1ZmZlciBsZW5ndGggbWludXMgdGhlIGJ5dGVPZmZzZXQgaXMgbm90IGEgbXVsdGlwbGUgb2YgdGhlIGVsZW1lbnQgc2l6ZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gdGhpcy5ieXRlT2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKHRoaXMuYnl0ZUxlbmd0aCAlIHRoaXMuQllURVNfUEVSX0VMRU1FTlQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibGVuZ3RoIG9mIGJ1ZmZlciBtaW51cyBieXRlT2Zmc2V0IG5vdCBhIG11bHRpcGxlIG9mIHRoZSBlbGVtZW50IHNpemVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoIC8gdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IEVDTUFTY3JpcHQuVG9VaW50MzIobGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmxlbmd0aCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHRoaXMuYnl0ZU9mZnNldCArIHRoaXMuYnl0ZUxlbmd0aCkgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJieXRlT2Zmc2V0IGFuZCBsZW5ndGggcmVmZXJlbmNlIGFuIGFyZWEgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnQgdHlwZShzKVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGN0b3I7XG5cbiAgICAgIGNvbmZpZ3VyZVByb3BlcnRpZXModGhpcyk7XG4gICAgICBtYWtlQXJyYXlBY2Nlc3NvcnModGhpcyk7XG4gICAgfTtcblxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IEFycmF5QnVmZmVyVmlldygpO1xuICAgIGN0b3IucHJvdG90eXBlLkJZVEVTX1BFUl9FTEVNRU5UID0gYnl0ZXNQZXJFbGVtZW50O1xuICAgIGN0b3IucHJvdG90eXBlLl9wYWNrID0gcGFjaztcbiAgICBjdG9yLnByb3RvdHlwZS5fdW5wYWNrID0gdW5wYWNrO1xuICAgIGN0b3IuQllURVNfUEVSX0VMRU1FTlQgPSBieXRlc1BlckVsZW1lbnQ7XG5cbiAgICAvLyBnZXR0ZXIgdHlwZSAodW5zaWduZWQgbG9uZyBpbmRleCk7XG4gICAgY3Rvci5wcm90b3R5cGUuX2dldHRlciA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIpO1xuXG4gICAgICBpbmRleCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoaW5kZXgpO1xuICAgICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBieXRlcyA9IFtdLCBpLCBvO1xuICAgICAgZm9yIChpID0gMCwgbyA9IHRoaXMuYnl0ZU9mZnNldCArIGluZGV4ICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICAgaSA8IHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgICAgIGkgKz0gMSwgbyArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2godGhpcy5idWZmZXIuX2J5dGVzW29dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl91bnBhY2soYnl0ZXMpO1xuICAgIH07XG5cbiAgICAvLyBOT05TVEFOREFSRDogY29udmVuaWVuY2UgYWxpYXMgZm9yIGdldHRlcjogdHlwZSBnZXQodW5zaWduZWQgbG9uZyBpbmRleCk7XG4gICAgY3Rvci5wcm90b3R5cGUuZ2V0ID0gY3Rvci5wcm90b3R5cGUuX2dldHRlcjtcblxuICAgIC8vIHNldHRlciB2b2lkICh1bnNpZ25lZCBsb25nIGluZGV4LCB0eXBlIHZhbHVlKTtcbiAgICBjdG9yLnByb3RvdHlwZS5fc2V0dGVyID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIpO1xuXG4gICAgICBpbmRleCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoaW5kZXgpO1xuICAgICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBieXRlcyA9IHRoaXMuX3BhY2sodmFsdWUpLCBpLCBvO1xuICAgICAgZm9yIChpID0gMCwgbyA9IHRoaXMuYnl0ZU9mZnNldCArIGluZGV4ICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICAgaSA8IHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgICAgIGkgKz0gMSwgbyArPSAxKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLl9ieXRlc1tvXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB2b2lkIHNldChUeXBlZEFycmF5IGFycmF5LCBvcHRpb25hbCB1bnNpZ25lZCBsb25nIG9mZnNldCk7XG4gICAgLy8gdm9pZCBzZXQoc2VxdWVuY2U8dHlwZT4gYXJyYXksIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgb2Zmc2V0KTtcbiAgICBjdG9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG4gICAgICB2YXIgYXJyYXksIHNlcXVlbmNlLCBvZmZzZXQsIGxlbixcbiAgICAgICAgICBpLCBzLCBkLFxuICAgICAgICAgIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgsIHRtcDtcblxuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnICYmIGFyZ3VtZW50c1swXS5jb25zdHJ1Y3RvciA9PT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAvLyB2b2lkIHNldChUeXBlZEFycmF5IGFycmF5LCBvcHRpb25hbCB1bnNpZ25lZCBsb25nIG9mZnNldCk7XG4gICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBvZmZzZXQgPSBFQ01BU2NyaXB0LlRvVWludDMyKGFyZ3VtZW50c1sxXSk7XG5cbiAgICAgICAgaWYgKG9mZnNldCArIGFycmF5Lmxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPZmZzZXQgcGx1cyBsZW5ndGggb2YgYXJyYXkgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnl0ZU9mZnNldCA9IHRoaXMuYnl0ZU9mZnNldCArIG9mZnNldCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIGJ5dGVMZW5ndGggPSBhcnJheS5sZW5ndGggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG4gICAgICAgIGlmIChhcnJheS5idWZmZXIgPT09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgdG1wID0gW107XG4gICAgICAgICAgZm9yIChpID0gMCwgcyA9IGFycmF5LmJ5dGVPZmZzZXQ7IGkgPCBieXRlTGVuZ3RoOyBpICs9IDEsIHMgKz0gMSkge1xuICAgICAgICAgICAgdG1wW2ldID0gYXJyYXkuYnVmZmVyLl9ieXRlc1tzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpID0gMCwgZCA9IGJ5dGVPZmZzZXQ7IGkgPCBieXRlTGVuZ3RoOyBpICs9IDEsIGQgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuX2J5dGVzW2RdID0gdG1wW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzID0gYXJyYXkuYnl0ZU9mZnNldCwgZCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICBpIDwgYnl0ZUxlbmd0aDsgaSArPSAxLCBzICs9IDEsIGQgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuX2J5dGVzW2RdID0gYXJyYXkuYnVmZmVyLl9ieXRlc1tzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZ3VtZW50c1swXS5sZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHZvaWQgc2V0KHNlcXVlbmNlPHR5cGU+IGFycmF5LCBvcHRpb25hbCB1bnNpZ25lZCBsb25nIG9mZnNldCk7XG4gICAgICAgIHNlcXVlbmNlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBsZW4gPSBFQ01BU2NyaXB0LlRvVWludDMyKHNlcXVlbmNlLmxlbmd0aCk7XG4gICAgICAgIG9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYXJndW1lbnRzWzFdKTtcblxuICAgICAgICBpZiAob2Zmc2V0ICsgbGVuID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk9mZnNldCBwbHVzIGxlbmd0aCBvZiBhcnJheSBpcyBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzID0gc2VxdWVuY2VbaV07XG4gICAgICAgICAgdGhpcy5fc2V0dGVyKG9mZnNldCArIGksIE51bWJlcihzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50IHR5cGUocylcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFR5cGVkQXJyYXkgc3ViYXJyYXkobG9uZyBiZWdpbiwgb3B0aW9uYWwgbG9uZyBlbmQpO1xuICAgIGN0b3IucHJvdG90eXBlLnN1YmFycmF5ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgZnVuY3Rpb24gY2xhbXAodiwgbWluLCBtYXgpIHsgcmV0dXJuIHYgPCBtaW4gPyBtaW4gOiB2ID4gbWF4ID8gbWF4IDogdjsgfVxuXG4gICAgICBzdGFydCA9IEVDTUFTY3JpcHQuVG9JbnQzMihzdGFydCk7XG4gICAgICBlbmQgPSBFQ01BU2NyaXB0LlRvSW50MzIoZW5kKTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7IGVuZCA9IHRoaXMubGVuZ3RoOyB9XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHsgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0OyB9XG4gICAgICBpZiAoZW5kIDwgMCkgeyBlbmQgPSB0aGlzLmxlbmd0aCArIGVuZDsgfVxuXG4gICAgICBzdGFydCA9IGNsYW1wKHN0YXJ0LCAwLCB0aGlzLmxlbmd0aCk7XG4gICAgICBlbmQgPSBjbGFtcChlbmQsIDAsIHRoaXMubGVuZ3RoKTtcblxuICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGxlbiA8IDApIHtcbiAgICAgICAgbGVuID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgICAgICB0aGlzLmJ1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgc3RhcnQgKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5ULCBsZW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gY3RvcjtcbiAgfVxuXG4gIHZhciBJbnQ4QXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoMSwgcGFja0k4LCB1bnBhY2tJOCk7XG4gIHZhciBVaW50OEFycmF5ID0gbWFrZUNvbnN0cnVjdG9yKDEsIHBhY2tVOCwgdW5wYWNrVTgpO1xuICB2YXIgVWludDhDbGFtcGVkQXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoMSwgcGFja1U4Q2xhbXBlZCwgdW5wYWNrVTgpO1xuICB2YXIgSW50MTZBcnJheSA9IG1ha2VDb25zdHJ1Y3RvcigyLCBwYWNrSTE2LCB1bnBhY2tJMTYpO1xuICB2YXIgVWludDE2QXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoMiwgcGFja1UxNiwgdW5wYWNrVTE2KTtcbiAgdmFyIEludDMyQXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoNCwgcGFja0kzMiwgdW5wYWNrSTMyKTtcbiAgdmFyIFVpbnQzMkFycmF5ID0gbWFrZUNvbnN0cnVjdG9yKDQsIHBhY2tVMzIsIHVucGFja1UzMik7XG4gIHZhciBGbG9hdDMyQXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoNCwgcGFja0YzMiwgdW5wYWNrRjMyKTtcbiAgdmFyIEZsb2F0NjRBcnJheSA9IG1ha2VDb25zdHJ1Y3Rvcig4LCBwYWNrRjY0LCB1bnBhY2tGNjQpO1xuXG4gIGV4cG9ydHMuSW50OEFycmF5ID0gZXhwb3J0cy5JbnQ4QXJyYXkgfHwgSW50OEFycmF5O1xuICBleHBvcnRzLlVpbnQ4QXJyYXkgPSBleHBvcnRzLlVpbnQ4QXJyYXkgfHwgVWludDhBcnJheTtcbiAgZXhwb3J0cy5VaW50OENsYW1wZWRBcnJheSA9IGV4cG9ydHMuVWludDhDbGFtcGVkQXJyYXkgfHwgVWludDhDbGFtcGVkQXJyYXk7XG4gIGV4cG9ydHMuSW50MTZBcnJheSA9IGV4cG9ydHMuSW50MTZBcnJheSB8fCBJbnQxNkFycmF5O1xuICBleHBvcnRzLlVpbnQxNkFycmF5ID0gZXhwb3J0cy5VaW50MTZBcnJheSB8fCBVaW50MTZBcnJheTtcbiAgZXhwb3J0cy5JbnQzMkFycmF5ID0gZXhwb3J0cy5JbnQzMkFycmF5IHx8IEludDMyQXJyYXk7XG4gIGV4cG9ydHMuVWludDMyQXJyYXkgPSBleHBvcnRzLlVpbnQzMkFycmF5IHx8IFVpbnQzMkFycmF5O1xuICBleHBvcnRzLkZsb2F0MzJBcnJheSA9IGV4cG9ydHMuRmxvYXQzMkFycmF5IHx8IEZsb2F0MzJBcnJheTtcbiAgZXhwb3J0cy5GbG9hdDY0QXJyYXkgPSBleHBvcnRzLkZsb2F0NjRBcnJheSB8fCBGbG9hdDY0QXJyYXk7XG59KCkpO1xuXG4vL1xuLy8gNiBUaGUgRGF0YVZpZXcgVmlldyBUeXBlXG4vL1xuXG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHIoYXJyYXksIGluZGV4KSB7XG4gICAgcmV0dXJuIEVDTUFTY3JpcHQuSXNDYWxsYWJsZShhcnJheS5nZXQpID8gYXJyYXkuZ2V0KGluZGV4KSA6IGFycmF5W2luZGV4XTtcbiAgfVxuXG4gIHZhciBJU19CSUdfRU5ESUFOID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1MTZhcnJheSA9IG5ldyhleHBvcnRzLlVpbnQxNkFycmF5KShbMHgxMjM0XSksXG4gICAgICAgIHU4YXJyYXkgPSBuZXcoZXhwb3J0cy5VaW50OEFycmF5KSh1MTZhcnJheS5idWZmZXIpO1xuICAgIHJldHVybiByKHU4YXJyYXksIDApID09PSAweDEyO1xuICB9KCkpO1xuXG4gIC8vIENvbnN0cnVjdG9yKEFycmF5QnVmZmVyIGJ1ZmZlcixcbiAgLy8gICAgICAgICAgICAgb3B0aW9uYWwgdW5zaWduZWQgbG9uZyBieXRlT2Zmc2V0LFxuICAvLyAgICAgICAgICAgICBvcHRpb25hbCB1bnNpZ25lZCBsb25nIGJ5dGVMZW5ndGgpXG4gIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgdmFyIERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9IGVsc2UgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgRUNNQVNjcmlwdC5DbGFzcyhidWZmZXIpID09PSAnQXJyYXlCdWZmZXInKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGVFcnJvclwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBuZXcgQXJyYXlCdWZmZXIoMCk7XG5cbiAgICB0aGlzLmJ5dGVPZmZzZXQgPSBFQ01BU2NyaXB0LlRvVWludDMyKGJ5dGVPZmZzZXQpO1xuICAgIGlmICh0aGlzLmJ5dGVPZmZzZXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImJ5dGVPZmZzZXQgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCAtIHRoaXMuYnl0ZU9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMuYnl0ZU9mZnNldCArIHRoaXMuYnl0ZUxlbmd0aCkgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImJ5dGVPZmZzZXQgYW5kIGxlbmd0aCByZWZlcmVuY2UgYW4gYXJlYSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXCIpO1xuICAgIH1cblxuICAgIGNvbmZpZ3VyZVByb3BlcnRpZXModGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUdldHRlcihhcnJheVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG5cbiAgICAgIGJ5dGVPZmZzZXQgPSBFQ01BU2NyaXB0LlRvVWludDMyKGJ5dGVPZmZzZXQpO1xuXG4gICAgICBpZiAoYnl0ZU9mZnNldCArIGFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCA+IHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFycmF5IGluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgIH1cbiAgICAgIGJ5dGVPZmZzZXQgKz0gdGhpcy5ieXRlT2Zmc2V0O1xuXG4gICAgICB2YXIgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCBieXRlT2Zmc2V0LCBhcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQpLFxuICAgICAgICAgIGJ5dGVzID0gW10sIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UOyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaChyKHVpbnQ4QXJyYXksIGkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEJvb2xlYW4obGl0dGxlRW5kaWFuKSA9PT0gQm9vbGVhbihJU19CSUdfRU5ESUFOKSkge1xuICAgICAgICBieXRlcy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByKG5ldyBhcnJheVR5cGUobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlciksIDApO1xuICAgIH07XG4gIH1cblxuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDggPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQ4ID0gbWFrZUdldHRlcihleHBvcnRzLkludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MTYgPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDE2QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MTYgPSBtYWtlR2V0dGVyKGV4cG9ydHMuSW50MTZBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MzIgPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MzIgPSBtYWtlR2V0dGVyKGV4cG9ydHMuSW50MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDMyID0gbWFrZUdldHRlcihleHBvcnRzLkZsb2F0MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDY0ID0gbWFrZUdldHRlcihleHBvcnRzLkZsb2F0NjRBcnJheSk7XG5cbiAgZnVuY3Rpb24gbWFrZVNldHRlcihhcnJheVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuXG4gICAgICBieXRlT2Zmc2V0ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihieXRlT2Zmc2V0KTtcbiAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UID4gdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYnl0ZXNcbiAgICAgIHZhciB0eXBlQXJyYXkgPSBuZXcgYXJyYXlUeXBlKFt2YWx1ZV0pLFxuICAgICAgICAgIGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVBcnJheS5idWZmZXIpLFxuICAgICAgICAgIGJ5dGVzID0gW10sIGksIGJ5dGVWaWV3O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UOyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaChyKGJ5dGVBcnJheSwgaSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBGbGlwIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKEJvb2xlYW4obGl0dGxlRW5kaWFuKSA9PT0gQm9vbGVhbihJU19CSUdfRU5ESUFOKSkge1xuICAgICAgICBieXRlcy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdyaXRlIHRoZW1cbiAgICAgIGJ5dGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsIGJ5dGVPZmZzZXQsIGFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgICBieXRlVmlldy5zZXQoYnl0ZXMpO1xuICAgIH07XG4gIH1cblxuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0VWludDggPSBtYWtlU2V0dGVyKGV4cG9ydHMuVWludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5zZXRJbnQ4ID0gbWFrZVNldHRlcihleHBvcnRzLkludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5zZXRVaW50MTYgPSBtYWtlU2V0dGVyKGV4cG9ydHMuVWludDE2QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0SW50MTYgPSBtYWtlU2V0dGVyKGV4cG9ydHMuSW50MTZBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5zZXRVaW50MzIgPSBtYWtlU2V0dGVyKGV4cG9ydHMuVWludDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0SW50MzIgPSBtYWtlU2V0dGVyKGV4cG9ydHMuSW50MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5zZXRGbG9hdDMyID0gbWFrZVNldHRlcihleHBvcnRzLkZsb2F0MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5zZXRGbG9hdDY0ID0gbWFrZVNldHRlcihleHBvcnRzLkZsb2F0NjRBcnJheSk7XG5cbiAgZXhwb3J0cy5EYXRhVmlldyA9IGV4cG9ydHMuRGF0YVZpZXcgfHwgRGF0YVZpZXc7XG5cbn0oKSk7XG5cbn0se31dfSx7fSxbXSlcbjs7bW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIm5hdGl2ZS1idWZmZXItYnJvd3NlcmlmeVwiKS5CdWZmZXJcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwidmFyIHByb2Nlc3M9cmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpOy8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhY3RpdmVMaW5lID0gXCJsaW5lQGFjdGl2aW5lXCJcblxuZnVuY3Rpb24gb25DdXJzb3JBY3Rpdml0eShlZGl0b3IpIHtcbiAgdmFyIGxpbmUgPSBlZGl0b3IuZ2V0TGluZUhhbmRsZShlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZSlcbiAgdmFyIGFjdGl2ZSA9IGVkaXRvclthY3RpdmVMaW5lXVxuICBpZiAobGluZSAhPSBhY3RpdmUpIHtcbiAgICBlZGl0b3IucmVtb3ZlTGluZUNsYXNzKGFjdGl2ZSwgXCJiYWNrZ3JvdW5kXCIsIFwiYWN0aXZlbGluZVwiKVxuICAgIGVkaXRvclthY3RpdmVMaW5lXSA9IGVkaXRvci5hZGRMaW5lQ2xhc3MobGluZSwgXCJiYWNrZ3JvdW5kXCIsIFwiYWN0aXZlbGluZVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwKGVkaXRvciwgdmFsdWUpIHtcbiAgLyoqXG4gIFRha2VzIGVkaXRvciBhbmQgZW5hYmxlcyBwZXJzaXN0cyBjaGFuZ2VzIHRvIHRoZSBidWZmZXIgYWNyb3NzIHRoZSBzZXNzaW9ucy5cbiAgKiovXG4gIGlmICh2YWx1ZSkge1xuICAgIGVkaXRvclthY3RpdmVMaW5lXSA9IGVkaXRvci5hZGRMaW5lQ2xhc3MoMCwgXCJiYWNrZ3JvdW5kXCIsIFwiYWN0aXZlbGluZVwiKVxuICAgIGVkaXRvci5vbihcImN1cnNvckFjdGl2aXR5XCIsIG9uQ3Vyc29yQWN0aXZpdHkpXG4gICAgb25DdXJzb3JBY3Rpdml0eShlZGl0b3IpXG4gIH0gZWxzZSBpZiAoYWN0aXZlTGluZSBpbiBlZGl0b3IpIHtcbiAgICBlZGl0b3IucmVtb3ZlTGluZUNsYXNzKGVkaXRvclthY3RpdmVMaW5lXSwgXCJiYWNrZ3JvdW5kXCIsIFwiYWN0aXZlbGluZVwiKVxuICAgIGRlbGV0ZSBlZGl0b3JbYWN0aXZlTGluZV1cbiAgICBlZGl0b3Iub2ZmKFwiY3Vyc29yQWN0aXZpdHlcIiwgb25DdXJzb3JBY3Rpdml0eSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwbHVnaW4oQ29kZU1pcnJvcikge1xuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcImFjdGl2ZUxpbmVcIiwgZmFsc2UsIHNldHVwKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdWdpblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIG9uQ2hhbmdlKGVkaXRvcikge1xuICBsb2NhbFN0b3JhZ2Vbd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoXCIjXCIpWzBdXSA9IGVkaXRvci5nZXRWYWx1ZSgpXG59XG5cbmZ1bmN0aW9uIHNldHVwKGVkaXRvciwgdmFsdWUpIHtcbiAgLyoqXG4gIFRha2VzIGVkaXRvciBhbmQgZW5hYmxlcyBwZXJzaXN0cyBjaGFuZ2VzIHRvIHRoZSBidWZmZXIgYWNyb3NzIHRoZSBzZXNzaW9ucy5cbiAgKiovXG4gIGlmICh2YWx1ZSkge1xuICAgIHZhciBhZGRyZXNzID0gd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoXCIjXCIpWzBdXG4gICAgdmFyIHBlcnNpc3RlZCA9IGxvY2FsU3RvcmFnZVthZGRyZXNzXSB8fCBlZGl0b3IuZ2V0VmFsdWUoKVxuICAgIGVkaXRvci5zZXRWYWx1ZShwZXJzaXN0ZWQpXG4gICAgZWRpdG9yLm9uKFwiY2hhbmdlXCIsIG9uQ2hhbmdlKVxuICB9IGVsc2Uge1xuICAgIGVkaXRvci5vZmYoXCJjaGFuZ2VcIiwgb25DaGFuZ2UpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGx1Z2luKENvZGVNaXJyb3IpIHtcbiAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24oXCJwZXJzaXN0XCIsIGZhbHNlLCBzZXR1cClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwbHVnaW5cbiIsIntcbiAgICB2YXIgX25zXyA9IHtcbiAgICAgICAgICAgIGlkOiAnd2lzcC5hbmFseXplcicsXG4gICAgICAgICAgICBkb2M6IHZvaWQgMFxuICAgICAgICB9O1xuICAgIHZhciB3aXNwX2FzdCA9IHJlcXVpcmUoJy4vYXN0Jyk7XG4gICAgdmFyIG1ldGEgPSB3aXNwX2FzdC5tZXRhO1xuICAgIHZhciB3aXRoTWV0YSA9IHdpc3BfYXN0LndpdGhNZXRhO1xuICAgIHZhciBpc1N5bWJvbCA9IHdpc3BfYXN0LmlzU3ltYm9sO1xuICAgIHZhciBpc0tleXdvcmQgPSB3aXNwX2FzdC5pc0tleXdvcmQ7XG4gICAgdmFyIGlzUXVvdGUgPSB3aXNwX2FzdC5pc1F1b3RlO1xuICAgIHZhciBzeW1ib2wgPSB3aXNwX2FzdC5zeW1ib2w7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHdpc3BfYXN0Lm5hbWVzcGFjZTtcbiAgICB2YXIgbmFtZSA9IHdpc3BfYXN0Lm5hbWU7XG4gICAgdmFyIHByU3RyID0gd2lzcF9hc3QucHJTdHI7XG4gICAgdmFyIGlzVW5xdW90ZSA9IHdpc3BfYXN0LmlzVW5xdW90ZTtcbiAgICB2YXIgaXNVbnF1b3RlU3BsaWNpbmcgPSB3aXNwX2FzdC5pc1VucXVvdGVTcGxpY2luZztcbiAgICB2YXIgd2lzcF9zZXF1ZW5jZSA9IHJlcXVpcmUoJy4vc2VxdWVuY2UnKTtcbiAgICB2YXIgaXNMaXN0ID0gd2lzcF9zZXF1ZW5jZS5pc0xpc3Q7XG4gICAgdmFyIGxpc3QgPSB3aXNwX3NlcXVlbmNlLmxpc3Q7XG4gICAgdmFyIGNvbmogPSB3aXNwX3NlcXVlbmNlLmNvbmo7XG4gICAgdmFyIHBhcnRpdGlvbiA9IHdpc3Bfc2VxdWVuY2UucGFydGl0aW9uO1xuICAgIHZhciBzZXEgPSB3aXNwX3NlcXVlbmNlLnNlcTtcbiAgICB2YXIgaXNFbXB0eSA9IHdpc3Bfc2VxdWVuY2UuaXNFbXB0eTtcbiAgICB2YXIgbWFwID0gd2lzcF9zZXF1ZW5jZS5tYXA7XG4gICAgdmFyIHZlYyA9IHdpc3Bfc2VxdWVuY2UudmVjO1xuICAgIHZhciBpc0V2ZXJ5ID0gd2lzcF9zZXF1ZW5jZS5pc0V2ZXJ5O1xuICAgIHZhciBjb25jYXQgPSB3aXNwX3NlcXVlbmNlLmNvbmNhdDtcbiAgICB2YXIgZmlyc3QgPSB3aXNwX3NlcXVlbmNlLmZpcnN0O1xuICAgIHZhciBzZWNvbmQgPSB3aXNwX3NlcXVlbmNlLnNlY29uZDtcbiAgICB2YXIgdGhpcmQgPSB3aXNwX3NlcXVlbmNlLnRoaXJkO1xuICAgIHZhciByZXN0ID0gd2lzcF9zZXF1ZW5jZS5yZXN0O1xuICAgIHZhciBsYXN0ID0gd2lzcF9zZXF1ZW5jZS5sYXN0O1xuICAgIHZhciBidXRsYXN0ID0gd2lzcF9zZXF1ZW5jZS5idXRsYXN0O1xuICAgIHZhciBpbnRlcmxlYXZlID0gd2lzcF9zZXF1ZW5jZS5pbnRlcmxlYXZlO1xuICAgIHZhciBjb25zID0gd2lzcF9zZXF1ZW5jZS5jb25zO1xuICAgIHZhciBjb3VudCA9IHdpc3Bfc2VxdWVuY2UuY291bnQ7XG4gICAgdmFyIHNvbWUgPSB3aXNwX3NlcXVlbmNlLnNvbWU7XG4gICAgdmFyIGFzc29jID0gd2lzcF9zZXF1ZW5jZS5hc3NvYztcbiAgICB2YXIgcmVkdWNlID0gd2lzcF9zZXF1ZW5jZS5yZWR1Y2U7XG4gICAgdmFyIGZpbHRlciA9IHdpc3Bfc2VxdWVuY2UuZmlsdGVyO1xuICAgIHZhciBpc1NlcSA9IHdpc3Bfc2VxdWVuY2UuaXNTZXE7XG4gICAgdmFyIHdpc3BfcnVudGltZSA9IHJlcXVpcmUoJy4vcnVudGltZScpO1xuICAgIHZhciBpc05pbCA9IHdpc3BfcnVudGltZS5pc05pbDtcbiAgICB2YXIgaXNEaWN0aW9uYXJ5ID0gd2lzcF9ydW50aW1lLmlzRGljdGlvbmFyeTtcbiAgICB2YXIgaXNWZWN0b3IgPSB3aXNwX3J1bnRpbWUuaXNWZWN0b3I7XG4gICAgdmFyIGtleXMgPSB3aXNwX3J1bnRpbWUua2V5cztcbiAgICB2YXIgdmFscyA9IHdpc3BfcnVudGltZS52YWxzO1xuICAgIHZhciBpc1N0cmluZyA9IHdpc3BfcnVudGltZS5pc1N0cmluZztcbiAgICB2YXIgaXNOdW1iZXIgPSB3aXNwX3J1bnRpbWUuaXNOdW1iZXI7XG4gICAgdmFyIGlzQm9vbGVhbiA9IHdpc3BfcnVudGltZS5pc0Jvb2xlYW47XG4gICAgdmFyIGlzRGF0ZSA9IHdpc3BfcnVudGltZS5pc0RhdGU7XG4gICAgdmFyIGlzUmVQYXR0ZXJuID0gd2lzcF9ydW50aW1lLmlzUmVQYXR0ZXJuO1xuICAgIHZhciBpc0V2ZW4gPSB3aXNwX3J1bnRpbWUuaXNFdmVuO1xuICAgIHZhciBpc0VxdWFsID0gd2lzcF9ydW50aW1lLmlzRXF1YWw7XG4gICAgdmFyIG1heCA9IHdpc3BfcnVudGltZS5tYXg7XG4gICAgdmFyIGRlYyA9IHdpc3BfcnVudGltZS5kZWM7XG4gICAgdmFyIGRpY3Rpb25hcnkgPSB3aXNwX3J1bnRpbWUuZGljdGlvbmFyeTtcbiAgICB2YXIgc3VicyA9IHdpc3BfcnVudGltZS5zdWJzO1xuICAgIHZhciBpbmMgPSB3aXNwX3J1bnRpbWUuaW5jO1xuICAgIHZhciBkZWMgPSB3aXNwX3J1bnRpbWUuZGVjO1xuICAgIHZhciB3aXNwX2V4cGFuZGVyID0gcmVxdWlyZSgnLi9leHBhbmRlcicpO1xuICAgIHZhciBtYWNyb2V4cGFuZCA9IHdpc3BfZXhwYW5kZXIubWFjcm9leHBhbmQ7XG4gICAgdmFyIHdpc3Bfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbiAgICB2YXIgc3BsaXQgPSB3aXNwX3N0cmluZy5zcGxpdDtcbiAgICB2YXIgam9pbiA9IHdpc3Bfc3RyaW5nLmpvaW47XG59XG52YXIgc3ludGF4RXJyb3IgPSBleHBvcnRzLnN5bnRheEVycm9yID0gZnVuY3Rpb24gc3ludGF4RXJyb3IobWVzc2FnZSwgZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhw7gxID0gbWV0YShmb3JtKTtcbiAgICAgICAgICAgIHZhciBsaW5lw7gxID0gKChtZXRhZGF0YcO4MSB8fCAwKVsnc3RhcnQnXSB8fCAwKVsnbGluZSddO1xuICAgICAgICAgICAgdmFyIHVyacO4MSA9IChtZXRhZGF0YcO4MSB8fCAwKVsndXJpJ107XG4gICAgICAgICAgICB2YXIgY29sdW1uw7gxID0gKChtZXRhZGF0YcO4MSB8fCAwKVsnc3RhcnQnXSB8fCAwKVsnY29sdW1uJ107XG4gICAgICAgICAgICB2YXIgZXJyb3LDuDEgPSBTeW50YXhFcnJvcignJyArIG1lc3NhZ2UgKyAnXFxuJyArICdGb3JtOiAnICsgcHJTdHIoZm9ybSkgKyAnXFxuJyArICdVUkk6ICcgKyB1cmnDuDEgKyAnXFxuJyArICdMaW5lOiAnICsgbGluZcO4MSArICdcXG4nICsgJ0NvbHVtbjogJyArIGNvbHVtbsO4MSk7XG4gICAgICAgICAgICBlcnJvcsO4MS5saW5lTnVtYmVyID0gbGluZcO4MTtcbiAgICAgICAgICAgIGVycm9yw7gxLmxpbmUgPSBsaW5lw7gxO1xuICAgICAgICAgICAgZXJyb3LDuDEuY29sdW1uTnVtYmVyID0gY29sdW1uw7gxO1xuICAgICAgICAgICAgZXJyb3LDuDEuY29sdW1uID0gY29sdW1uw7gxO1xuICAgICAgICAgICAgZXJyb3LDuDEuZmlsZU5hbWUgPSB1cmnDuDE7XG4gICAgICAgICAgICBlcnJvcsO4MS51cmkgPSB1cmnDuDE7XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcsO4MTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGFuYWx5emVLZXl3b3JkID0gZXhwb3J0cy5hbmFseXplS2V5d29yZCA9IGZ1bmN0aW9uIGFuYWx5emVLZXl3b3JkKGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ29wJzogJ2NvbnN0YW50JyxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICB9O1xuICAgIH07XG52YXIgX19zcGVjaWFsc19fID0gZXhwb3J0cy5fX3NwZWNpYWxzX18gPSB7fTtcbnZhciBpbnN0YWxsU3BlY2lhbCA9IGV4cG9ydHMuaW5zdGFsbFNwZWNpYWwgPSBmdW5jdGlvbiBpbnN0YWxsU3BlY2lhbChvcCwgYW5hbHl6ZXIpIHtcbiAgICAgICAgcmV0dXJuIChfX3NwZWNpYWxzX18gfHwgMClbbmFtZShvcCldID0gYW5hbHl6ZXI7XG4gICAgfTtcbnZhciBhbmFseXplU3BlY2lhbCA9IGV4cG9ydHMuYW5hbHl6ZVNwZWNpYWwgPSBmdW5jdGlvbiBhbmFseXplU3BlY2lhbChhbmFseXplciwgZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGHDuDEgPSBtZXRhKGZvcm0pO1xuICAgICAgICAgICAgdmFyIGFzdMO4MSA9IGFuYWx5emVyKGVudiwgZm9ybSk7XG4gICAgICAgICAgICByZXR1cm4gY29uaih7XG4gICAgICAgICAgICAgICAgJ3N0YXJ0JzogKG1ldGFkYXRhw7gxIHx8IDApWydzdGFydCddLFxuICAgICAgICAgICAgICAgICdlbmQnOiAobWV0YWRhdGHDuDEgfHwgMClbJ2VuZCddXG4gICAgICAgICAgICB9LCBhc3TDuDEpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBhbmFseXplSWYgPSBleHBvcnRzLmFuYWx5emVJZiA9IGZ1bmN0aW9uIGFuYWx5emVJZihlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmb3Jtc8O4MSA9IHJlc3QoZm9ybSk7XG4gICAgICAgICAgICB2YXIgdGVzdMO4MSA9IGFuYWx5emUoZW52LCBmaXJzdChmb3Jtc8O4MSkpO1xuICAgICAgICAgICAgdmFyIGNvbnNlcXVlbnTDuDEgPSBhbmFseXplKGVudiwgc2Vjb25kKGZvcm1zw7gxKSk7XG4gICAgICAgICAgICB2YXIgYWx0ZXJuYXRlw7gxID0gYW5hbHl6ZShlbnYsIHRoaXJkKGZvcm1zw7gxKSk7XG4gICAgICAgICAgICBjb3VudChmb3Jtc8O4MSkgPCAyID8gc3ludGF4RXJyb3IoJ01hbGZvcm1lZCBpZiBleHByZXNzaW9uLCB0b28gZmV3IG9wZXJhbmRzJywgZm9ybSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICdpZicsXG4gICAgICAgICAgICAgICAgJ2Zvcm0nOiBmb3JtLFxuICAgICAgICAgICAgICAgICd0ZXN0JzogdGVzdMO4MSxcbiAgICAgICAgICAgICAgICAnY29uc2VxdWVudCc6IGNvbnNlcXVlbnTDuDEsXG4gICAgICAgICAgICAgICAgJ2FsdGVybmF0ZSc6IGFsdGVybmF0ZcO4MVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgnaWYnLCBhbmFseXplSWYpO1xudmFyIGFuYWx5emVUaHJvdyA9IGV4cG9ydHMuYW5hbHl6ZVRocm93ID0gZnVuY3Rpb24gYW5hbHl6ZVRocm93KGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb27DuDEgPSBhbmFseXplKGVudiwgc2Vjb25kKGZvcm0pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ29wJzogJ3Rocm93JyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm0sXG4gICAgICAgICAgICAgICAgJ3Rocm93JzogZXhwcmVzc2lvbsO4MVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgndGhyb3cnLCBhbmFseXplVGhyb3cpO1xudmFyIGFuYWx5emVUcnkgPSBleHBvcnRzLmFuYWx5emVUcnkgPSBmdW5jdGlvbiBhbmFseXplVHJ5KGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZvcm1zw7gxID0gdmVjKHJlc3QoZm9ybSkpO1xuICAgICAgICAgICAgdmFyIHRhaWzDuDEgPSBsYXN0KGZvcm1zw7gxKTtcbiAgICAgICAgICAgIHZhciBmaW5hbGl6ZXJGb3Jtw7gxID0gaXNMaXN0KHRhaWzDuDEpICYmIGlzRXF1YWwoc3ltYm9sKHZvaWQgMCwgJ2ZpbmFsbHknKSwgZmlyc3QodGFpbMO4MSkpID8gcmVzdCh0YWlsw7gxKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBmaW5hbGl6ZXLDuDEgPSBmaW5hbGl6ZXJGb3Jtw7gxID8gYW5hbHl6ZUJsb2NrKGVudiwgZmluYWxpemVyRm9ybcO4MSkgOiB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgYm9keUZvcm3DuDEgPSBmaW5hbGl6ZXLDuDEgPyBidXRsYXN0KGZvcm1zw7gxKSA6IGZvcm1zw7gxO1xuICAgICAgICAgICAgdmFyIHRhaWzDuDIgPSBsYXN0KGJvZHlGb3Jtw7gxKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyRm9ybcO4MSA9IGlzTGlzdCh0YWlsw7gyKSAmJiBpc0VxdWFsKHN5bWJvbCh2b2lkIDAsICdjYXRjaCcpLCBmaXJzdCh0YWlsw7gyKSkgPyByZXN0KHRhaWzDuDIpIDogdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXLDuDEgPSBoYW5kbGVyRm9ybcO4MSA/IGNvbmooeyAnbmFtZSc6IGFuYWx5emUoZW52LCBmaXJzdChoYW5kbGVyRm9ybcO4MSkpIH0sIGFuYWx5emVCbG9jayhlbnYsIHJlc3QoaGFuZGxlckZvcm3DuDEpKSkgOiB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgYm9kecO4MSA9IGhhbmRsZXJGb3Jtw7gxID8gYW5hbHl6ZUJsb2NrKGVudiwgYnV0bGFzdChib2R5Rm9ybcO4MSkpIDogYW5hbHl6ZUJsb2NrKGVudiwgYm9keUZvcm3DuDEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnb3AnOiAndHJ5JyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm0sXG4gICAgICAgICAgICAgICAgJ2JvZHknOiBib2R5w7gxLFxuICAgICAgICAgICAgICAgICdoYW5kbGVyJzogaGFuZGxlcsO4MSxcbiAgICAgICAgICAgICAgICAnZmluYWxpemVyJzogZmluYWxpemVyw7gxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxTcGVjaWFsKCd0cnknLCBhbmFseXplVHJ5KTtcbnZhciBhbmFseXplU2V0ID0gZXhwb3J0cy5hbmFseXplU2V0ID0gZnVuY3Rpb24gYW5hbHl6ZVNldChlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gcmVzdChmb3JtKTtcbiAgICAgICAgICAgIHZhciBsZWZ0w7gxID0gZmlyc3QoYm9kecO4MSk7XG4gICAgICAgICAgICB2YXIgcmlnaHTDuDEgPSBzZWNvbmQoYm9kecO4MSk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0w7gxID0gaXNTeW1ib2wobGVmdMO4MSkgPyBhbmFseXplU3ltYm9sKGVudiwgbGVmdMO4MSkgOiBpc0xpc3QobGVmdMO4MSkgPyBhbmFseXplTGlzdChlbnYsIGxlZnTDuDEpIDogJ2Vsc2UnID8gbGVmdMO4MSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZcO4MSA9IGFuYWx5emUoZW52LCByaWdodMO4MSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICdzZXQhJyxcbiAgICAgICAgICAgICAgICAndGFyZ2V0JzogdGFyZ2V0w7gxLFxuICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlw7gxLFxuICAgICAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgnc2V0IScsIGFuYWx5emVTZXQpO1xudmFyIGFuYWx5emVOZXcgPSBleHBvcnRzLmFuYWx5emVOZXcgPSBmdW5jdGlvbiBhbmFseXplTmV3KGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJvZHnDuDEgPSByZXN0KGZvcm0pO1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yw7gxID0gYW5hbHl6ZShlbnYsIGZpcnN0KGJvZHnDuDEpKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXPDuDEgPSB2ZWMobWFwKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5hbHl6ZShlbnYsICQxKTtcbiAgICAgICAgICAgICAgICB9LCByZXN0KGJvZHnDuDEpKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICduZXcnLFxuICAgICAgICAgICAgICAgICdjb25zdHJ1Y3Rvcic6IGNvbnN0cnVjdG9yw7gxLFxuICAgICAgICAgICAgICAgICdmb3JtJzogZm9ybSxcbiAgICAgICAgICAgICAgICAncGFyYW1zJzogcGFyYW1zw7gxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxTcGVjaWFsKCduZXcnLCBhbmFseXplTmV3KTtcbnZhciBhbmFseXplQWdldCA9IGV4cG9ydHMuYW5hbHl6ZUFnZXQgPSBmdW5jdGlvbiBhbmFseXplQWdldChlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gcmVzdChmb3JtKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXTDuDEgPSBhbmFseXplKGVudiwgZmlyc3QoYm9kecO4MSkpO1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZcO4MSA9IHNlY29uZChib2R5w7gxKTtcbiAgICAgICAgICAgIHZhciBmaWVsZMO4MSA9IGlzUXVvdGUoYXR0cmlidXRlw7gxKSAmJiBpc1N5bWJvbChzZWNvbmQoYXR0cmlidXRlw7gxKSkgJiYgc2Vjb25kKGF0dHJpYnV0ZcO4MSk7XG4gICAgICAgICAgICByZXR1cm4gaXNOaWwoYXR0cmlidXRlw7gxKSA/IHN5bnRheEVycm9yKCdNYWxmb3JtZWQgYWdldCBleHByZXNzaW9uIGV4cGVjdGVkIChhZ2V0IG9iamVjdCBtZW1iZXIpJywgZm9ybSkgOiB7XG4gICAgICAgICAgICAgICAgJ29wJzogJ21lbWJlci1leHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAnY29tcHV0ZWQnOiAhZmllbGTDuDEsXG4gICAgICAgICAgICAgICAgJ2Zvcm0nOiBmb3JtLFxuICAgICAgICAgICAgICAgICd0YXJnZXQnOiB0YXJnZXTDuDEsXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnR5JzogZmllbGTDuDEgPyBjb25qKGFuYWx5emVTcGVjaWFsKGFuYWx5emVJZGVudGlmaWVyLCBlbnYsIGZpZWxkw7gxKSwgeyAnYmluZGluZyc6IHZvaWQgMCB9KSA6IGFuYWx5emUoZW52LCBhdHRyaWJ1dGXDuDEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxTcGVjaWFsKCdhZ2V0JywgYW5hbHl6ZUFnZXQpO1xudmFyIHBhcnNlRGVmID0gZXhwb3J0cy5wYXJzZURlZiA9IGZ1bmN0aW9uIHBhcnNlRGVmKCkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdmFyIGlkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHsgJ2lkJzogaWQgfTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIGlkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdpbml0JzogaW5pdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdmFyIGlkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGRvYyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBpbml0ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnZG9jJzogZG9jLFxuICAgICAgICAgICAgICAgICdpbml0JzogaW5pdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICB9O1xudmFyIGFuYWx5emVEZWYgPSBleHBvcnRzLmFuYWx5emVEZWYgPSBmdW5jdGlvbiBhbmFseXplRGVmKGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtc8O4MSA9IHBhcnNlRGVmLmFwcGx5KHZvaWQgMCwgdmVjKHJlc3QoZm9ybSkpKTtcbiAgICAgICAgICAgIHZhciBpZMO4MSA9IChwYXJhbXPDuDEgfHwgMClbJ2lkJ107XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGHDuDEgPSBtZXRhKGlkw7gxKTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nw7gxID0gYW5hbHl6ZVNwZWNpYWwoYW5hbHl6ZURlY2xhcmF0aW9uLCBlbnYsIGlkw7gxKTtcbiAgICAgICAgICAgIHZhciBpbml0w7gxID0gYW5hbHl6ZShlbnYsIChwYXJhbXPDuDEgfHwgMClbJ2luaXQnXSk7XG4gICAgICAgICAgICB2YXIgZG9jw7gxID0gKHBhcmFtc8O4MSB8fCAwKVsnZG9jJ10gfHwgKG1ldGFkYXRhw7gxIHx8IDApWydkb2MnXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ29wJzogJ2RlZicsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IGRvY8O4MSxcbiAgICAgICAgICAgICAgICAnaWQnOiBiaW5kaW5nw7gxLFxuICAgICAgICAgICAgICAgICdpbml0JzogaW5pdMO4MSxcbiAgICAgICAgICAgICAgICAnZXhwb3J0JzogKGVudiB8fCAwKVsndG9wJ10gJiYgIShtZXRhZGF0YcO4MSB8fCAwKVsncHJpdmF0ZSddLFxuICAgICAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgnZGVmJywgYW5hbHl6ZURlZik7XG52YXIgYW5hbHl6ZURvID0gZXhwb3J0cy5hbmFseXplRG8gPSBmdW5jdGlvbiBhbmFseXplRG8oZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnPDuDEgPSByZXN0KGZvcm0pO1xuICAgICAgICAgICAgdmFyIGJvZHnDuDEgPSBhbmFseXplQmxvY2soZW52LCBleHByZXNzaW9uc8O4MSk7XG4gICAgICAgICAgICByZXR1cm4gY29uaihib2R5w7gxLCB7XG4gICAgICAgICAgICAgICAgJ29wJzogJ2RvJyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxTcGVjaWFsKCdkbycsIGFuYWx5emVEbyk7XG52YXIgYW5hbHl6ZVN5bWJvbCA9IGV4cG9ydHMuYW5hbHl6ZVN5bWJvbCA9IGZ1bmN0aW9uIGFuYWx5emVTeW1ib2woZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm9ybXPDuDEgPSBzcGxpdChuYW1lKGZvcm0pLCAnLicpO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhw7gxID0gbWV0YShmb3JtKTtcbiAgICAgICAgICAgIHZhciBzdGFydMO4MSA9IChtZXRhZGF0YcO4MSB8fCAwKVsnc3RhcnQnXTtcbiAgICAgICAgICAgIHZhciBlbmTDuDEgPSAobWV0YWRhdGHDuDEgfHwgMClbJ2VuZCddO1xuICAgICAgICAgICAgdmFyIGV4cGFuc2lvbsO4MSA9IGNvdW50KGZvcm1zw7gxKSA+IDEgPyBsaXN0KHN5bWJvbCh2b2lkIDAsICdhZ2V0JyksIHdpdGhNZXRhKHN5bWJvbChmaXJzdChmb3Jtc8O4MSkpLCBjb25qKG1ldGFkYXRhw7gxLCB7XG4gICAgICAgICAgICAgICAgICAgICdzdGFydCc6IHN0YXJ0w7gxLFxuICAgICAgICAgICAgICAgICAgICAnZW5kJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUnOiAoZW5kw7gxIHx8IDApWydsaW5lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sdW1uJzogMSArIChzdGFydMO4MSB8fCAwKVsnY29sdW1uJ10gKyBjb3VudChmaXJzdChmb3Jtc8O4MSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSksIGxpc3Qoc3ltYm9sKHZvaWQgMCwgJ3F1b3RlJyksIHdpdGhNZXRhKHN5bWJvbChqb2luKCcuJywgcmVzdChmb3Jtc8O4MSkpKSwgY29uaihtZXRhZGF0YcO4MSwge1xuICAgICAgICAgICAgICAgICAgICAnZW5kJzogZW5kw7gxLFxuICAgICAgICAgICAgICAgICAgICAnc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbGluZSc6IChzdGFydMO4MSB8fCAwKVsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbic6IDEgKyAoc3RhcnTDuDEgfHwgMClbJ2NvbHVtbiddICsgY291bnQoZmlyc3QoZm9ybXPDuDEpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpKSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5zaW9uw7gxID8gYW5hbHl6ZShlbnYsIHdpdGhNZXRhKGV4cGFuc2lvbsO4MSwgbWV0YShmb3JtKSkpIDogYW5hbHl6ZVNwZWNpYWwoYW5hbHl6ZUlkZW50aWZpZXIsIGVudiwgZm9ybSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGFuYWx5emVJZGVudGlmaWVyID0gZXhwb3J0cy5hbmFseXplSWRlbnRpZmllciA9IGZ1bmN0aW9uIGFuYWx5emVJZGVudGlmaWVyKGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ29wJzogJ3ZhcicsXG4gICAgICAgICAgICAndHlwZSc6ICdpZGVudGlmaWVyJyxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybSxcbiAgICAgICAgICAgICdzdGFydCc6IChtZXRhKGZvcm0pIHx8IDApWydzdGFydCddLFxuICAgICAgICAgICAgJ2VuZCc6IChtZXRhKGZvcm0pIHx8IDApWydlbmQnXSxcbiAgICAgICAgICAgICdiaW5kaW5nJzogcmVzb2x2ZUJpbmRpbmcoZW52LCBmb3JtKVxuICAgICAgICB9O1xuICAgIH07XG52YXIgdW5yZXNvbHZlZEJpbmRpbmcgPSBleHBvcnRzLnVucmVzb2x2ZWRCaW5kaW5nID0gZnVuY3Rpb24gdW5yZXNvbHZlZEJpbmRpbmcoZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnb3AnOiAndW5yZXNvbHZlZC1iaW5kaW5nJyxcbiAgICAgICAgICAgICd0eXBlJzogJ3VucmVzb2x2ZWQtYmluZGluZycsXG4gICAgICAgICAgICAnaWRlbnRpZmllcic6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdpZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IHN5bWJvbChuYW1lc3BhY2UoZm9ybSksIG5hbWUoZm9ybSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3N0YXJ0JzogKG1ldGEoZm9ybSkgfHwgMClbJ3N0YXJ0J10sXG4gICAgICAgICAgICAnZW5kJzogKG1ldGEoZm9ybSkgfHwgMClbJ2VuZCddXG4gICAgICAgIH07XG4gICAgfTtcbnZhciByZXNvbHZlQmluZGluZyA9IGV4cG9ydHMucmVzb2x2ZUJpbmRpbmcgPSBmdW5jdGlvbiByZXNvbHZlQmluZGluZyhlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuICgoZW52IHx8IDApWydsb2NhbHMnXSB8fCAwKVtuYW1lKGZvcm0pXSB8fCAoKGVudiB8fCAwKVsnZW5jbG9zZWQnXSB8fCAwKVtuYW1lKGZvcm0pXSB8fCB1bnJlc29sdmVkQmluZGluZyhlbnYsIGZvcm0pO1xuICAgIH07XG52YXIgYW5hbHl6ZVNoYWRvdyA9IGV4cG9ydHMuYW5hbHl6ZVNoYWRvdyA9IGZ1bmN0aW9uIGFuYWx5emVTaGFkb3coZW52LCBpZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmfDuDEgPSByZXNvbHZlQmluZGluZyhlbnYsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2RlcHRoJzogaW5jKChiaW5kaW5nw7gxIHx8IDApWydkZXB0aCddIHx8IDApLFxuICAgICAgICAgICAgICAgICdzaGFkb3cnOiBiaW5kaW5nw7gxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBhbmFseXplQmluZGluZyA9IGV4cG9ydHMuYW5hbHl6ZUJpbmRpbmcgPSBmdW5jdGlvbiBhbmFseXplQmluZGluZyhlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZMO4MSA9IGZpcnN0KGZvcm0pO1xuICAgICAgICAgICAgdmFyIGJvZHnDuDEgPSBzZWNvbmQoZm9ybSk7XG4gICAgICAgICAgICByZXR1cm4gY29uaihhbmFseXplU2hhZG93KGVudiwgaWTDuDEpLCB7XG4gICAgICAgICAgICAgICAgJ29wJzogJ2JpbmRpbmcnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2JpbmRpbmcnLFxuICAgICAgICAgICAgICAgICdpZCc6IGlkw7gxLFxuICAgICAgICAgICAgICAgICdpbml0JzogYW5hbHl6ZShlbnYsIGJvZHnDuDEpLFxuICAgICAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGFuYWx5emVEZWNsYXJhdGlvbiA9IGV4cG9ydHMuYW5hbHl6ZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gYW5hbHl6ZURlY2xhcmF0aW9uKGVudiwgZm9ybSkge1xuICAgICAgICAhIShuYW1lc3BhY2UoZm9ybSkgfHwgMSA8IGNvdW50KHNwbGl0KCcuJywgJycgKyBmb3JtKSkpID8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCcnICsgJ0Fzc2VydCBmYWlsZWQ6ICcgKyAnJyArICcobm90IChvciAobmFtZXNwYWNlIGZvcm0pICg8IDEgKGNvdW50IChzcGxpdCBcIi5cIiAoc3RyIGZvcm0pKSkpKSknKTtcbiAgICAgICAgfSkoKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGNvbmooYW5hbHl6ZVNoYWRvdyhlbnYsIGZvcm0pLCB7XG4gICAgICAgICAgICAnb3AnOiAndmFyJyxcbiAgICAgICAgICAgICd0eXBlJzogJ2lkZW50aWZpZXInLFxuICAgICAgICAgICAgJ2RlcHRoJzogMCxcbiAgICAgICAgICAgICdpZCc6IGZvcm0sXG4gICAgICAgICAgICAnZm9ybSc6IGZvcm1cbiAgICAgICAgfSk7XG4gICAgfTtcbnZhciBhbmFseXplUGFyYW0gPSBleHBvcnRzLmFuYWx5emVQYXJhbSA9IGZ1bmN0aW9uIGFuYWx5emVQYXJhbShlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGNvbmooYW5hbHl6ZVNoYWRvdyhlbnYsIGZvcm0pLCB7XG4gICAgICAgICAgICAnb3AnOiAncGFyYW0nLFxuICAgICAgICAgICAgJ3R5cGUnOiAncGFyYW1ldGVyJyxcbiAgICAgICAgICAgICdpZCc6IGZvcm0sXG4gICAgICAgICAgICAnZm9ybSc6IGZvcm0sXG4gICAgICAgICAgICAnc3RhcnQnOiAobWV0YShmb3JtKSB8fCAwKVsnc3RhcnQnXSxcbiAgICAgICAgICAgICdlbmQnOiAobWV0YShmb3JtKSB8fCAwKVsnZW5kJ11cbiAgICAgICAgfSk7XG4gICAgfTtcbnZhciB3aXRoQmluZGluZyA9IGV4cG9ydHMud2l0aEJpbmRpbmcgPSBmdW5jdGlvbiB3aXRoQmluZGluZyhlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGNvbmooZW52LCB7XG4gICAgICAgICAgICAnbG9jYWxzJzogYXNzb2MoKGVudiB8fCAwKVsnbG9jYWxzJ10sIG5hbWUoKGZvcm0gfHwgMClbJ2lkJ10pLCBmb3JtKSxcbiAgICAgICAgICAgICdiaW5kaW5ncyc6IGNvbmooKGVudiB8fCAwKVsnYmluZGluZ3MnXSwgZm9ybSlcbiAgICAgICAgfSk7XG4gICAgfTtcbnZhciB3aXRoUGFyYW0gPSBleHBvcnRzLndpdGhQYXJhbSA9IGZ1bmN0aW9uIHdpdGhQYXJhbShlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGNvbmood2l0aEJpbmRpbmcoZW52LCBmb3JtKSwgeyAncGFyYW1zJzogY29uaigoZW52IHx8IDApWydwYXJhbXMnXSwgZm9ybSkgfSk7XG4gICAgfTtcbnZhciBzdWJFbnYgPSBleHBvcnRzLnN1YkVudiA9IGZ1bmN0aW9uIHN1YkVudihlbnYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdlbmNsb3NlZCc6IGNvbmooe30sIChlbnYgfHwgMClbJ2VuY2xvc2VkJ10sIChlbnYgfHwgMClbJ2xvY2FscyddKSxcbiAgICAgICAgICAgICdsb2NhbHMnOiB7fSxcbiAgICAgICAgICAgICdiaW5kaW5ncyc6IFtdLFxuICAgICAgICAgICAgJ3BhcmFtcyc6IChlbnYgfHwgMClbJ3BhcmFtcyddIHx8IFtdXG4gICAgICAgIH07XG4gICAgfTtcbnZhciBhbmFseXplTGV0XyA9IGV4cG9ydHMuYW5hbHl6ZUxldF8gPSBmdW5jdGlvbiBhbmFseXplTGV0XyhlbnYsIGZvcm0sIGlzTG9vcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zw7gxID0gcmVzdChmb3JtKTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nc8O4MSA9IGZpcnN0KGV4cHJlc3Npb25zw7gxKTtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gcmVzdChleHByZXNzaW9uc8O4MSk7XG4gICAgICAgICAgICB2YXIgaXNWYWxpZEJpbmRpbmdzw7gxID0gaXNWZWN0b3IoYmluZGluZ3PDuDEpICYmIGlzRXZlbihjb3VudChiaW5kaW5nc8O4MSkpO1xuICAgICAgICAgICAgdmFyIF/DuDEgPSAhaXNWYWxpZEJpbmRpbmdzw7gxID8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJycgKyAnQXNzZXJ0IGZhaWxlZDogJyArICdiaW5kaW5ncyBtdXN0IGJlIHZlY3RvciBvZiBldmVuIG51bWJlciBvZiBlbGVtZW50cycgKyAndmFsaWQtYmluZGluZ3M/Jyk7XG4gICAgICAgICAgICAgICAgfSkoKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBzY29wZcO4MSA9IHJlZHVjZShmdW5jdGlvbiAoJDEsICQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aXRoQmluZGluZygkMSwgYW5hbHl6ZUJpbmRpbmcoJDEsICQyKSk7XG4gICAgICAgICAgICAgICAgfSwgc3ViRW52KGVudiksIHBhcnRpdGlvbigyLCBiaW5kaW5nc8O4MSkpO1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzw7gyID0gKHNjb3Blw7gxIHx8IDApWydiaW5kaW5ncyddO1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zw7gyID0gYW5hbHl6ZUJsb2NrKGlzTG9vcCA/IGNvbmooc2NvcGXDuDEsIHsgJ3BhcmFtcyc6IGJpbmRpbmdzw7gyIH0pIDogc2NvcGXDuDEsIGJvZHnDuDEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnb3AnOiAnbGV0JyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm0sXG4gICAgICAgICAgICAgICAgJ3N0YXJ0JzogKG1ldGEoZm9ybSkgfHwgMClbJ3N0YXJ0J10sXG4gICAgICAgICAgICAgICAgJ2VuZCc6IChtZXRhKGZvcm0pIHx8IDApWydlbmQnXSxcbiAgICAgICAgICAgICAgICAnYmluZGluZ3MnOiBiaW5kaW5nc8O4MixcbiAgICAgICAgICAgICAgICAnc3RhdGVtZW50cyc6IChleHByZXNzaW9uc8O4MiB8fCAwKVsnc3RhdGVtZW50cyddLFxuICAgICAgICAgICAgICAgICdyZXN1bHQnOiAoZXhwcmVzc2lvbnPDuDIgfHwgMClbJ3Jlc3VsdCddXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBhbmFseXplTGV0ID0gZXhwb3J0cy5hbmFseXplTGV0ID0gZnVuY3Rpb24gYW5hbHl6ZUxldChlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGFuYWx5emVMZXRfKGVudiwgZm9ybSwgZmFsc2UpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgnbGV0JywgYW5hbHl6ZUxldCk7XG52YXIgYW5hbHl6ZUxvb3AgPSBleHBvcnRzLmFuYWx5emVMb29wID0gZnVuY3Rpb24gYW5hbHl6ZUxvb3AoZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBjb25qKGFuYWx5emVMZXRfKGVudiwgZm9ybSwgdHJ1ZSksIHsgJ29wJzogJ2xvb3AnIH0pO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgnbG9vcCcsIGFuYWx5emVMb29wKTtcbnZhciBhbmFseXplUmVjdXIgPSBleHBvcnRzLmFuYWx5emVSZWN1ciA9IGZ1bmN0aW9uIGFuYWx5emVSZWN1cihlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXPDuDEgPSAoZW52IHx8IDApWydwYXJhbXMnXTtcbiAgICAgICAgICAgIHZhciBmb3Jtc8O4MSA9IHZlYyhtYXAoZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmFseXplKGVudiwgJDEpO1xuICAgICAgICAgICAgICAgIH0sIHJlc3QoZm9ybSkpKTtcbiAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKGNvdW50KHBhcmFtc8O4MSksIGNvdW50KGZvcm1zw7gxKSkgPyB7XG4gICAgICAgICAgICAgICAgJ29wJzogJ3JlY3VyJyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm0sXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IGZvcm1zw7gxXG4gICAgICAgICAgICB9IDogc3ludGF4RXJyb3IoJ1JlY3VycyB3aXRoIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMnLCBmb3JtKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgncmVjdXInLCBhbmFseXplUmVjdXIpO1xudmFyIGFuYWx5emVRdW90ZWRMaXN0ID0gZXhwb3J0cy5hbmFseXplUXVvdGVkTGlzdCA9IGZ1bmN0aW9uIGFuYWx5emVRdW90ZWRMaXN0KGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdvcCc6ICdsaXN0JyxcbiAgICAgICAgICAgICdpdGVtcyc6IG1hcChhbmFseXplUXVvdGVkLCB2ZWMoZm9ybSkpLFxuICAgICAgICAgICAgJ2Zvcm0nOiBmb3JtLFxuICAgICAgICAgICAgJ3N0YXJ0JzogKG1ldGEoZm9ybSkgfHwgMClbJ3N0YXJ0J10sXG4gICAgICAgICAgICAnZW5kJzogKG1ldGEoZm9ybSkgfHwgMClbJ2VuZCddXG4gICAgICAgIH07XG4gICAgfTtcbnZhciBhbmFseXplUXVvdGVkVmVjdG9yID0gZXhwb3J0cy5hbmFseXplUXVvdGVkVmVjdG9yID0gZnVuY3Rpb24gYW5hbHl6ZVF1b3RlZFZlY3Rvcihmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnb3AnOiAndmVjdG9yJyxcbiAgICAgICAgICAgICdpdGVtcyc6IG1hcChhbmFseXplUXVvdGVkLCBmb3JtKSxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybSxcbiAgICAgICAgICAgICdzdGFydCc6IChtZXRhKGZvcm0pIHx8IDApWydzdGFydCddLFxuICAgICAgICAgICAgJ2VuZCc6IChtZXRhKGZvcm0pIHx8IDApWydlbmQnXVxuICAgICAgICB9O1xuICAgIH07XG52YXIgYW5hbHl6ZVF1b3RlZERpY3Rpb25hcnkgPSBleHBvcnRzLmFuYWx5emVRdW90ZWREaWN0aW9uYXJ5ID0gZnVuY3Rpb24gYW5hbHl6ZVF1b3RlZERpY3Rpb25hcnkoZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5hbWVzw7gxID0gdmVjKG1hcChhbmFseXplUXVvdGVkLCBrZXlzKGZvcm0pKSk7XG4gICAgICAgICAgICB2YXIgdmFsdWVzw7gxID0gdmVjKG1hcChhbmFseXplUXVvdGVkLCB2YWxzKGZvcm0pKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICdkaWN0aW9uYXJ5JyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm0sXG4gICAgICAgICAgICAgICAgJ2tleXMnOiBuYW1lc8O4MSxcbiAgICAgICAgICAgICAgICAndmFsdWVzJzogdmFsdWVzw7gxLFxuICAgICAgICAgICAgICAgICdzdGFydCc6IChtZXRhKGZvcm0pIHx8IDApWydzdGFydCddLFxuICAgICAgICAgICAgICAgICdlbmQnOiAobWV0YShmb3JtKSB8fCAwKVsnZW5kJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGFuYWx5emVRdW90ZWRTeW1ib2wgPSBleHBvcnRzLmFuYWx5emVRdW90ZWRTeW1ib2wgPSBmdW5jdGlvbiBhbmFseXplUXVvdGVkU3ltYm9sKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdvcCc6ICdzeW1ib2wnLFxuICAgICAgICAgICAgJ25hbWUnOiBuYW1lKGZvcm0pLFxuICAgICAgICAgICAgJ25hbWVzcGFjZSc6IG5hbWVzcGFjZShmb3JtKSxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICB9O1xuICAgIH07XG52YXIgYW5hbHl6ZVF1b3RlZEtleXdvcmQgPSBleHBvcnRzLmFuYWx5emVRdW90ZWRLZXl3b3JkID0gZnVuY3Rpb24gYW5hbHl6ZVF1b3RlZEtleXdvcmQoZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ29wJzogJ2tleXdvcmQnLFxuICAgICAgICAgICAgJ25hbWUnOiBuYW1lKGZvcm0pLFxuICAgICAgICAgICAgJ25hbWVzcGFjZSc6IG5hbWVzcGFjZShmb3JtKSxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICB9O1xuICAgIH07XG52YXIgYW5hbHl6ZVF1b3RlZCA9IGV4cG9ydHMuYW5hbHl6ZVF1b3RlZCA9IGZ1bmN0aW9uIGFuYWx5emVRdW90ZWQoZm9ybSkge1xuICAgICAgICByZXR1cm4gaXNTeW1ib2woZm9ybSkgPyBhbmFseXplUXVvdGVkU3ltYm9sKGZvcm0pIDogaXNLZXl3b3JkKGZvcm0pID8gYW5hbHl6ZVF1b3RlZEtleXdvcmQoZm9ybSkgOiBpc0xpc3QoZm9ybSkgPyBhbmFseXplUXVvdGVkTGlzdChmb3JtKSA6IGlzVmVjdG9yKGZvcm0pID8gYW5hbHl6ZVF1b3RlZFZlY3Rvcihmb3JtKSA6IGlzRGljdGlvbmFyeShmb3JtKSA/IGFuYWx5emVRdW90ZWREaWN0aW9uYXJ5KGZvcm0pIDogJ2Vsc2UnID8ge1xuICAgICAgICAgICAgJ29wJzogJ2NvbnN0YW50JyxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICB9IDogdm9pZCAwO1xuICAgIH07XG52YXIgYW5hbHl6ZVF1b3RlID0gZXhwb3J0cy5hbmFseXplUXVvdGUgPSBmdW5jdGlvbiBhbmFseXplUXVvdGUoZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBhbmFseXplUXVvdGVkKHNlY29uZChmb3JtKSk7XG4gICAgfTtcbmluc3RhbGxTcGVjaWFsKCdxdW90ZScsIGFuYWx5emVRdW90ZSk7XG52YXIgYW5hbHl6ZVN0YXRlbWVudCA9IGV4cG9ydHMuYW5hbHl6ZVN0YXRlbWVudCA9IGZ1bmN0aW9uIGFuYWx5emVTdGF0ZW1lbnQoZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50c8O4MSA9IChlbnYgfHwgMClbJ3N0YXRlbWVudHMnXSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nc8O4MSA9IChlbnYgfHwgMClbJ2JpbmRpbmdzJ10gfHwgW107XG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50w7gxID0gYW5hbHl6ZShlbnYsIGZvcm0pO1xuICAgICAgICAgICAgdmFyIG9ww7gxID0gKHN0YXRlbWVudMO4MSB8fCAwKVsnb3AnXTtcbiAgICAgICAgICAgIHZhciBkZWZzw7gxID0gaXNFcXVhbChvcMO4MSwgJ2RlZicpID8gWyhzdGF0ZW1lbnTDuDEgfHwgMClbJ3ZhciddXSA6ICdlbHNlJyA/IHZvaWQgMCA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBjb25qKGVudiwge1xuICAgICAgICAgICAgICAgICdzdGF0ZW1lbnRzJzogY29uaihzdGF0ZW1lbnRzw7gxLCBzdGF0ZW1lbnTDuDEpLFxuICAgICAgICAgICAgICAgICdiaW5kaW5ncyc6IGNvbmNhdChiaW5kaW5nc8O4MSwgZGVmc8O4MSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBhbmFseXplQmxvY2sgPSBleHBvcnRzLmFuYWx5emVCbG9jayA9IGZ1bmN0aW9uIGFuYWx5emVCbG9jayhlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gY291bnQoZm9ybSkgPiAxID8gcmVkdWNlKGFuYWx5emVTdGF0ZW1lbnQsIGVudiwgYnV0bGFzdChmb3JtKSkgOiB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgcmVzdWx0w7gxID0gYW5hbHl6ZShib2R5w7gxIHx8IGVudiwgbGFzdChmb3JtKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdzdGF0ZW1lbnRzJzogKGJvZHnDuDEgfHwgMClbJ3N0YXRlbWVudHMnXSxcbiAgICAgICAgICAgICAgICAncmVzdWx0JzogcmVzdWx0w7gxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBhbmFseXplRm5NZXRob2QgPSBleHBvcnRzLmFuYWx5emVGbk1ldGhvZCA9IGZ1bmN0aW9uIGFuYWx5emVGbk1ldGhvZChlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmXDuDEgPSBpc0xpc3QoZm9ybSkgJiYgaXNWZWN0b3IoZmlyc3QoZm9ybSkpID8gZmlyc3QoZm9ybSkgOiBzeW50YXhFcnJvcignTWFsZm9ybWVkIGZuIG92ZXJsb2FkIGZvcm0nLCBmb3JtKTtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gcmVzdChmb3JtKTtcbiAgICAgICAgICAgIHZhciB2YXJpYWRpY8O4MSA9IHNvbWUoZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKHN5bWJvbCh2b2lkIDAsICcmJyksICQxKTtcbiAgICAgICAgICAgICAgICB9LCBzaWduYXR1cmXDuDEpO1xuICAgICAgICAgICAgdmFyIHBhcmFtc8O4MSA9IHZhcmlhZGljw7gxID8gZmlsdGVyKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzRXF1YWwoc3ltYm9sKHZvaWQgMCwgJyYnKSwgJDEpO1xuICAgICAgICAgICAgICAgIH0sIHNpZ25hdHVyZcO4MSkgOiBzaWduYXR1cmXDuDE7XG4gICAgICAgICAgICB2YXIgYXJpdHnDuDEgPSB2YXJpYWRpY8O4MSA/IGRlYyhjb3VudChwYXJhbXPDuDEpKSA6IGNvdW50KHBhcmFtc8O4MSk7XG4gICAgICAgICAgICB2YXIgc2NvcGXDuDEgPSByZWR1Y2UoZnVuY3Rpb24gKCQxLCAkMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2l0aFBhcmFtKCQxLCBhbmFseXplUGFyYW0oJDEsICQyKSk7XG4gICAgICAgICAgICAgICAgfSwgY29uaihlbnYsIHsgJ3BhcmFtcyc6IFtdIH0pLCBwYXJhbXPDuDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmooYW5hbHl6ZUJsb2NrKHNjb3Blw7gxLCBib2R5w7gxKSwge1xuICAgICAgICAgICAgICAgICdvcCc6ICdvdmVybG9hZCcsXG4gICAgICAgICAgICAgICAgJ3ZhcmlhZGljJzogdmFyaWFkaWPDuDEsXG4gICAgICAgICAgICAgICAgJ2FyaXR5JzogYXJpdHnDuDEsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IChzY29wZcO4MSB8fCAwKVsncGFyYW1zJ10sXG4gICAgICAgICAgICAgICAgJ2Zvcm0nOiBmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgYW5hbHl6ZUZuID0gZXhwb3J0cy5hbmFseXplRm4gPSBmdW5jdGlvbiBhbmFseXplRm4oZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm9ybXPDuDEgPSByZXN0KGZvcm0pO1xuICAgICAgICAgICAgdmFyIGZvcm1zw7gyID0gaXNTeW1ib2woZmlyc3QoZm9ybXPDuDEpKSA/IGZvcm1zw7gxIDogY29ucyh2b2lkIDAsIGZvcm1zw7gxKTtcbiAgICAgICAgICAgIHZhciBpZMO4MSA9IGZpcnN0KGZvcm1zw7gyKTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nw7gxID0gaWTDuDEgPyBhbmFseXplU3BlY2lhbChhbmFseXplRGVjbGFyYXRpb24sIGVudiwgaWTDuDEpIDogdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGJvZHnDuDEgPSByZXN0KGZvcm1zw7gyKTtcbiAgICAgICAgICAgIHZhciBvdmVybG9hZHPDuDEgPSBpc1ZlY3RvcihmaXJzdChib2R5w7gxKSkgPyBsaXN0KGJvZHnDuDEpIDogaXNMaXN0KGZpcnN0KGJvZHnDuDEpKSAmJiBpc1ZlY3RvcihmaXJzdChmaXJzdChib2R5w7gxKSkpID8gYm9kecO4MSA6ICdlbHNlJyA/IHN5bnRheEVycm9yKCcnICsgJ01hbGZvcm1lZCBmbiBleHByZXNzaW9uLCAnICsgJ3BhcmFtZXRlciBkZWNsYXJhdGlvbiAoJyArIHByU3RyKGZpcnN0KGJvZHnDuDEpKSArICcpIG11c3QgYmUgYSB2ZWN0b3InLCBmb3JtKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBzY29wZcO4MSA9IGJpbmRpbmfDuDEgPyB3aXRoQmluZGluZyhzdWJFbnYoZW52KSwgYmluZGluZ8O4MSkgOiBzdWJFbnYoZW52KTtcbiAgICAgICAgICAgIHZhciBtZXRob2Rzw7gxID0gbWFwKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5hbHl6ZUZuTWV0aG9kKHNjb3Blw7gxLCAkMSk7XG4gICAgICAgICAgICAgICAgfSwgdmVjKG92ZXJsb2Fkc8O4MSkpO1xuICAgICAgICAgICAgdmFyIGFyaXR5w7gxID0gbWF4LmFwcGx5KHZvaWQgMCwgbWFwKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCQxIHx8IDApWydhcml0eSddO1xuICAgICAgICAgICAgICAgIH0sIG1ldGhvZHPDuDEpKTtcbiAgICAgICAgICAgIHZhciB2YXJpYWRpY8O4MSA9IHNvbWUoZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJDEgfHwgMClbJ3ZhcmlhZGljJ107XG4gICAgICAgICAgICAgICAgfSwgbWV0aG9kc8O4MSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICdmbicsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICdpZCc6IGJpbmRpbmfDuDEsXG4gICAgICAgICAgICAgICAgJ3ZhcmlhZGljJzogdmFyaWFkaWPDuDEsXG4gICAgICAgICAgICAgICAgJ21ldGhvZHMnOiBtZXRob2Rzw7gxLFxuICAgICAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgnZm4nLCBhbmFseXplRm4pO1xudmFyIHBhcnNlUmVmZXJlbmNlcyA9IGV4cG9ydHMucGFyc2VSZWZlcmVuY2VzID0gZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2VzKGZvcm1zKSB7XG4gICAgICAgIHJldHVybiByZWR1Y2UoZnVuY3Rpb24gKHJlZmVyZW5jZXMsIGZvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NlcShmb3JtKSA/IGFzc29jKHJlZmVyZW5jZXMsIG5hbWUoZmlyc3QoZm9ybSkpLCB2ZWMocmVzdChmb3JtKSkpIDogcmVmZXJlbmNlcztcbiAgICAgICAgfSwge30sIGZvcm1zKTtcbiAgICB9O1xudmFyIHBhcnNlUmVxdWlyZSA9IGV4cG9ydHMucGFyc2VSZXF1aXJlID0gZnVuY3Rpb24gcGFyc2VSZXF1aXJlKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXF1aXJlbWVudMO4MSA9IGlzU3ltYm9sKGZvcm0pID8gW2Zvcm1dIDogdmVjKGZvcm0pO1xuICAgICAgICAgICAgdmFyIGlkw7gxID0gZmlyc3QocmVxdWlyZW1lbnTDuDEpO1xuICAgICAgICAgICAgdmFyIHBhcmFtc8O4MSA9IGRpY3Rpb25hcnkuYXBwbHkodm9pZCAwLCByZXN0KHJlcXVpcmVtZW50w7gxKSk7XG4gICAgICAgICAgICB2YXIgcmVuYW1lc8O4MSA9IChwYXJhbXPDuDEgfHwgMClbJ1xcdUE3ODlyZW5hbWUnXTtcbiAgICAgICAgICAgIHZhciBuYW1lc8O4MSA9IChwYXJhbXPDuDEgfHwgMClbJ1xcdUE3ODlyZWZlciddO1xuICAgICAgICAgICAgdmFyIGFsaWFzw7gxID0gKHBhcmFtc8O4MSB8fCAwKVsnXFx1QTc4OWFzJ107XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlc8O4MSA9ICFpc0VtcHR5KG5hbWVzw7gxKSA/IHJlZHVjZShmdW5jdGlvbiAocmVmZXJzLCByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmoocmVmZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnb3AnOiAncmVmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiByZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IHJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZW5hbWUnOiAocmVuYW1lc8O4MSB8fCAwKVtyZWZlcmVuY2VdIHx8IChyZW5hbWVzw7gxIHx8IDApW25hbWUocmVmZXJlbmNlKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnMnOiBpZMO4MVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBbXSwgbmFtZXPDuDEpIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnb3AnOiAncmVxdWlyZScsXG4gICAgICAgICAgICAgICAgJ2FsaWFzJzogYWxpYXPDuDEsXG4gICAgICAgICAgICAgICAgJ25zJzogaWTDuDEsXG4gICAgICAgICAgICAgICAgJ3JlZmVyJzogcmVmZXJlbmNlc8O4MSxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGFuYWx5emVOcyA9IGV4cG9ydHMuYW5hbHl6ZU5zID0gZnVuY3Rpb24gYW5hbHl6ZU5zKGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZvcm1zw7gxID0gcmVzdChmb3JtKTtcbiAgICAgICAgICAgIHZhciBuYW1lw7gxID0gZmlyc3QoZm9ybXPDuDEpO1xuICAgICAgICAgICAgdmFyIGJvZHnDuDEgPSByZXN0KGZvcm1zw7gxKTtcbiAgICAgICAgICAgIHZhciBkb2PDuDEgPSBpc1N0cmluZyhmaXJzdChib2R5w7gxKSkgPyBmaXJzdChib2R5w7gxKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2Vzw7gxID0gcGFyc2VSZWZlcmVuY2VzKGRvY8O4MSA/IHJlc3QoYm9kecO4MSkgOiBib2R5w7gxKTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlbWVudHPDuDEgPSAocmVmZXJlbmNlc8O4MSB8fCAwKVsncmVxdWlyZSddID8gbWFwKHBhcnNlUmVxdWlyZSwgKHJlZmVyZW5jZXPDuDEgfHwgMClbJ3JlcXVpcmUnXSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICducycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiBuYW1lw7gxLFxuICAgICAgICAgICAgICAgICdkb2MnOiBkb2PDuDEsXG4gICAgICAgICAgICAgICAgJ3JlcXVpcmUnOiByZXF1aXJlbWVudHPDuDEgPyB2ZWMocmVxdWlyZW1lbnRzw7gxKSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xuaW5zdGFsbFNwZWNpYWwoJ25zJywgYW5hbHl6ZU5zKTtcbnZhciBhbmFseXplTGlzdCA9IGV4cG9ydHMuYW5hbHl6ZUxpc3QgPSBmdW5jdGlvbiBhbmFseXplTGlzdChlbnYsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHBhbnNpb27DuDEgPSBtYWNyb2V4cGFuZChmb3JtLCBlbnYpO1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yw7gxID0gZmlyc3QoZm9ybSk7XG4gICAgICAgICAgICB2YXIgYW5hbHl6ZXLDuDEgPSBpc1N5bWJvbChvcGVyYXRvcsO4MSkgJiYgKF9fc3BlY2lhbHNfXyB8fCAwKVtuYW1lKG9wZXJhdG9yw7gxKV07XG4gICAgICAgICAgICByZXR1cm4gIShleHBhbnNpb27DuDEgPT09IGZvcm0pID8gYW5hbHl6ZShlbnYsIGV4cGFuc2lvbsO4MSkgOiBhbmFseXplcsO4MSA/IGFuYWx5emVTcGVjaWFsKGFuYWx5emVyw7gxLCBlbnYsIGV4cGFuc2lvbsO4MSkgOiAnZWxzZScgPyBhbmFseXplSW52b2tlKGVudiwgZXhwYW5zaW9uw7gxKSA6IHZvaWQgMDtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgYW5hbHl6ZVZlY3RvciA9IGV4cG9ydHMuYW5hbHl6ZVZlY3RvciA9IGZ1bmN0aW9uIGFuYWx5emVWZWN0b3IoZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXPDuDEgPSB2ZWMobWFwKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5hbHl6ZShlbnYsICQxKTtcbiAgICAgICAgICAgICAgICB9LCBmb3JtKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICd2ZWN0b3InLFxuICAgICAgICAgICAgICAgICdmb3JtJzogZm9ybSxcbiAgICAgICAgICAgICAgICAnaXRlbXMnOiBpdGVtc8O4MVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgYW5hbHl6ZURpY3Rpb25hcnkgPSBleHBvcnRzLmFuYWx5emVEaWN0aW9uYXJ5ID0gZnVuY3Rpb24gYW5hbHl6ZURpY3Rpb25hcnkoZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXPDuDEgPSB2ZWMobWFwKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5hbHl6ZShlbnYsICQxKTtcbiAgICAgICAgICAgICAgICB9LCBrZXlzKGZvcm0pKSk7XG4gICAgICAgICAgICB2YXIgdmFsdWVzw7gxID0gdmVjKG1hcChmdW5jdGlvbiAoJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuYWx5emUoZW52LCAkMSk7XG4gICAgICAgICAgICAgICAgfSwgdmFscyhmb3JtKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnb3AnOiAnZGljdGlvbmFyeScsXG4gICAgICAgICAgICAgICAgJ2tleXMnOiBuYW1lc8O4MSxcbiAgICAgICAgICAgICAgICAndmFsdWVzJzogdmFsdWVzw7gxLFxuICAgICAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgYW5hbHl6ZUludm9rZSA9IGV4cG9ydHMuYW5hbHl6ZUludm9rZSA9IGZ1bmN0aW9uIGFuYWx5emVJbnZva2UoZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGVlw7gxID0gYW5hbHl6ZShlbnYsIGZpcnN0KGZvcm0pKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXPDuDEgPSB2ZWMobWFwKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5hbHl6ZShlbnYsICQxKTtcbiAgICAgICAgICAgICAgICB9LCByZXN0KGZvcm0pKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdvcCc6ICdpbnZva2UnLFxuICAgICAgICAgICAgICAgICdjYWxsZWUnOiBjYWxsZWXDuDEsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHBhcmFtc8O4MSxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IGZvcm1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGFuYWx5emVDb25zdGFudCA9IGV4cG9ydHMuYW5hbHl6ZUNvbnN0YW50ID0gZnVuY3Rpb24gYW5hbHl6ZUNvbnN0YW50KGVudiwgZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ29wJzogJ2NvbnN0YW50JyxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICB9O1xuICAgIH07XG52YXIgYW5hbHl6ZSA9IGV4cG9ydHMuYW5hbHl6ZSA9IGZ1bmN0aW9uIGFuYWx5emUoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiBhbmFseXplKHtcbiAgICAgICAgICAgICAgICAnbG9jYWxzJzoge30sXG4gICAgICAgICAgICAgICAgJ2JpbmRpbmdzJzogW10sXG4gICAgICAgICAgICAgICAgJ3RvcCc6IHRydWVcbiAgICAgICAgICAgIH0sIGZvcm0pO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgZW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4gaXNOaWwoZm9ybSkgPyBhbmFseXplQ29uc3RhbnQoZW52LCBmb3JtKSA6IGlzU3ltYm9sKGZvcm0pID8gYW5hbHl6ZVN5bWJvbChlbnYsIGZvcm0pIDogaXNMaXN0KGZvcm0pID8gaXNFbXB0eShmb3JtKSA/IGFuYWx5emVRdW90ZWQoZm9ybSkgOiBhbmFseXplTGlzdChlbnYsIGZvcm0pIDogaXNEaWN0aW9uYXJ5KGZvcm0pID8gYW5hbHl6ZURpY3Rpb25hcnkoZW52LCBmb3JtKSA6IGlzVmVjdG9yKGZvcm0pID8gYW5hbHl6ZVZlY3RvcihlbnYsIGZvcm0pIDogaXNLZXl3b3JkKGZvcm0pID8gYW5hbHl6ZUtleXdvcmQoZW52LCBmb3JtKSA6ICdlbHNlJyA/IGFuYWx5emVDb25zdGFudChlbnYsIGZvcm0pIDogdm9pZCAwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgIH07Iiwie1xuICAgIHZhciBfbnNfID0ge1xuICAgICAgICAgICAgaWQ6ICd3aXNwLmFzdCcsXG4gICAgICAgICAgICBkb2M6IHZvaWQgMFxuICAgICAgICB9O1xuICAgIHZhciB3aXNwX3NlcXVlbmNlID0gcmVxdWlyZSgnLi9zZXF1ZW5jZScpO1xuICAgIHZhciBpc0xpc3QgPSB3aXNwX3NlcXVlbmNlLmlzTGlzdDtcbiAgICB2YXIgaXNTZXF1ZW50aWFsID0gd2lzcF9zZXF1ZW5jZS5pc1NlcXVlbnRpYWw7XG4gICAgdmFyIGZpcnN0ID0gd2lzcF9zZXF1ZW5jZS5maXJzdDtcbiAgICB2YXIgc2Vjb25kID0gd2lzcF9zZXF1ZW5jZS5zZWNvbmQ7XG4gICAgdmFyIGNvdW50ID0gd2lzcF9zZXF1ZW5jZS5jb3VudDtcbiAgICB2YXIgbGFzdCA9IHdpc3Bfc2VxdWVuY2UubGFzdDtcbiAgICB2YXIgbWFwID0gd2lzcF9zZXF1ZW5jZS5tYXA7XG4gICAgdmFyIHZlYyA9IHdpc3Bfc2VxdWVuY2UudmVjO1xuICAgIHZhciByZXBlYXQgPSB3aXNwX3NlcXVlbmNlLnJlcGVhdDtcbiAgICB2YXIgd2lzcF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZycpO1xuICAgIHZhciBzcGxpdCA9IHdpc3Bfc3RyaW5nLnNwbGl0O1xuICAgIHZhciBqb2luID0gd2lzcF9zdHJpbmcuam9pbjtcbiAgICB2YXIgd2lzcF9ydW50aW1lID0gcmVxdWlyZSgnLi9ydW50aW1lJyk7XG4gICAgdmFyIGlzTmlsID0gd2lzcF9ydW50aW1lLmlzTmlsO1xuICAgIHZhciBpc1ZlY3RvciA9IHdpc3BfcnVudGltZS5pc1ZlY3RvcjtcbiAgICB2YXIgaXNOdW1iZXIgPSB3aXNwX3J1bnRpbWUuaXNOdW1iZXI7XG4gICAgdmFyIGlzU3RyaW5nID0gd2lzcF9ydW50aW1lLmlzU3RyaW5nO1xuICAgIHZhciBpc0Jvb2xlYW4gPSB3aXNwX3J1bnRpbWUuaXNCb29sZWFuO1xuICAgIHZhciBpc09iamVjdCA9IHdpc3BfcnVudGltZS5pc09iamVjdDtcbiAgICB2YXIgaXNEYXRlID0gd2lzcF9ydW50aW1lLmlzRGF0ZTtcbiAgICB2YXIgaXNSZVBhdHRlcm4gPSB3aXNwX3J1bnRpbWUuaXNSZVBhdHRlcm47XG4gICAgdmFyIGlzRGljdGlvbmFyeSA9IHdpc3BfcnVudGltZS5pc0RpY3Rpb25hcnk7XG4gICAgdmFyIHN0ciA9IHdpc3BfcnVudGltZS5zdHI7XG4gICAgdmFyIGluYyA9IHdpc3BfcnVudGltZS5pbmM7XG4gICAgdmFyIHN1YnMgPSB3aXNwX3J1bnRpbWUuc3VicztcbiAgICB2YXIgaXNFcXVhbCA9IHdpc3BfcnVudGltZS5pc0VxdWFsO1xufVxudmFyIHdpdGhNZXRhID0gZXhwb3J0cy53aXRoTWV0YSA9IGZ1bmN0aW9uIHdpdGhNZXRhKHZhbHVlLCBtZXRhZGF0YSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsICdtZXRhZGF0YScsIHtcbiAgICAgICAgICAgICd2YWx1ZSc6IG1ldGFkYXRhLFxuICAgICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xudmFyIG1ldGEgPSBleHBvcnRzLm1ldGEgPSBmdW5jdGlvbiBtZXRhKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc05pbCh2YWx1ZSkgPyB2b2lkIDAgOiB2YWx1ZS5tZXRhZGF0YTtcbiAgICB9O1xudmFyIF9fbnNTZXBhcmF0b3JfXyA9IGV4cG9ydHMuX19uc1NlcGFyYXRvcl9fID0gJ1xcdTIwNDQnO1xudmFyIFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbChuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzO1xufTtcblN5bWJvbC50eXBlID0gJ3dpc3Auc3ltYm9sJztcblN5bWJvbC5wcm90b3R5cGUudHlwZSA9IFN5bWJvbC50eXBlO1xuU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlZml4w7gxID0gJycgKyAnXFx1RkVGRicgKyAnXFwnJztcbiAgICAgICAgdmFyIG5zw7gxID0gbmFtZXNwYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gbnPDuDEgPyAnJyArIHByZWZpeMO4MSArIG5zw7gxICsgJy8nICsgbmFtZSh0aGlzKSA6ICcnICsgcHJlZml4w7gxICsgbmFtZSh0aGlzKTtcbiAgICB9LmNhbGwodGhpcyk7XG59O1xudmFyIHN5bWJvbCA9IGV4cG9ydHMuc3ltYm9sID0gZnVuY3Rpb24gc3ltYm9sKG5zLCBpZCkge1xuICAgICAgICByZXR1cm4gaXNTeW1ib2wobnMpID8gbnMgOiBpc0tleXdvcmQobnMpID8gbmV3IFN5bWJvbChuYW1lc3BhY2UobnMpLCBuYW1lKG5zKSkgOiBpc05pbChpZCkgPyBuZXcgU3ltYm9sKHZvaWQgMCwgbnMpIDogJ2Vsc2UnID8gbmV3IFN5bWJvbChucywgaWQpIDogdm9pZCAwO1xuICAgIH07XG52YXIgaXNTeW1ib2wgPSBleHBvcnRzLmlzU3ltYm9sID0gZnVuY3Rpb24gaXNTeW1ib2woeCkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoeCkgJiYgJ1xcdUZFRkYnID09PSB4WzBdICYmICdcXCcnID09PSB4WzFdIHx8IHggJiYgU3ltYm9sLnR5cGUgPT09IHgudHlwZTtcbiAgICB9O1xudmFyIGlzS2V5d29yZCA9IGV4cG9ydHMuaXNLZXl3b3JkID0gZnVuY3Rpb24gaXNLZXl3b3JkKHgpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHgpICYmIGNvdW50KHgpID4gMSAmJiBmaXJzdCh4KSA9PT0gJ1xcdUE3ODknO1xuICAgIH07XG52YXIga2V5d29yZCA9IGV4cG9ydHMua2V5d29yZCA9IGZ1bmN0aW9uIGtleXdvcmQobnMsIGlkKSB7XG4gICAgICAgIHJldHVybiBpc0tleXdvcmQobnMpID8gbnMgOiBpc1N5bWJvbChucykgPyAnJyArICdcXHVBNzg5JyArIG5hbWUobnMpIDogaXNOaWwoaWQpID8gJycgKyAnXFx1QTc4OScgKyBucyA6IGlzTmlsKG5zKSA/ICcnICsgJ1xcdUE3ODknICsgaWQgOiAnZWxzZScgPyAnJyArICdcXHVBNzg5JyArIG5zICsgX19uc1NlcGFyYXRvcl9fICsgaWQgOiB2b2lkIDA7XG4gICAgfTtcbnZhciBrZXl3b3JkTmFtZSA9IGZ1bmN0aW9uIGtleXdvcmROYW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIGxhc3Qoc3BsaXQoc3Vicyh2YWx1ZSwgMSksIF9fbnNTZXBhcmF0b3JfXykpO1xufTtcbnZhciBzeW1ib2xOYW1lID0gZnVuY3Rpb24gc3ltYm9sTmFtZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5uYW1lIHx8IGxhc3Qoc3BsaXQoc3Vicyh2YWx1ZSwgMiksIF9fbnNTZXBhcmF0b3JfXykpO1xufTtcbnZhciBuYW1lID0gZXhwb3J0cy5uYW1lID0gZnVuY3Rpb24gbmFtZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gc3ltYm9sTmFtZSh2YWx1ZSkgOiBpc0tleXdvcmQodmFsdWUpID8ga2V5d29yZE5hbWUodmFsdWUpIDogaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiAnZWxzZScgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignJyArICdEb2VzblxcJ3Qgc3VwcG9ydCBuYW1lOiAnICsgdmFsdWUpO1xuICAgICAgICB9KSgpIDogdm9pZCAwO1xuICAgIH07XG52YXIga2V5d29yZE5hbWVzcGFjZSA9IGZ1bmN0aW9uIGtleXdvcmROYW1lc3BhY2UoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJ0c8O4MSA9IHNwbGl0KHN1YnMoeCwgMSksIF9fbnNTZXBhcmF0b3JfXyk7XG4gICAgICAgIHJldHVybiBjb3VudChwYXJ0c8O4MSkgPiAxID8gcGFydHPDuDFbMF0gOiB2b2lkIDA7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBzeW1ib2xOYW1lc3BhY2UgPSBmdW5jdGlvbiBzeW1ib2xOYW1lc3BhY2UoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJ0c8O4MSA9IGlzU3RyaW5nKHgpID8gc3BsaXQoc3Vicyh4LCAxKSwgX19uc1NlcGFyYXRvcl9fKSA6IFtcbiAgICAgICAgICAgICAgICB4Lm5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICB4Lm5hbWVcbiAgICAgICAgICAgIF07XG4gICAgICAgIHJldHVybiBjb3VudChwYXJ0c8O4MSkgPiAxID8gcGFydHPDuDFbMF0gOiB2b2lkIDA7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBuYW1lc3BhY2UgPSBleHBvcnRzLm5hbWVzcGFjZSA9IGZ1bmN0aW9uIG5hbWVzcGFjZSh4KSB7XG4gICAgICAgIHJldHVybiBpc1N5bWJvbCh4KSA/IHN5bWJvbE5hbWVzcGFjZSh4KSA6IGlzS2V5d29yZCh4KSA/IGtleXdvcmROYW1lc3BhY2UoeCkgOiAnZWxzZScgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignJyArICdEb2VzblxcJ3Qgc3VwcG9ydHMgbmFtZXNwYWNlOiAnICsgeCk7XG4gICAgICAgIH0pKCkgOiB2b2lkIDA7XG4gICAgfTtcbnZhciBnZW5zeW0gPSBleHBvcnRzLmdlbnN5bSA9IGZ1bmN0aW9uIGdlbnN5bShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbCgnJyArIChpc05pbChwcmVmaXgpID8gJ0dfXycgOiBwcmVmaXgpICsgKGdlbnN5bS5iYXNlID0gZ2Vuc3ltLmJhc2UgKyAxKSk7XG4gICAgfTtcbmdlbnN5bS5iYXNlID0gMDtcbnZhciBpc1VucXVvdGUgPSBleHBvcnRzLmlzVW5xdW90ZSA9IGZ1bmN0aW9uIGlzVW5xdW90ZShmb3JtKSB7XG4gICAgICAgIHJldHVybiBpc0xpc3QoZm9ybSkgJiYgaXNFcXVhbChmaXJzdChmb3JtKSwgc3ltYm9sKHZvaWQgMCwgJ3VucXVvdGUnKSk7XG4gICAgfTtcbnZhciBpc1VucXVvdGVTcGxpY2luZyA9IGV4cG9ydHMuaXNVbnF1b3RlU3BsaWNpbmcgPSBmdW5jdGlvbiBpc1VucXVvdGVTcGxpY2luZyhmb3JtKSB7XG4gICAgICAgIHJldHVybiBpc0xpc3QoZm9ybSkgJiYgaXNFcXVhbChmaXJzdChmb3JtKSwgc3ltYm9sKHZvaWQgMCwgJ3VucXVvdGUtc3BsaWNpbmcnKSk7XG4gICAgfTtcbnZhciBpc1F1b3RlID0gZXhwb3J0cy5pc1F1b3RlID0gZnVuY3Rpb24gaXNRdW90ZShmb3JtKSB7XG4gICAgICAgIHJldHVybiBpc0xpc3QoZm9ybSkgJiYgaXNFcXVhbChmaXJzdChmb3JtKSwgc3ltYm9sKHZvaWQgMCwgJ3F1b3RlJykpO1xuICAgIH07XG52YXIgaXNTeW50YXhRdW90ZSA9IGV4cG9ydHMuaXNTeW50YXhRdW90ZSA9IGZ1bmN0aW9uIGlzU3ludGF4UXVvdGUoZm9ybSkge1xuICAgICAgICByZXR1cm4gaXNMaXN0KGZvcm0pICYmIGlzRXF1YWwoZmlyc3QoZm9ybSksIHN5bWJvbCh2b2lkIDAsICdzeW50YXgtcXVvdGUnKSk7XG4gICAgfTtcbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgIHZhciBuc8O4MSA9ICcnICsgbjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSBjb3VudChuc8O4MSkgPCBsZW4gPyAobG9vcFswXSA9ICcnICsgJzAnICsgbnPDuDEsIGxvb3ApIDogbnPDuDE7XG4gICAgICAgIH0gd2hpbGUgKG5zw7gxID0gbG9vcFswXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBxdW90ZVN0cmluZyA9IGV4cG9ydHMucXVvdGVTdHJpbmcgPSBmdW5jdGlvbiBxdW90ZVN0cmluZyhzKSB7XG4gICAgICAgIHMgPSBqb2luKCdcXFxcXCInLCBzcGxpdChzLCAnXCInKSk7XG4gICAgICAgIHMgPSBqb2luKCdcXFxcXFxcXCcsIHNwbGl0KHMsICdcXFxcJykpO1xuICAgICAgICBzID0gam9pbignXFxcXGInLCBzcGxpdChzLCAnXFxiJykpO1xuICAgICAgICBzID0gam9pbignXFxcXGYnLCBzcGxpdChzLCAnXFxmJykpO1xuICAgICAgICBzID0gam9pbignXFxcXG4nLCBzcGxpdChzLCAnXFxuJykpO1xuICAgICAgICBzID0gam9pbignXFxcXHInLCBzcGxpdChzLCAnXFxyJykpO1xuICAgICAgICBzID0gam9pbignXFxcXHQnLCBzcGxpdChzLCAnXFx0JykpO1xuICAgICAgICByZXR1cm4gJycgKyAnXCInICsgcyArICdcIic7XG4gICAgfTtcbnZhciBwclN0ciA9IGV4cG9ydHMucHJTdHIgPSBmdW5jdGlvbiBwclN0cih4LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXTDuDIgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgICAgIHJldHVybiBpc05pbCh4KSA/ICduaWwnIDogaXNLZXl3b3JkKHgpID8gbmFtZXNwYWNlKHgpID8gJycgKyAnOicgKyBuYW1lc3BhY2UoeCkgKyAnLycgKyBuYW1lKHgpIDogJycgKyAnOicgKyBuYW1lKHgpIDogaXNTeW1ib2woeCkgPyBuYW1lc3BhY2UoeCkgPyAnJyArIG5hbWVzcGFjZSh4KSArICcvJyArIG5hbWUoeCkgOiBuYW1lKHgpIDogaXNTdHJpbmcoeCkgPyBxdW90ZVN0cmluZyh4KSA6IGlzRGF0ZSh4KSA/ICcnICsgJyNpbnN0IFwiJyArIHguZ2V0VVRDRnVsbFllYXIoKSArICctJyArIG5vcm1hbGl6ZShpbmMoeC5nZXRVVENNb250aCgpKSwgMikgKyAnLScgKyBub3JtYWxpemUoeC5nZXRVVENEYXRlKCksIDIpICsgJ1QnICsgbm9ybWFsaXplKHguZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgKyBub3JtYWxpemUoeC5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICsgbm9ybWFsaXplKHguZ2V0VVRDU2Vjb25kcygpLCAyKSArICcuJyArIG5vcm1hbGl6ZSh4LmdldFVUQ01pbGxpc2Vjb25kcygpLCAzKSArICctJyArICcwMDowMFwiJyA6IGlzVmVjdG9yKHgpID8gJycgKyAnWycgKyBqb2luKCcnICsgJ1xcbiAnICsgam9pbihyZXBlYXQoaW5jKG9mZnNldMO4MiksICcgJykpLCBtYXAoZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByU3RyKCQxLCBpbmMob2Zmc2V0w7gyKSk7XG4gICAgICAgICAgICB9LCB2ZWMoeCkpKSArICddJyA6IGlzRGljdGlvbmFyeSh4KSA/ICcnICsgJ3snICsgam9pbignJyArICcsXFxuJyArIGpvaW4ocmVwZWF0KGluYyhvZmZzZXTDuDIpLCAnICcpKSwgbWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGVudMO4MSA9IGpvaW4ocmVwZWF0KG9mZnNldMO4MiwgJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXnDuDEgPSBwclN0cihmaXJzdChwYWlyKSwgaW5jKG9mZnNldMO4MikpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWXDuDEgPSBwclN0cihzZWNvbmQocGFpciksIDIgKyBvZmZzZXTDuDIgKyBjb3VudChrZXnDuDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnICsga2V5w7gxICsgJyAnICsgdmFsdWXDuDE7XG4gICAgICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfSwgeCkpICsgJ30nIDogaXNTZXF1ZW50aWFsKHgpID8gJycgKyAnKCcgKyBqb2luKCcgJywgbWFwKGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwclN0cigkMSwgaW5jKG9mZnNldMO4MikpO1xuICAgICAgICAgICAgfSwgdmVjKHgpKSkgKyAnKScgOiBpc1JlUGF0dGVybih4KSA/ICcnICsgJyNcIicgKyBqb2luKCdcXFxcLycsIHNwbGl0KHguc291cmNlLCAnLycpKSArICdcIicgOiAnZWxzZScgPyAnJyArIHggOiB2b2lkIDA7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9OyIsIntcbiAgICB2YXIgX25zXyA9IHtcbiAgICAgICAgICAgIGlkOiAnd2lzcC5iYWNrZW5kLmVzY29kZWdlbi5nZW5lcmF0b3InLFxuICAgICAgICAgICAgZG9jOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICB2YXIgd2lzcF9yZWFkZXIgPSByZXF1aXJlKCcuLy4uLy4uL3JlYWRlcicpO1xuICAgIHZhciByZWFkU3RyaW5nID0gd2lzcF9yZWFkZXIucmVhZEZyb21TdHJpbmc7XG4gICAgdmFyIHJlYWRfID0gd2lzcF9yZWFkZXIucmVhZF87XG4gICAgdmFyIHdpc3BfYXN0ID0gcmVxdWlyZSgnLi8uLi8uLi9hc3QnKTtcbiAgICB2YXIgbWV0YSA9IHdpc3BfYXN0Lm1ldGE7XG4gICAgdmFyIHdpdGhNZXRhID0gd2lzcF9hc3Qud2l0aE1ldGE7XG4gICAgdmFyIGlzU3ltYm9sID0gd2lzcF9hc3QuaXNTeW1ib2w7XG4gICAgdmFyIHN5bWJvbCA9IHdpc3BfYXN0LnN5bWJvbDtcbiAgICB2YXIgaXNLZXl3b3JkID0gd2lzcF9hc3QuaXNLZXl3b3JkO1xuICAgIHZhciBrZXl3b3JkID0gd2lzcF9hc3Qua2V5d29yZDtcbiAgICB2YXIgbmFtZXNwYWNlID0gd2lzcF9hc3QubmFtZXNwYWNlO1xuICAgIHZhciBpc1VucXVvdGUgPSB3aXNwX2FzdC5pc1VucXVvdGU7XG4gICAgdmFyIGlzVW5xdW90ZVNwbGljaW5nID0gd2lzcF9hc3QuaXNVbnF1b3RlU3BsaWNpbmc7XG4gICAgdmFyIGlzUXVvdGUgPSB3aXNwX2FzdC5pc1F1b3RlO1xuICAgIHZhciBpc1N5bnRheFF1b3RlID0gd2lzcF9hc3QuaXNTeW50YXhRdW90ZTtcbiAgICB2YXIgbmFtZSA9IHdpc3BfYXN0Lm5hbWU7XG4gICAgdmFyIGdlbnN5bSA9IHdpc3BfYXN0LmdlbnN5bTtcbiAgICB2YXIgcHJTdHIgPSB3aXNwX2FzdC5wclN0cjtcbiAgICB2YXIgd2lzcF9zZXF1ZW5jZSA9IHJlcXVpcmUoJy4vLi4vLi4vc2VxdWVuY2UnKTtcbiAgICB2YXIgaXNFbXB0eSA9IHdpc3Bfc2VxdWVuY2UuaXNFbXB0eTtcbiAgICB2YXIgY291bnQgPSB3aXNwX3NlcXVlbmNlLmNvdW50O1xuICAgIHZhciBpc0xpc3QgPSB3aXNwX3NlcXVlbmNlLmlzTGlzdDtcbiAgICB2YXIgbGlzdCA9IHdpc3Bfc2VxdWVuY2UubGlzdDtcbiAgICB2YXIgZmlyc3QgPSB3aXNwX3NlcXVlbmNlLmZpcnN0O1xuICAgIHZhciBzZWNvbmQgPSB3aXNwX3NlcXVlbmNlLnNlY29uZDtcbiAgICB2YXIgdGhpcmQgPSB3aXNwX3NlcXVlbmNlLnRoaXJkO1xuICAgIHZhciByZXN0ID0gd2lzcF9zZXF1ZW5jZS5yZXN0O1xuICAgIHZhciBjb25zID0gd2lzcF9zZXF1ZW5jZS5jb25zO1xuICAgIHZhciBjb25qID0gd2lzcF9zZXF1ZW5jZS5jb25qO1xuICAgIHZhciBidXRsYXN0ID0gd2lzcF9zZXF1ZW5jZS5idXRsYXN0O1xuICAgIHZhciByZXZlcnNlID0gd2lzcF9zZXF1ZW5jZS5yZXZlcnNlO1xuICAgIHZhciByZWR1Y2UgPSB3aXNwX3NlcXVlbmNlLnJlZHVjZTtcbiAgICB2YXIgdmVjID0gd2lzcF9zZXF1ZW5jZS52ZWM7XG4gICAgdmFyIGxhc3QgPSB3aXNwX3NlcXVlbmNlLmxhc3Q7XG4gICAgdmFyIG1hcCA9IHdpc3Bfc2VxdWVuY2UubWFwO1xuICAgIHZhciBmaWx0ZXIgPSB3aXNwX3NlcXVlbmNlLmZpbHRlcjtcbiAgICB2YXIgdGFrZSA9IHdpc3Bfc2VxdWVuY2UudGFrZTtcbiAgICB2YXIgY29uY2F0ID0gd2lzcF9zZXF1ZW5jZS5jb25jYXQ7XG4gICAgdmFyIHBhcnRpdGlvbiA9IHdpc3Bfc2VxdWVuY2UucGFydGl0aW9uO1xuICAgIHZhciByZXBlYXQgPSB3aXNwX3NlcXVlbmNlLnJlcGVhdDtcbiAgICB2YXIgaW50ZXJsZWF2ZSA9IHdpc3Bfc2VxdWVuY2UuaW50ZXJsZWF2ZTtcbiAgICB2YXIgd2lzcF9ydW50aW1lID0gcmVxdWlyZSgnLi8uLi8uLi9ydW50aW1lJyk7XG4gICAgdmFyIGlzT2RkID0gd2lzcF9ydW50aW1lLmlzT2RkO1xuICAgIHZhciBpc0RpY3Rpb25hcnkgPSB3aXNwX3J1bnRpbWUuaXNEaWN0aW9uYXJ5O1xuICAgIHZhciBkaWN0aW9uYXJ5ID0gd2lzcF9ydW50aW1lLmRpY3Rpb25hcnk7XG4gICAgdmFyIG1lcmdlID0gd2lzcF9ydW50aW1lLm1lcmdlO1xuICAgIHZhciBrZXlzID0gd2lzcF9ydW50aW1lLmtleXM7XG4gICAgdmFyIHZhbHMgPSB3aXNwX3J1bnRpbWUudmFscztcbiAgICB2YXIgaXNDb250YWluc1ZlY3RvciA9IHdpc3BfcnVudGltZS5pc0NvbnRhaW5zVmVjdG9yO1xuICAgIHZhciBtYXBEaWN0aW9uYXJ5ID0gd2lzcF9ydW50aW1lLm1hcERpY3Rpb25hcnk7XG4gICAgdmFyIGlzU3RyaW5nID0gd2lzcF9ydW50aW1lLmlzU3RyaW5nO1xuICAgIHZhciBpc051bWJlciA9IHdpc3BfcnVudGltZS5pc051bWJlcjtcbiAgICB2YXIgaXNWZWN0b3IgPSB3aXNwX3J1bnRpbWUuaXNWZWN0b3I7XG4gICAgdmFyIGlzQm9vbGVhbiA9IHdpc3BfcnVudGltZS5pc0Jvb2xlYW47XG4gICAgdmFyIHN1YnMgPSB3aXNwX3J1bnRpbWUuc3VicztcbiAgICB2YXIgcmVGaW5kID0gd2lzcF9ydW50aW1lLnJlRmluZDtcbiAgICB2YXIgaXNUcnVlID0gd2lzcF9ydW50aW1lLmlzVHJ1ZTtcbiAgICB2YXIgaXNGYWxzZSA9IHdpc3BfcnVudGltZS5pc0ZhbHNlO1xuICAgIHZhciBpc05pbCA9IHdpc3BfcnVudGltZS5pc05pbDtcbiAgICB2YXIgaXNSZVBhdHRlcm4gPSB3aXNwX3J1bnRpbWUuaXNSZVBhdHRlcm47XG4gICAgdmFyIGluYyA9IHdpc3BfcnVudGltZS5pbmM7XG4gICAgdmFyIGRlYyA9IHdpc3BfcnVudGltZS5kZWM7XG4gICAgdmFyIHN0ciA9IHdpc3BfcnVudGltZS5zdHI7XG4gICAgdmFyIGNoYXIgPSB3aXNwX3J1bnRpbWUuY2hhcjtcbiAgICB2YXIgaW50ID0gd2lzcF9ydW50aW1lLmludDtcbiAgICB2YXIgaXNFcXVhbCA9IHdpc3BfcnVudGltZS5pc0VxdWFsO1xuICAgIHZhciBpc1N0cmljdEVxdWFsID0gd2lzcF9ydW50aW1lLmlzU3RyaWN0RXF1YWw7XG4gICAgdmFyIHdpc3Bfc3RyaW5nID0gcmVxdWlyZSgnLi8uLi8uLi9zdHJpbmcnKTtcbiAgICB2YXIgc3BsaXQgPSB3aXNwX3N0cmluZy5zcGxpdDtcbiAgICB2YXIgam9pbiA9IHdpc3Bfc3RyaW5nLmpvaW47XG4gICAgdmFyIHVwcGVyQ2FzZSA9IHdpc3Bfc3RyaW5nLnVwcGVyQ2FzZTtcbiAgICB2YXIgcmVwbGFjZSA9IHdpc3Bfc3RyaW5nLnJlcGxhY2U7XG4gICAgdmFyIHdpc3BfZXhwYW5kZXIgPSByZXF1aXJlKCcuLy4uLy4uL2V4cGFuZGVyJyk7XG4gICAgdmFyIGluc3RhbGxNYWNybyA9IHdpc3BfZXhwYW5kZXIuaW5zdGFsbE1hY3JvO1xuICAgIHZhciB3aXNwX2FuYWx5emVyID0gcmVxdWlyZSgnLi8uLi8uLi9hbmFseXplcicpO1xuICAgIHZhciBlbXB0eUVudiA9IHdpc3BfYW5hbHl6ZXIuZW1wdHlFbnY7XG4gICAgdmFyIGFuYWx5emUgPSB3aXNwX2FuYWx5emVyLmFuYWx5emU7XG4gICAgdmFyIGFuYWx5emVfID0gd2lzcF9hbmFseXplci5hbmFseXplXztcbiAgICB2YXIgd2lzcF9iYWNrZW5kX2VzY29kZWdlbl93cml0ZXIgPSByZXF1aXJlKCcuL3dyaXRlcicpO1xuICAgIHZhciB3cml0ZSA9IHdpc3BfYmFja2VuZF9lc2NvZGVnZW5fd3JpdGVyLndyaXRlO1xuICAgIHZhciBjb21waWxlID0gd2lzcF9iYWNrZW5kX2VzY29kZWdlbl93cml0ZXIuY29tcGlsZTtcbiAgICB2YXIgd3JpdGVfID0gd2lzcF9iYWNrZW5kX2VzY29kZWdlbl93cml0ZXIud3JpdGVfO1xuICAgIHZhciBlc2NvZGVnZW4gPSByZXF1aXJlKCdlc2NvZGVnZW4nKTtcbiAgICB2YXIgZ2VuZXJhdGVfID0gZXNjb2RlZ2VuLmdlbmVyYXRlO1xuICAgIHZhciBiYXNlNjRFbmNvZGUgPSByZXF1aXJlKCdiYXNlNjQtZW5jb2RlJyk7XG4gICAgdmFyIGJ0b2EgPSBiYXNlNjRFbmNvZGU7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICB2YXIgcmVhZEZpbGVTeW5jID0gZnMucmVhZEZpbGVTeW5jO1xuICAgIHZhciB3cml0ZUZpbGVTeW5jID0gZnMud3JpdGVGaWxlU3luYztcbiAgICB2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbiAgICB2YXIgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lO1xuICAgIHZhciBkaXJuYW1lID0gcGF0aC5kaXJuYW1lO1xuICAgIHZhciBqb2luUGF0aCA9IHBhdGguam9pbjtcbn1cbnZhciBnZW5lcmF0ZSA9IGV4cG9ydHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXN0w7gxID0gd3JpdGVfLmFwcGx5KHZvaWQgMCwgbm9kZXMpO1xuICAgICAgICAgICAgdmFyIG91dHB1dMO4MSA9IGdlbmVyYXRlXyhhc3TDuDEsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGUnOiAob3B0aW9ucyB8fCAwKVsnb3V0cHV0LXVyaSddLFxuICAgICAgICAgICAgICAgICAgICAnc291cmNlQ29udGVudCc6IChvcHRpb25zIHx8IDApWydzb3VyY2UnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZU1hcCc6IChvcHRpb25zIHx8IDApWydzb3VyY2UtdXJpJ10sXG4gICAgICAgICAgICAgICAgICAgICdzb3VyY2VNYXBSb290JzogKG9wdGlvbnMgfHwgMClbJ3NvdXJjZS1yb290J10sXG4gICAgICAgICAgICAgICAgICAgICdzb3VyY2VNYXBXaXRoQ29kZSc6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChvdXRwdXTDuDEgfHwgMClbJ21hcCddLnNldFNvdXJjZUNvbnRlbnQoKG9wdGlvbnMgfHwgMClbJ3NvdXJjZS11cmknXSwgKG9wdGlvbnMgfHwgMClbJ3NvdXJjZSddKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2NvZGUnOiAob3B0aW9ucyB8fCAwKVsnbm8tbWFwJ10gPyAob3V0cHV0w7gxIHx8IDApWydjb2RlJ10gOiAnJyArIChvdXRwdXTDuDEgfHwgMClbJ2NvZGUnXSArICdcXG4vLyMgc291cmNlTWFwcGluZ1VSTD0nICsgJ2RhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EoJycgKyAob3V0cHV0w7gxIHx8IDApWydtYXAnXSkgKyAnXFxuJyxcbiAgICAgICAgICAgICAgICAnc291cmNlLW1hcCc6IChvdXRwdXTDuDEgfHwgMClbJ21hcCddLFxuICAgICAgICAgICAgICAgICdqcy1hc3QnOiBhc3TDuDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGV4cGFuZERlZm1hY3JvID0gZXhwb3J0cy5leHBhbmREZWZtYWNybyA9IGZ1bmN0aW9uIGV4cGFuZERlZm1hY3JvKGFuZEZvcm0sIGlkKSB7XG4gICAgICAgIHZhciBib2R5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmbsO4MSA9IHdpdGhNZXRhKGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2RlZm4nKV0uY29uY2F0KFtpZF0sIHZlYyhib2R5KSkpLCBtZXRhKGFuZEZvcm0pKTtcbiAgICAgICAgICAgIHZhciBmb3Jtw7gxID0gbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnZG8nKV0uY29uY2F0KFtmbsO4MV0sIFtpZF0pKTtcbiAgICAgICAgICAgIHZhciBhc3TDuDEgPSBhbmFseXplKGZvcm3DuDEpO1xuICAgICAgICAgICAgdmFyIGNvZGXDuDEgPSBjb21waWxlKGFzdMO4MSk7XG4gICAgICAgICAgICB2YXIgbWFjcm/DuDEgPSBldmFsKGNvZGXDuDEpO1xuICAgICAgICAgICAgaW5zdGFsbE1hY3JvKGlkLCBtYWNyb8O4MSk7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxNYWNybyhzeW1ib2wodm9pZCAwLCAnZGVmbWFjcm8nKSwgd2l0aE1ldGEoZXhwYW5kRGVmbWFjcm8sIHsgJ2ltcGxpY2l0JzogWycmZm9ybSddIH0pKTtcbnZvaWQgMDsiLCJ7XG4gICAgdmFyIF9uc18gPSB7XG4gICAgICAgICAgICBpZDogJ3dpc3AuYmFja2VuZC5lc2NvZGVnZW4ud3JpdGVyJyxcbiAgICAgICAgICAgIGRvYzogdm9pZCAwXG4gICAgICAgIH07XG4gICAgdmFyIHdpc3BfcmVhZGVyID0gcmVxdWlyZSgnLi8uLi8uLi9yZWFkZXInKTtcbiAgICB2YXIgcmVhZEZyb21TdHJpbmcgPSB3aXNwX3JlYWRlci5yZWFkRnJvbVN0cmluZztcbiAgICB2YXIgd2lzcF9hc3QgPSByZXF1aXJlKCcuLy4uLy4uL2FzdCcpO1xuICAgIHZhciBtZXRhID0gd2lzcF9hc3QubWV0YTtcbiAgICB2YXIgd2l0aE1ldGEgPSB3aXNwX2FzdC53aXRoTWV0YTtcbiAgICB2YXIgaXNTeW1ib2wgPSB3aXNwX2FzdC5pc1N5bWJvbDtcbiAgICB2YXIgc3ltYm9sID0gd2lzcF9hc3Quc3ltYm9sO1xuICAgIHZhciBpc0tleXdvcmQgPSB3aXNwX2FzdC5pc0tleXdvcmQ7XG4gICAgdmFyIGtleXdvcmQgPSB3aXNwX2FzdC5rZXl3b3JkO1xuICAgIHZhciBuYW1lc3BhY2UgPSB3aXNwX2FzdC5uYW1lc3BhY2U7XG4gICAgdmFyIGlzVW5xdW90ZSA9IHdpc3BfYXN0LmlzVW5xdW90ZTtcbiAgICB2YXIgaXNVbnF1b3RlU3BsaWNpbmcgPSB3aXNwX2FzdC5pc1VucXVvdGVTcGxpY2luZztcbiAgICB2YXIgaXNRdW90ZSA9IHdpc3BfYXN0LmlzUXVvdGU7XG4gICAgdmFyIGlzU3ludGF4UXVvdGUgPSB3aXNwX2FzdC5pc1N5bnRheFF1b3RlO1xuICAgIHZhciBuYW1lID0gd2lzcF9hc3QubmFtZTtcbiAgICB2YXIgZ2Vuc3ltID0gd2lzcF9hc3QuZ2Vuc3ltO1xuICAgIHZhciBwclN0ciA9IHdpc3BfYXN0LnByU3RyO1xuICAgIHZhciB3aXNwX3NlcXVlbmNlID0gcmVxdWlyZSgnLi8uLi8uLi9zZXF1ZW5jZScpO1xuICAgIHZhciBpc0VtcHR5ID0gd2lzcF9zZXF1ZW5jZS5pc0VtcHR5O1xuICAgIHZhciBjb3VudCA9IHdpc3Bfc2VxdWVuY2UuY291bnQ7XG4gICAgdmFyIGlzTGlzdCA9IHdpc3Bfc2VxdWVuY2UuaXNMaXN0O1xuICAgIHZhciBsaXN0ID0gd2lzcF9zZXF1ZW5jZS5saXN0O1xuICAgIHZhciBmaXJzdCA9IHdpc3Bfc2VxdWVuY2UuZmlyc3Q7XG4gICAgdmFyIHNlY29uZCA9IHdpc3Bfc2VxdWVuY2Uuc2Vjb25kO1xuICAgIHZhciB0aGlyZCA9IHdpc3Bfc2VxdWVuY2UudGhpcmQ7XG4gICAgdmFyIHJlc3QgPSB3aXNwX3NlcXVlbmNlLnJlc3Q7XG4gICAgdmFyIGNvbnMgPSB3aXNwX3NlcXVlbmNlLmNvbnM7XG4gICAgdmFyIGNvbmogPSB3aXNwX3NlcXVlbmNlLmNvbmo7XG4gICAgdmFyIGJ1dGxhc3QgPSB3aXNwX3NlcXVlbmNlLmJ1dGxhc3Q7XG4gICAgdmFyIHJldmVyc2UgPSB3aXNwX3NlcXVlbmNlLnJldmVyc2U7XG4gICAgdmFyIHJlZHVjZSA9IHdpc3Bfc2VxdWVuY2UucmVkdWNlO1xuICAgIHZhciB2ZWMgPSB3aXNwX3NlcXVlbmNlLnZlYztcbiAgICB2YXIgbGFzdCA9IHdpc3Bfc2VxdWVuY2UubGFzdDtcbiAgICB2YXIgbWFwID0gd2lzcF9zZXF1ZW5jZS5tYXA7XG4gICAgdmFyIGZpbHRlciA9IHdpc3Bfc2VxdWVuY2UuZmlsdGVyO1xuICAgIHZhciB0YWtlID0gd2lzcF9zZXF1ZW5jZS50YWtlO1xuICAgIHZhciBjb25jYXQgPSB3aXNwX3NlcXVlbmNlLmNvbmNhdDtcbiAgICB2YXIgcGFydGl0aW9uID0gd2lzcF9zZXF1ZW5jZS5wYXJ0aXRpb247XG4gICAgdmFyIHJlcGVhdCA9IHdpc3Bfc2VxdWVuY2UucmVwZWF0O1xuICAgIHZhciBpbnRlcmxlYXZlID0gd2lzcF9zZXF1ZW5jZS5pbnRlcmxlYXZlO1xuICAgIHZhciBhc3NvYyA9IHdpc3Bfc2VxdWVuY2UuYXNzb2M7XG4gICAgdmFyIHdpc3BfcnVudGltZSA9IHJlcXVpcmUoJy4vLi4vLi4vcnVudGltZScpO1xuICAgIHZhciBpc09kZCA9IHdpc3BfcnVudGltZS5pc09kZDtcbiAgICB2YXIgaXNEaWN0aW9uYXJ5ID0gd2lzcF9ydW50aW1lLmlzRGljdGlvbmFyeTtcbiAgICB2YXIgZGljdGlvbmFyeSA9IHdpc3BfcnVudGltZS5kaWN0aW9uYXJ5O1xuICAgIHZhciBtZXJnZSA9IHdpc3BfcnVudGltZS5tZXJnZTtcbiAgICB2YXIga2V5cyA9IHdpc3BfcnVudGltZS5rZXlzO1xuICAgIHZhciB2YWxzID0gd2lzcF9ydW50aW1lLnZhbHM7XG4gICAgdmFyIGlzQ29udGFpbnNWZWN0b3IgPSB3aXNwX3J1bnRpbWUuaXNDb250YWluc1ZlY3RvcjtcbiAgICB2YXIgbWFwRGljdGlvbmFyeSA9IHdpc3BfcnVudGltZS5tYXBEaWN0aW9uYXJ5O1xuICAgIHZhciBpc1N0cmluZyA9IHdpc3BfcnVudGltZS5pc1N0cmluZztcbiAgICB2YXIgaXNOdW1iZXIgPSB3aXNwX3J1bnRpbWUuaXNOdW1iZXI7XG4gICAgdmFyIGlzVmVjdG9yID0gd2lzcF9ydW50aW1lLmlzVmVjdG9yO1xuICAgIHZhciBpc0Jvb2xlYW4gPSB3aXNwX3J1bnRpbWUuaXNCb29sZWFuO1xuICAgIHZhciBzdWJzID0gd2lzcF9ydW50aW1lLnN1YnM7XG4gICAgdmFyIHJlRmluZCA9IHdpc3BfcnVudGltZS5yZUZpbmQ7XG4gICAgdmFyIGlzVHJ1ZSA9IHdpc3BfcnVudGltZS5pc1RydWU7XG4gICAgdmFyIGlzRmFsc2UgPSB3aXNwX3J1bnRpbWUuaXNGYWxzZTtcbiAgICB2YXIgaXNOaWwgPSB3aXNwX3J1bnRpbWUuaXNOaWw7XG4gICAgdmFyIGlzUmVQYXR0ZXJuID0gd2lzcF9ydW50aW1lLmlzUmVQYXR0ZXJuO1xuICAgIHZhciBpbmMgPSB3aXNwX3J1bnRpbWUuaW5jO1xuICAgIHZhciBkZWMgPSB3aXNwX3J1bnRpbWUuZGVjO1xuICAgIHZhciBzdHIgPSB3aXNwX3J1bnRpbWUuc3RyO1xuICAgIHZhciBjaGFyID0gd2lzcF9ydW50aW1lLmNoYXI7XG4gICAgdmFyIGludCA9IHdpc3BfcnVudGltZS5pbnQ7XG4gICAgdmFyIGlzRXF1YWwgPSB3aXNwX3J1bnRpbWUuaXNFcXVhbDtcbiAgICB2YXIgaXNTdHJpY3RFcXVhbCA9IHdpc3BfcnVudGltZS5pc1N0cmljdEVxdWFsO1xuICAgIHZhciB3aXNwX3N0cmluZyA9IHJlcXVpcmUoJy4vLi4vLi4vc3RyaW5nJyk7XG4gICAgdmFyIHNwbGl0ID0gd2lzcF9zdHJpbmcuc3BsaXQ7XG4gICAgdmFyIGpvaW4gPSB3aXNwX3N0cmluZy5qb2luO1xuICAgIHZhciB1cHBlckNhc2UgPSB3aXNwX3N0cmluZy51cHBlckNhc2U7XG4gICAgdmFyIHJlcGxhY2UgPSB3aXNwX3N0cmluZy5yZXBsYWNlO1xuICAgIHZhciB3aXNwX2V4cGFuZGVyID0gcmVxdWlyZSgnLi8uLi8uLi9leHBhbmRlcicpO1xuICAgIHZhciBpbnN0YWxsTWFjcm8gPSB3aXNwX2V4cGFuZGVyLmluc3RhbGxNYWNybztcbiAgICB2YXIgZXNjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XG4gICAgdmFyIGdlbmVyYXRlID0gZXNjb2RlZ2VuLmdlbmVyYXRlO1xufVxudmFyIF9fdW5pcXVlQ2hhcl9fID0gZXhwb3J0cy5fX3VuaXF1ZUNoYXJfXyA9ICdcXHhGOCc7XG52YXIgdG9DYW1lbEpvaW4gPSBleHBvcnRzLnRvQ2FtZWxKb2luID0gZnVuY3Rpb24gdG9DYW1lbEpvaW4ocHJlZml4LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICcnICsgcHJlZml4ICsgKCFpc0VtcHR5KHByZWZpeCkgJiYgIWlzRW1wdHkoa2V5KSA/ICcnICsgdXBwZXJDYXNlKChrZXkgfHwgMClbMF0pICsgc3VicyhrZXksIDEpIDoga2V5KTtcbiAgICB9O1xudmFyIHRyYW5zbGF0ZUlkZW50aWZpZXJXb3JkID0gZXhwb3J0cy50cmFuc2xhdGVJZGVudGlmaWVyV29yZCA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUlkZW50aWZpZXJXb3JkKGZvcm0pIHtcbiAgICAgICAgdmFyIGlkID0gbmFtZShmb3JtKTtcbiAgICAgICAgaWQgPSBpZCA9PT0gJyonID8gJ211bHRpcGx5JyA6IGlkID09PSAnLycgPyAnZGl2aWRlJyA6IGlkID09PSAnKycgPyAnc3VtJyA6IGlkID09PSAnLScgPyAnc3VidHJhY3QnIDogaWQgPT09ICc9JyA/ICdlcXVhbD8nIDogaWQgPT09ICc9PScgPyAnc3RyaWN0LWVxdWFsPycgOiBpZCA9PT0gJzw9JyA/ICdub3QtZ3JlYXRlci10aGFuJyA6IGlkID09PSAnPj0nID8gJ25vdC1sZXNzLXRoYW4nIDogaWQgPT09ICc+JyA/ICdncmVhdGVyLXRoYW4nIDogaWQgPT09ICc8JyA/ICdsZXNzLXRoYW4nIDogJ2Vsc2UnID8gaWQgOiB2b2lkIDA7XG4gICAgICAgIGlkID0gam9pbignXycsIHNwbGl0KGlkLCAnKicpKTtcbiAgICAgICAgaWQgPSBqb2luKCctdG8tJywgc3BsaXQoaWQsICctPicpKTtcbiAgICAgICAgaWQgPSBqb2luKHNwbGl0KGlkLCAnIScpKTtcbiAgICAgICAgaWQgPSBqb2luKCckJywgc3BsaXQoaWQsICclJykpO1xuICAgICAgICBpZCA9IGpvaW4oJy1lcXVhbC0nLCBzcGxpdChpZCwgJz0nKSk7XG4gICAgICAgIGlkID0gam9pbignLXBsdXMtJywgc3BsaXQoaWQsICcrJykpO1xuICAgICAgICBpZCA9IGpvaW4oJy1hbmQtJywgc3BsaXQoaWQsICcmJykpO1xuICAgICAgICBpZCA9IGxhc3QoaWQpID09PSAnPycgPyAnJyArICdpcy0nICsgc3VicyhpZCwgMCwgZGVjKGNvdW50KGlkKSkpIDogaWQ7XG4gICAgICAgIGlkID0gcmVkdWNlKHRvQ2FtZWxKb2luLCAnJywgc3BsaXQoaWQsICctJykpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbnZhciB0cmFuc2xhdGVJZGVudGlmaWVyID0gZXhwb3J0cy50cmFuc2xhdGVJZGVudGlmaWVyID0gZnVuY3Rpb24gdHJhbnNsYXRlSWRlbnRpZmllcihmb3JtKSB7XG4gICAgICAgIHJldHVybiBqb2luKCcuJywgbWFwKHRyYW5zbGF0ZUlkZW50aWZpZXJXb3JkLCBzcGxpdChuYW1lKGZvcm0pLCAnLicpKSk7XG4gICAgfTtcbnZhciBlcnJvckFyZ0NvdW50ID0gZXhwb3J0cy5lcnJvckFyZ0NvdW50ID0gZnVuY3Rpb24gZXJyb3JBcmdDb3VudChjYWxsZWUsIG4pIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcignJyArICdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgnICsgbiArICcpIHBhc3NlZCB0bzogJyArIGNhbGxlZSk7XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbnZhciBpbmhlcml0TG9jYXRpb24gPSBleHBvcnRzLmluaGVyaXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGluaGVyaXRMb2NhdGlvbihib2R5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnTDuDEgPSAoKGZpcnN0KGJvZHkpIHx8IDApWydsb2MnXSB8fCAwKVsnc3RhcnQnXTtcbiAgICAgICAgICAgIHZhciBlbmTDuDEgPSAoKGxhc3QoYm9keSkgfHwgMClbJ2xvYyddIHx8IDApWydlbmQnXTtcbiAgICAgICAgICAgIHJldHVybiAhKGlzTmlsKHN0YXJ0w7gxKSB8fCBpc05pbChlbmTDuDEpKSA/IHtcbiAgICAgICAgICAgICAgICAnc3RhcnQnOiBzdGFydMO4MSxcbiAgICAgICAgICAgICAgICAnZW5kJzogZW5kw7gxXG4gICAgICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciB3cml0ZUxvY2F0aW9uID0gZXhwb3J0cy53cml0ZUxvY2F0aW9uID0gZnVuY3Rpb24gd3JpdGVMb2NhdGlvbihmb3JtLCBvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGHDuDEgPSBtZXRhKGZvcm0pO1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZMO4MSA9IG1ldGEob3JpZ2luYWwpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0w7gxID0gKGZvcm0gfHwgMClbJ3N0YXJ0J10gfHwgKGRhdGHDuDEgfHwgMClbJ3N0YXJ0J10gfHwgKGluaGVyaXRlZMO4MSB8fCAwKVsnc3RhcnQnXTtcbiAgICAgICAgICAgIHZhciBlbmTDuDEgPSAoZm9ybSB8fCAwKVsnZW5kJ10gfHwgKGRhdGHDuDEgfHwgMClbJ2VuZCddIHx8IChpbmhlcml0ZWTDuDEgfHwgMClbJ2VuZCddO1xuICAgICAgICAgICAgcmV0dXJuICFpc05pbChzdGFydMO4MSkgPyB7XG4gICAgICAgICAgICAgICAgJ2xvYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXJ0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUnOiBpbmMoKHN0YXJ0w7gxIHx8IDApWydsaW5lJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbic6IChzdGFydMO4MSB8fCAwKVsnY29sdW1uJ11cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2VuZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lJzogaW5jKChlbmTDuDEgfHwgMClbJ2xpbmUnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sdW1uJzogKGVuZMO4MSB8fCAwKVsnY29sdW1uJ11cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiB7fTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgX193cml0ZXJzX18gPSBleHBvcnRzLl9fd3JpdGVyc19fID0ge307XG52YXIgaW5zdGFsbFdyaXRlciA9IGV4cG9ydHMuaW5zdGFsbFdyaXRlciA9IGZ1bmN0aW9uIGluc3RhbGxXcml0ZXIob3AsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gKF9fd3JpdGVyc19fIHx8IDApW29wXSA9IHdyaXRlcjtcbiAgICB9O1xudmFyIHdyaXRlT3AgPSBleHBvcnRzLndyaXRlT3AgPSBmdW5jdGlvbiB3cml0ZU9wKG9wLCBmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVyw7gxID0gKF9fd3JpdGVyc19fIHx8IDApW29wXTtcbiAgICAgICAgICAgICF3cml0ZXLDuDEgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCcnICsgJ0Fzc2VydCBmYWlsZWQ6ICcgKyAoJycgKyAnVW5zdXBwb3J0ZWQgb3BlcmF0aW9uOiAnICsgb3ApICsgJ3dyaXRlcicpO1xuICAgICAgICAgICAgfSkoKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBjb25qKHdyaXRlTG9jYXRpb24oKGZvcm0gfHwgMClbJ2Zvcm0nXSwgKGZvcm0gfHwgMClbJ29yaWdpbmFsLWZvcm0nXSksIHdyaXRlcsO4MShmb3JtKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIF9fc3BlY2lhbHNfXyA9IGV4cG9ydHMuX19zcGVjaWFsc19fID0ge307XG52YXIgaW5zdGFsbFNwZWNpYWwgPSBleHBvcnRzLmluc3RhbGxTcGVjaWFsID0gZnVuY3Rpb24gaW5zdGFsbFNwZWNpYWwob3AsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gKF9fc3BlY2lhbHNfXyB8fCAwKVtuYW1lKG9wKV0gPSB3cml0ZXI7XG4gICAgfTtcbnZhciB3cml0ZVNwZWNpYWwgPSBleHBvcnRzLndyaXRlU3BlY2lhbCA9IGZ1bmN0aW9uIHdyaXRlU3BlY2lhbCh3cml0ZXIsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGNvbmood3JpdGVMb2NhdGlvbigoZm9ybSB8fCAwKVsnZm9ybSddLCAoZm9ybSB8fCAwKVsnb3JpZ2luYWwtZm9ybSddKSwgd3JpdGVyLmFwcGx5KHZvaWQgMCwgKGZvcm0gfHwgMClbJ3BhcmFtcyddKSk7XG4gICAgfTtcbnZhciB3cml0ZU5pbCA9IGV4cG9ydHMud3JpdGVOaWwgPSBmdW5jdGlvbiB3cml0ZU5pbChmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICAgICAgJ29wZXJhdG9yJzogJ3ZvaWQnLFxuICAgICAgICAgICAgJ2FyZ3VtZW50Jzoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICAgICd2YWx1ZSc6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHJlZml4JzogdHJ1ZVxuICAgICAgICB9O1xuICAgIH07XG5pbnN0YWxsV3JpdGVyKCduaWwnLCB3cml0ZU5pbCk7XG52YXIgd3JpdGVMaXRlcmFsID0gZXhwb3J0cy53cml0ZUxpdGVyYWwgPSBmdW5jdGlvbiB3cml0ZUxpdGVyYWwoZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiAnTGl0ZXJhbCcsXG4gICAgICAgICAgICAndmFsdWUnOiBmb3JtXG4gICAgICAgIH07XG4gICAgfTtcbnZhciB3cml0ZUxpc3QgPSBleHBvcnRzLndyaXRlTGlzdCA9IGZ1bmN0aW9uIHdyaXRlTGlzdChmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnY2FsbGVlJzogd3JpdGUoe1xuICAgICAgICAgICAgICAgICdvcCc6ICd2YXInLFxuICAgICAgICAgICAgICAgICdmb3JtJzogc3ltYm9sKHZvaWQgMCwgJ2xpc3QnKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAnYXJndW1lbnRzJzogbWFwKHdyaXRlLCAoZm9ybSB8fCAwKVsnaXRlbXMnXSlcbiAgICAgICAgfTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignbGlzdCcsIHdyaXRlTGlzdCk7XG52YXIgd3JpdGVTeW1ib2wgPSBleHBvcnRzLndyaXRlU3ltYm9sID0gZnVuY3Rpb24gd3JpdGVTeW1ib2woZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICAgICAgJ2NhbGxlZSc6IHdyaXRlKHtcbiAgICAgICAgICAgICAgICAnb3AnOiAndmFyJyxcbiAgICAgICAgICAgICAgICAnZm9ybSc6IHN5bWJvbCh2b2lkIDAsICdzeW1ib2wnKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAnYXJndW1lbnRzJzogW1xuICAgICAgICAgICAgICAgIHdyaXRlQ29uc3RhbnQoKGZvcm0gfHwgMClbJ25hbWVzcGFjZSddKSxcbiAgICAgICAgICAgICAgICB3cml0ZUNvbnN0YW50KChmb3JtIHx8IDApWyduYW1lJ10pXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfTtcbmluc3RhbGxXcml0ZXIoJ3N5bWJvbCcsIHdyaXRlU3ltYm9sKTtcbnZhciB3cml0ZUNvbnN0YW50ID0gZXhwb3J0cy53cml0ZUNvbnN0YW50ID0gZnVuY3Rpb24gd3JpdGVDb25zdGFudChmb3JtKSB7XG4gICAgICAgIHJldHVybiBpc05pbChmb3JtKSA/IHdyaXRlTmlsKGZvcm0pIDogaXNLZXl3b3JkKGZvcm0pID8gd3JpdGVMaXRlcmFsKG5hbWUoZm9ybSkpIDogaXNOdW1iZXIoZm9ybSkgPyB3cml0ZU51bWJlcihmb3JtLnZhbHVlT2YoKSkgOiBpc1N0cmluZyhmb3JtKSA/IHdyaXRlU3RyaW5nKGZvcm0pIDogJ2Vsc2UnID8gd3JpdGVMaXRlcmFsKGZvcm0pIDogdm9pZCAwO1xuICAgIH07XG5pbnN0YWxsV3JpdGVyKCdjb25zdGFudCcsIGZ1bmN0aW9uICgkMSkge1xuICAgIHJldHVybiB3cml0ZUNvbnN0YW50KCgkMSB8fCAwKVsnZm9ybSddKTtcbn0pO1xudmFyIHdyaXRlU3RyaW5nID0gZXhwb3J0cy53cml0ZVN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlU3RyaW5nKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0eXBlJzogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgJ3ZhbHVlJzogJycgKyBmb3JtXG4gICAgICAgIH07XG4gICAgfTtcbnZhciB3cml0ZU51bWJlciA9IGV4cG9ydHMud3JpdGVOdW1iZXIgPSBmdW5jdGlvbiB3cml0ZU51bWJlcihmb3JtKSB7XG4gICAgICAgIHJldHVybiBmb3JtIDwgMCA/IHtcbiAgICAgICAgICAgICd0eXBlJzogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnb3BlcmF0b3InOiAnLScsXG4gICAgICAgICAgICAncHJlZml4JzogdHJ1ZSxcbiAgICAgICAgICAgICdhcmd1bWVudCc6IHdyaXRlTnVtYmVyKGZvcm0gKiAtMSlcbiAgICAgICAgfSA6IHdyaXRlTGl0ZXJhbChmb3JtKTtcbiAgICB9O1xudmFyIHdyaXRlS2V5d29yZCA9IGV4cG9ydHMud3JpdGVLZXl3b3JkID0gZnVuY3Rpb24gd3JpdGVLZXl3b3JkKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0eXBlJzogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgJ3ZhbHVlJzogKGZvcm0gfHwgMClbJ2Zvcm0nXVxuICAgICAgICB9O1xuICAgIH07XG5pbnN0YWxsV3JpdGVyKCdrZXl3b3JkJywgd3JpdGVLZXl3b3JkKTtcbnZhciB0b0lkZW50aWZpZXIgPSBleHBvcnRzLnRvSWRlbnRpZmllciA9IGZ1bmN0aW9uIHRvSWRlbnRpZmllcihmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICduYW1lJzogdHJhbnNsYXRlSWRlbnRpZmllcihmb3JtKVxuICAgICAgICB9O1xuICAgIH07XG52YXIgd3JpdGVCaW5kaW5nVmFyID0gZXhwb3J0cy53cml0ZUJpbmRpbmdWYXIgPSBmdW5jdGlvbiB3cml0ZUJpbmRpbmdWYXIoZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkw7gxID0gbmFtZSgoZm9ybSB8fCAwKVsnaWQnXSk7XG4gICAgICAgICAgICByZXR1cm4gY29uaih0b0lkZW50aWZpZXIoKGZvcm0gfHwgMClbJ3NoYWRvdyddID8gJycgKyB0cmFuc2xhdGVJZGVudGlmaWVyKGlkw7gxKSArIF9fdW5pcXVlQ2hhcl9fICsgKGZvcm0gfHwgMClbJ2RlcHRoJ10gOiBpZMO4MSksIHdyaXRlTG9jYXRpb24oKGZvcm0gfHwgMClbJ2lkJ10pKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgd3JpdGVWYXIgPSBleHBvcnRzLndyaXRlVmFyID0gZnVuY3Rpb24gd3JpdGVWYXIobm9kZSkge1xuICAgICAgICByZXR1cm4gaXNFcXVhbCgnYmluZGluZycsICgobm9kZSB8fCAwKVsnYmluZGluZyddIHx8IDApWyd0eXBlJ10pID8gY29uaih3cml0ZUJpbmRpbmdWYXIoKG5vZGUgfHwgMClbJ2JpbmRpbmcnXSksIHdyaXRlTG9jYXRpb24oKG5vZGUgfHwgMClbJ2Zvcm0nXSkpIDogY29uaih3cml0ZUxvY2F0aW9uKChub2RlIHx8IDApWydmb3JtJ10pLCB0b0lkZW50aWZpZXIobmFtZSgobm9kZSB8fCAwKVsnZm9ybSddKSkpO1xuICAgIH07XG5pbnN0YWxsV3JpdGVyKCd2YXInLCB3cml0ZVZhcik7XG5pbnN0YWxsV3JpdGVyKCdwYXJhbScsIHdyaXRlVmFyKTtcbnZhciB3cml0ZUludm9rZSA9IGV4cG9ydHMud3JpdGVJbnZva2UgPSBmdW5jdGlvbiB3cml0ZUludm9rZShmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnY2FsbGVlJzogd3JpdGUoKGZvcm0gfHwgMClbJ2NhbGxlZSddKSxcbiAgICAgICAgICAgICdhcmd1bWVudHMnOiBtYXAod3JpdGUsIChmb3JtIHx8IDApWydwYXJhbXMnXSlcbiAgICAgICAgfTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignaW52b2tlJywgd3JpdGVJbnZva2UpO1xudmFyIHdyaXRlVmVjdG9yID0gZXhwb3J0cy53cml0ZVZlY3RvciA9IGZ1bmN0aW9uIHdyaXRlVmVjdG9yKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0eXBlJzogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnZWxlbWVudHMnOiBtYXAod3JpdGUsIChmb3JtIHx8IDApWydpdGVtcyddKVxuICAgICAgICB9O1xuICAgIH07XG5pbnN0YWxsV3JpdGVyKCd2ZWN0b3InLCB3cml0ZVZlY3Rvcik7XG52YXIgd3JpdGVEaWN0aW9uYXJ5ID0gZXhwb3J0cy53cml0ZURpY3Rpb25hcnkgPSBmdW5jdGlvbiB3cml0ZURpY3Rpb25hcnkoZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXPDuDEgPSBwYXJ0aXRpb24oMiwgaW50ZXJsZWF2ZSgoZm9ybSB8fCAwKVsna2V5cyddLCAoZm9ybSB8fCAwKVsndmFsdWVzJ10pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiBtYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXnDuDEgPSBmaXJzdChwYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZcO4MSA9IHNlY29uZChwYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2tpbmQnOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdrZXknOiBpc0VxdWFsKCdzeW1ib2wnLCAoa2V5w7gxIHx8IDApWydvcCddKSA/IHdyaXRlQ29uc3RhbnQoJycgKyAoa2V5w7gxIHx8IDApWydmb3JtJ10pIDogd3JpdGUoa2V5w7gxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiB3cml0ZSh2YWx1ZcO4MSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LCBwcm9wZXJ0aWVzw7gxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsV3JpdGVyKCdkaWN0aW9uYXJ5Jywgd3JpdGVEaWN0aW9uYXJ5KTtcbnZhciB3cml0ZUV4cG9ydCA9IGV4cG9ydHMud3JpdGVFeHBvcnQgPSBmdW5jdGlvbiB3cml0ZUV4cG9ydChmb3JtKSB7XG4gICAgICAgIHJldHVybiB3cml0ZSh7XG4gICAgICAgICAgICAnb3AnOiAnc2V0IScsXG4gICAgICAgICAgICAndGFyZ2V0Jzoge1xuICAgICAgICAgICAgICAgICdvcCc6ICdtZW1iZXItZXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgJ2NvbXB1dGVkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ3RhcmdldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ29wJzogJ3ZhcicsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtJzogd2l0aE1ldGEoc3ltYm9sKHZvaWQgMCwgJ2V4cG9ydHMnKSwgbWV0YSgoKGZvcm0gfHwgMClbJ2lkJ10gfHwgMClbJ2Zvcm0nXSkpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydHknOiAoZm9ybSB8fCAwKVsnaWQnXSxcbiAgICAgICAgICAgICAgICAnZm9ybSc6ICgoZm9ybSB8fCAwKVsnaWQnXSB8fCAwKVsnZm9ybSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3ZhbHVlJzogKGZvcm0gfHwgMClbJ2luaXQnXSxcbiAgICAgICAgICAgICdmb3JtJzogKChmb3JtIHx8IDApWydpZCddIHx8IDApWydmb3JtJ11cbiAgICAgICAgfSk7XG4gICAgfTtcbnZhciB3cml0ZURlZiA9IGV4cG9ydHMud3JpdGVEZWYgPSBmdW5jdGlvbiB3cml0ZURlZihmb3JtKSB7XG4gICAgICAgIHJldHVybiBjb25qKHtcbiAgICAgICAgICAgICd0eXBlJzogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgJ2tpbmQnOiAndmFyJyxcbiAgICAgICAgICAgICdkZWNsYXJhdGlvbnMnOiBbY29uaih7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgICAgICAgICAgICAgICdpZCc6IHdyaXRlKChmb3JtIHx8IDApWydpZCddKSxcbiAgICAgICAgICAgICAgICAgICAgJ2luaXQnOiBjb25qKChmb3JtIHx8IDApWydleHBvcnQnXSA/IHdyaXRlRXhwb3J0KGZvcm0pIDogd3JpdGUoKGZvcm0gfHwgMClbJ2luaXQnXSkpXG4gICAgICAgICAgICAgICAgfSwgd3JpdGVMb2NhdGlvbigoKGZvcm0gfHwgMClbJ2lkJ10gfHwgMClbJ2Zvcm0nXSkpXVxuICAgICAgICB9LCB3cml0ZUxvY2F0aW9uKChmb3JtIHx8IDApWydmb3JtJ10sIChmb3JtIHx8IDApWydvcmlnaW5hbC1mb3JtJ10pKTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignZGVmJywgd3JpdGVEZWYpO1xudmFyIHdyaXRlQmluZGluZyA9IGV4cG9ydHMud3JpdGVCaW5kaW5nID0gZnVuY3Rpb24gd3JpdGVCaW5kaW5nKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZMO4MSA9IHdyaXRlQmluZGluZ1Zhcihmb3JtKTtcbiAgICAgICAgICAgIHZhciBpbml0w7gxID0gd3JpdGUoKGZvcm0gfHwgMClbJ2luaXQnXSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgICAgICdraW5kJzogJ3ZhcicsXG4gICAgICAgICAgICAgICAgJ2xvYyc6IGluaGVyaXRMb2NhdGlvbihbXG4gICAgICAgICAgICAgICAgICAgIGlkw7gxLFxuICAgICAgICAgICAgICAgICAgICBpbml0w7gxXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgJ2RlY2xhcmF0aW9ucyc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWTDuDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdCc6IGluaXTDuDFcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignYmluZGluZycsIHdyaXRlQmluZGluZyk7XG52YXIgd3JpdGVUaHJvdyA9IGV4cG9ydHMud3JpdGVUaHJvdyA9IGZ1bmN0aW9uIHdyaXRlVGhyb3coZm9ybSkge1xuICAgICAgICByZXR1cm4gdG9FeHByZXNzaW9uKGNvbmooe1xuICAgICAgICAgICAgJ3R5cGUnOiAnVGhyb3dTdGF0ZW1lbnQnLFxuICAgICAgICAgICAgJ2FyZ3VtZW50Jzogd3JpdGUoKGZvcm0gfHwgMClbJ3Rocm93J10pXG4gICAgICAgIH0sIHdyaXRlTG9jYXRpb24oKGZvcm0gfHwgMClbJ2Zvcm0nXSwgKGZvcm0gfHwgMClbJ29yaWdpbmFsLWZvcm0nXSkpKTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcigndGhyb3cnLCB3cml0ZVRocm93KTtcbnZhciB3cml0ZU5ldyA9IGV4cG9ydHMud3JpdGVOZXcgPSBmdW5jdGlvbiB3cml0ZU5ldyhmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICdjYWxsZWUnOiB3cml0ZSgoZm9ybSB8fCAwKVsnY29uc3RydWN0b3InXSksXG4gICAgICAgICAgICAnYXJndW1lbnRzJzogbWFwKHdyaXRlLCAoZm9ybSB8fCAwKVsncGFyYW1zJ10pXG4gICAgICAgIH07XG4gICAgfTtcbmluc3RhbGxXcml0ZXIoJ25ldycsIHdyaXRlTmV3KTtcbnZhciB3cml0ZVNldCA9IGV4cG9ydHMud3JpdGVTZXQgPSBmdW5jdGlvbiB3cml0ZVNldChmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnb3BlcmF0b3InOiAnPScsXG4gICAgICAgICAgICAnbGVmdCc6IHdyaXRlKChmb3JtIHx8IDApWyd0YXJnZXQnXSksXG4gICAgICAgICAgICAncmlnaHQnOiB3cml0ZSgoZm9ybSB8fCAwKVsndmFsdWUnXSlcbiAgICAgICAgfTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignc2V0IScsIHdyaXRlU2V0KTtcbnZhciB3cml0ZUFnZXQgPSBleHBvcnRzLndyaXRlQWdldCA9IGZ1bmN0aW9uIHdyaXRlQWdldChmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICdjb21wdXRlZCc6IChmb3JtIHx8IDApWydjb21wdXRlZCddLFxuICAgICAgICAgICAgJ29iamVjdCc6IHdyaXRlKChmb3JtIHx8IDApWyd0YXJnZXQnXSksXG4gICAgICAgICAgICAncHJvcGVydHknOiB3cml0ZSgoZm9ybSB8fCAwKVsncHJvcGVydHknXSlcbiAgICAgICAgfTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignbWVtYmVyLWV4cHJlc3Npb24nLCB3cml0ZUFnZXQpO1xudmFyIF9fc3RhdGVtZW50c19fID0gZXhwb3J0cy5fX3N0YXRlbWVudHNfXyA9IHtcbiAgICAgICAgJ0VtcHR5U3RhdGVtZW50JzogdHJ1ZSxcbiAgICAgICAgJ0Jsb2NrU3RhdGVtZW50JzogdHJ1ZSxcbiAgICAgICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOiB0cnVlLFxuICAgICAgICAnSWZTdGF0ZW1lbnQnOiB0cnVlLFxuICAgICAgICAnTGFiZWxlZFN0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdCcmVha1N0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdDb250aW51ZVN0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdTd2l0Y2hTdGF0ZW1lbnQnOiB0cnVlLFxuICAgICAgICAnUmV0dXJuU3RhdGVtZW50JzogdHJ1ZSxcbiAgICAgICAgJ1Rocm93U3RhdGVtZW50JzogdHJ1ZSxcbiAgICAgICAgJ1RyeVN0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdXaGlsZVN0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdEb1doaWxlU3RhdGVtZW50JzogdHJ1ZSxcbiAgICAgICAgJ0ZvclN0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdGb3JJblN0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdGb3JPZlN0YXRlbWVudCc6IHRydWUsXG4gICAgICAgICdMZXRTdGF0ZW1lbnQnOiB0cnVlLFxuICAgICAgICAnVmFyaWFibGVEZWNsYXJhdGlvbic6IHRydWUsXG4gICAgICAgICdGdW5jdGlvbkRlY2xhcmF0aW9uJzogdHJ1ZVxuICAgIH07XG52YXIgd3JpdGVTdGF0ZW1lbnQgPSBleHBvcnRzLndyaXRlU3RhdGVtZW50ID0gZnVuY3Rpb24gd3JpdGVTdGF0ZW1lbnQoZm9ybSkge1xuICAgICAgICByZXR1cm4gdG9TdGF0ZW1lbnQod3JpdGUoZm9ybSkpO1xuICAgIH07XG52YXIgdG9TdGF0ZW1lbnQgPSBleHBvcnRzLnRvU3RhdGVtZW50ID0gZnVuY3Rpb24gdG9TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gKF9fc3RhdGVtZW50c19fIHx8IDApWyhub2RlIHx8IDApWyd0eXBlJ11dID8gbm9kZSA6IHtcbiAgICAgICAgICAgICd0eXBlJzogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICAgICAgJ2V4cHJlc3Npb24nOiBub2RlLFxuICAgICAgICAgICAgJ2xvYyc6IChub2RlIHx8IDApWydsb2MnXVxuICAgICAgICB9O1xuICAgIH07XG52YXIgdG9SZXR1cm4gPSBleHBvcnRzLnRvUmV0dXJuID0gZnVuY3Rpb24gdG9SZXR1cm4oZm9ybSkge1xuICAgICAgICByZXR1cm4gY29uaih7XG4gICAgICAgICAgICAndHlwZSc6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICAgICAgJ2FyZ3VtZW50Jzogd3JpdGUoZm9ybSlcbiAgICAgICAgfSwgd3JpdGVMb2NhdGlvbigoZm9ybSB8fCAwKVsnZm9ybSddLCAoZm9ybSB8fCAwKVsnb3JpZ2luYWwtZm9ybSddKSk7XG4gICAgfTtcbnZhciB3cml0ZUJvZHkgPSBleHBvcnRzLndyaXRlQm9keSA9IGZ1bmN0aW9uIHdyaXRlQm9keShmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50c8O4MSA9IG1hcCh3cml0ZVN0YXRlbWVudCwgKGZvcm0gfHwgMClbJ3N0YXRlbWVudHMnXSB8fCBbXSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0w7gxID0gKGZvcm0gfHwgMClbJ3Jlc3VsdCddID8gdG9SZXR1cm4oKGZvcm0gfHwgMClbJ3Jlc3VsdCddKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHTDuDEgPyBjb25qKHN0YXRlbWVudHPDuDEsIHJlc3VsdMO4MSkgOiBzdGF0ZW1lbnRzw7gxO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciB0b0Jsb2NrID0gZXhwb3J0cy50b0Jsb2NrID0gZnVuY3Rpb24gdG9CbG9jayhib2R5KSB7XG4gICAgICAgIHJldHVybiBpc1ZlY3Rvcihib2R5KSA/IHtcbiAgICAgICAgICAgICd0eXBlJzogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgICAgICdib2R5JzogYm9keSxcbiAgICAgICAgICAgICdsb2MnOiBpbmhlcml0TG9jYXRpb24oYm9keSlcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICd0eXBlJzogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgICAgICdib2R5JzogW2JvZHldLFxuICAgICAgICAgICAgJ2xvYyc6IChib2R5IHx8IDApWydsb2MnXVxuICAgICAgICB9O1xuICAgIH07XG52YXIgdG9FeHByZXNzaW9uID0gZXhwb3J0cy50b0V4cHJlc3Npb24gPSBmdW5jdGlvbiB0b0V4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBib2R5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0eXBlJzogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICdhcmd1bWVudHMnOiBbXSxcbiAgICAgICAgICAgICdsb2MnOiBpbmhlcml0TG9jYXRpb24oYm9keSksXG4gICAgICAgICAgICAnY2FsbGVlJzogdG9TZXF1ZW5jZShbe1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAnaWQnOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICdwYXJhbXMnOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHRzJzogW10sXG4gICAgICAgICAgICAgICAgICAgICdleHByZXNzaW9uJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdnZW5lcmF0b3InOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3Jlc3QnOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICdib2R5JzogdG9CbG9jayhib2R5KVxuICAgICAgICAgICAgICAgIH1dKVxuICAgICAgICB9O1xuICAgIH07XG52YXIgd3JpdGVEbyA9IGV4cG9ydHMud3JpdGVEbyA9IGZ1bmN0aW9uIHdyaXRlRG8oZm9ybSkge1xuICAgICAgICByZXR1cm4gKG1ldGEoZmlyc3QoKGZvcm0gfHwgMClbJ2Zvcm0nXSkpIHx8IDApWydibG9jayddID8gdG9CbG9jayh3cml0ZUJvZHkoY29uaihmb3JtLCB7XG4gICAgICAgICAgICAncmVzdWx0Jzogdm9pZCAwLFxuICAgICAgICAgICAgJ3N0YXRlbWVudHMnOiBjb25qKChmb3JtIHx8IDApWydzdGF0ZW1lbnRzJ10sIChmb3JtIHx8IDApWydyZXN1bHQnXSlcbiAgICAgICAgfSkpKSA6IHRvRXhwcmVzc2lvbi5hcHBseSh2b2lkIDAsIHdyaXRlQm9keShmb3JtKSk7XG4gICAgfTtcbmluc3RhbGxXcml0ZXIoJ2RvJywgd3JpdGVEbyk7XG52YXIgd3JpdGVJZiA9IGV4cG9ydHMud3JpdGVJZiA9IGZ1bmN0aW9uIHdyaXRlSWYoZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICd0ZXN0Jzogd3JpdGUoKGZvcm0gfHwgMClbJ3Rlc3QnXSksXG4gICAgICAgICAgICAnY29uc2VxdWVudCc6IHdyaXRlKChmb3JtIHx8IDApWydjb25zZXF1ZW50J10pLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZSc6IHdyaXRlKChmb3JtIHx8IDApWydhbHRlcm5hdGUnXSlcbiAgICAgICAgfTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignaWYnLCB3cml0ZUlmKTtcbnZhciB3cml0ZVRyeSA9IGV4cG9ydHMud3JpdGVUcnkgPSBmdW5jdGlvbiB3cml0ZVRyeShmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcsO4MSA9IChmb3JtIHx8IDApWydoYW5kbGVyJ107XG4gICAgICAgICAgICB2YXIgZmluYWxpemVyw7gxID0gKGZvcm0gfHwgMClbJ2ZpbmFsaXplciddO1xuICAgICAgICAgICAgcmV0dXJuIHRvRXhwcmVzc2lvbihjb25qKHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdUcnlTdGF0ZW1lbnQnLFxuICAgICAgICAgICAgICAgICdndWFyZGVkSGFuZGxlcnMnOiBbXSxcbiAgICAgICAgICAgICAgICAnYmxvY2snOiB0b0Jsb2NrKHdyaXRlQm9keSgoZm9ybSB8fCAwKVsnYm9keSddKSksXG4gICAgICAgICAgICAgICAgJ2hhbmRsZXJzJzogaGFuZGxlcsO4MSA/IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdDYXRjaENsYXVzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFyYW0nOiB3cml0ZSgoaGFuZGxlcsO4MSB8fCAwKVsnbmFtZSddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib2R5JzogdG9CbG9jayh3cml0ZUJvZHkoaGFuZGxlcsO4MSkpXG4gICAgICAgICAgICAgICAgICAgIH1dIDogW10sXG4gICAgICAgICAgICAgICAgJ2ZpbmFsaXplcic6IGZpbmFsaXplcsO4MSA/IHRvQmxvY2sod3JpdGVCb2R5KGZpbmFsaXplcsO4MSkpIDogIWhhbmRsZXLDuDEgPyB0b0Jsb2NrKFtdKSA6ICdlbHNlJyA/IHZvaWQgMCA6IHZvaWQgMFxuICAgICAgICAgICAgfSwgd3JpdGVMb2NhdGlvbigoZm9ybSB8fCAwKVsnZm9ybSddLCAoZm9ybSB8fCAwKVsnb3JpZ2luYWwtZm9ybSddKSkpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxXcml0ZXIoJ3RyeScsIHdyaXRlVHJ5KTtcbnZhciB3cml0ZUJpbmRpbmdWYWx1ZSA9IGZ1bmN0aW9uIHdyaXRlQmluZGluZ1ZhbHVlKGZvcm0pIHtcbiAgICByZXR1cm4gd3JpdGUoKGZvcm0gfHwgMClbJ2luaXQnXSk7XG59O1xudmFyIHdyaXRlQmluZGluZ1BhcmFtID0gZnVuY3Rpb24gd3JpdGVCaW5kaW5nUGFyYW0oZm9ybSkge1xuICAgIHJldHVybiB3cml0ZVZhcih7ICdmb3JtJzogKGZvcm0gfHwgMClbJ25hbWUnXSB9KTtcbn07XG52YXIgd3JpdGVCaW5kaW5nID0gZXhwb3J0cy53cml0ZUJpbmRpbmcgPSBmdW5jdGlvbiB3cml0ZUJpbmRpbmcoZm9ybSkge1xuICAgICAgICByZXR1cm4gd3JpdGUoe1xuICAgICAgICAgICAgJ29wJzogJ2RlZicsXG4gICAgICAgICAgICAndmFyJzogZm9ybSxcbiAgICAgICAgICAgICdpbml0JzogKGZvcm0gfHwgMClbJ2luaXQnXSxcbiAgICAgICAgICAgICdmb3JtJzogZm9ybVxuICAgICAgICB9KTtcbiAgICB9O1xudmFyIHdyaXRlTGV0ID0gZXhwb3J0cy53cml0ZUxldCA9IGZ1bmN0aW9uIHdyaXRlTGV0KGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gY29uaihmb3JtLCB7ICdzdGF0ZW1lbnRzJzogdmVjKGNvbmNhdCgoZm9ybSB8fCAwKVsnYmluZGluZ3MnXSwgKGZvcm0gfHwgMClbJ3N0YXRlbWVudHMnXSkpIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvSWlmZSh0b0Jsb2NrKHdyaXRlQm9keShib2R5w7gxKSkpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxXcml0ZXIoJ2xldCcsIHdyaXRlTGV0KTtcbnZhciB0b1JlYmluZCA9IGV4cG9ydHMudG9SZWJpbmQgPSBmdW5jdGlvbiB0b1JlYmluZChmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgIHZhciByZXN1bHTDuDEgPSBbXTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nc8O4MSA9IChmb3JtIHx8IDApWydiaW5kaW5ncyddO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gaXNFbXB0eShiaW5kaW5nc8O4MSkgPyByZXN1bHTDuDEgOiAobG9vcFswXSA9IGNvbmoocmVzdWx0w7gxLCB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgJ29wZXJhdG9yJzogJz0nLFxuICAgICAgICAgICAgICAgICAgICAnbGVmdCc6IHdyaXRlQmluZGluZ1ZhcihmaXJzdChiaW5kaW5nc8O4MSkpLFxuICAgICAgICAgICAgICAgICAgICAncmlnaHQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb21wdXRlZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogJ2xvb3AnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IGNvdW50KHJlc3VsdMO4MSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCBsb29wWzFdID0gcmVzdChiaW5kaW5nc8O4MSksIGxvb3ApO1xuICAgICAgICAgICAgfSB3aGlsZSAocmVzdWx0w7gxID0gbG9vcFswXSwgYmluZGluZ3PDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHRvU2VxdWVuY2UgPSBleHBvcnRzLnRvU2VxdWVuY2UgPSBmdW5jdGlvbiB0b1NlcXVlbmNlKGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICAgICAgJ2V4cHJlc3Npb25zJzogZXhwcmVzc2lvbnNcbiAgICAgICAgfTtcbiAgICB9O1xudmFyIHRvSWlmZSA9IGV4cG9ydHMudG9JaWZlID0gZnVuY3Rpb24gdG9JaWZlKGJvZHksIGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnYXJndW1lbnRzJzogW3sgJ3R5cGUnOiAnVGhpc0V4cHJlc3Npb24nIH1dLFxuICAgICAgICAgICAgJ2NhbGxlZSc6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAnY29tcHV0ZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgJ3BhcmFtcyc6IFtdLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdHMnOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgJ2V4cHJlc3Npb24nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ2dlbmVyYXRvcic6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAncmVzdCc6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgJ2JvZHknOiBib2R5XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydHknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ICdjYWxsJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xudmFyIHRvTG9vcEluaXQgPSBleHBvcnRzLnRvTG9vcEluaXQgPSBmdW5jdGlvbiB0b0xvb3BJbml0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgICAgICAna2luZCc6ICd2YXInLFxuICAgICAgICAgICAgJ2RlY2xhcmF0aW9ucyc6IFt7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgICAgICAgICAgICAgICdpZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiAncmVjdXInXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdpbml0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ICdsb29wJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9O1xudmFyIHRvRG9XaGlsZSA9IGV4cG9ydHMudG9Eb1doaWxlID0gZnVuY3Rpb24gdG9Eb1doaWxlKGJvZHksIHRlc3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0eXBlJzogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICAgICAgJ2JvZHknOiBib2R5LFxuICAgICAgICAgICAgJ3Rlc3QnOiB0ZXN0XG4gICAgICAgIH07XG4gICAgfTtcbnZhciB0b1NldFJlY3VyID0gZXhwb3J0cy50b1NldFJlY3VyID0gZnVuY3Rpb24gdG9TZXRSZWN1cihmb3JtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnb3BlcmF0b3InOiAnPScsXG4gICAgICAgICAgICAnbGVmdCc6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdyZWN1cidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmlnaHQnOiB3cml0ZShmb3JtKVxuICAgICAgICB9O1xuICAgIH07XG52YXIgdG9Mb29wID0gZXhwb3J0cy50b0xvb3AgPSBmdW5jdGlvbiB0b0xvb3AoZm9ybSkge1xuICAgICAgICByZXR1cm4gdG9TZXF1ZW5jZShjb25qKHRvUmViaW5kKGZvcm0pLCB7XG4gICAgICAgICAgICAndHlwZSc6ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICdvcGVyYXRvcic6ICc9PT0nLFxuICAgICAgICAgICAgJ2xlZnQnOiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAncmVjdXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2xvb3AnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9O1xudmFyIHdyaXRlTG9vcCA9IGV4cG9ydHMud3JpdGVMb29wID0gZnVuY3Rpb24gd3JpdGVMb29wKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZW1lbnRzw7gxID0gKGZvcm0gfHwgMClbJ3N0YXRlbWVudHMnXTtcbiAgICAgICAgICAgIHZhciByZXN1bHTDuDEgPSAoZm9ybSB8fCAwKVsncmVzdWx0J107XG4gICAgICAgICAgICB2YXIgYmluZGluZ3PDuDEgPSAoZm9ybSB8fCAwKVsnYmluZGluZ3MnXTtcbiAgICAgICAgICAgIHZhciBsb29wQm9kecO4MSA9IGNvbmoobWFwKHdyaXRlU3RhdGVtZW50LCBzdGF0ZW1lbnRzw7gxKSwgdG9TdGF0ZW1lbnQodG9TZXRSZWN1cihyZXN1bHTDuDEpKSk7XG4gICAgICAgICAgICB2YXIgYm9kecO4MSA9IGNvbmNhdChbdG9Mb29wSW5pdCgpXSwgbWFwKHdyaXRlLCBiaW5kaW5nc8O4MSksIFt0b0RvV2hpbGUodG9CbG9jayh2ZWMobG9vcEJvZHnDuDEpKSwgdG9Mb29wKGZvcm0pKV0sIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogJ3JlY3VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICByZXR1cm4gdG9JaWZlKHRvQmxvY2sodmVjKGJvZHnDuDEpKSwgc3ltYm9sKHZvaWQgMCwgJ2xvb3AnKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignbG9vcCcsIHdyaXRlTG9vcCk7XG52YXIgdG9SZWN1ciA9IGV4cG9ydHMudG9SZWN1ciA9IGZ1bmN0aW9uIHRvUmVjdXIoZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgcmVzdWx0w7gxID0gW107XG4gICAgICAgICAgICB2YXIgcGFyYW1zw7gxID0gKGZvcm0gfHwgMClbJ3BhcmFtcyddO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gaXNFbXB0eShwYXJhbXPDuDEpID8gcmVzdWx0w7gxIDogKGxvb3BbMF0gPSBjb25qKHJlc3VsdMO4MSwge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICdvcGVyYXRvcic6ICc9JyxcbiAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0Jzogd3JpdGUoZmlyc3QocGFyYW1zw7gxKSksXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29tcHV0ZWQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ICdsb29wJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb3VudChyZXN1bHTDuDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgbG9vcFsxXSA9IHJlc3QocGFyYW1zw7gxKSwgbG9vcCk7XG4gICAgICAgICAgICB9IHdoaWxlIChyZXN1bHTDuDEgPSBsb29wWzBdLCBwYXJhbXPDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHdyaXRlUmVjdXIgPSBleHBvcnRzLndyaXRlUmVjdXIgPSBmdW5jdGlvbiB3cml0ZVJlY3VyKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRvU2VxdWVuY2UoY29uaih0b1JlY3VyKGZvcm0pLCB7XG4gICAgICAgICAgICAndHlwZSc6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICduYW1lJzogJ2xvb3AnXG4gICAgICAgIH0pKTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcigncmVjdXInLCB3cml0ZVJlY3VyKTtcbnZhciBmYWxsYmFja092ZXJsb2FkID0gZXhwb3J0cy5mYWxsYmFja092ZXJsb2FkID0gZnVuY3Rpb24gZmFsbGJhY2tPdmVybG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0eXBlJzogJ1N3aXRjaENhc2UnLFxuICAgICAgICAgICAgJ3Rlc3QnOiB2b2lkIDAsXG4gICAgICAgICAgICAnY29uc2VxdWVudCc6IFt7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbGxlZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ICdSYW5nZUVycm9yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH07XG52YXIgc3BsaWNlQmluZGluZyA9IGV4cG9ydHMuc3BsaWNlQmluZGluZyA9IGZ1bmN0aW9uIHNwbGljZUJpbmRpbmcoZm9ybSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ29wJzogJ2RlZicsXG4gICAgICAgICAgICAnaWQnOiBsYXN0KChmb3JtIHx8IDApWydwYXJhbXMnXSksXG4gICAgICAgICAgICAnaW5pdCc6IHtcbiAgICAgICAgICAgICAgICAnb3AnOiAnaW52b2tlJyxcbiAgICAgICAgICAgICAgICAnY2FsbGVlJzoge1xuICAgICAgICAgICAgICAgICAgICAnb3AnOiAndmFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiBzeW1ib2wodm9pZCAwLCAnQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwnKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29wJzogJ3ZhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9ybSc6IHN5bWJvbCh2b2lkIDAsICdhcmd1bWVudHMnKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnb3AnOiAnY29uc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiAoZm9ybSB8fCAwKVsnYXJpdHknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xudmFyIHdyaXRlT3ZlcmxvYWRpbmdQYXJhbXMgPSBleHBvcnRzLndyaXRlT3ZlcmxvYWRpbmdQYXJhbXMgPSBmdW5jdGlvbiB3cml0ZU92ZXJsb2FkaW5nUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uIChmb3JtcywgcGFyYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjb25qKGZvcm1zLCB7XG4gICAgICAgICAgICAgICAgJ29wJzogJ2RlZicsXG4gICAgICAgICAgICAgICAgJ2lkJzogcGFyYW0sXG4gICAgICAgICAgICAgICAgJ2luaXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdvcCc6ICdtZW1iZXItZXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICdjb21wdXRlZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0YXJnZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnb3AnOiAndmFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb3JtJzogc3ltYm9sKHZvaWQgMCwgJ2FyZ3VtZW50cycpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcCc6ICdjb25zdGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiBjb3VudChmb3JtcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBbXSwgcGFyYW1zKTtcbiAgICB9O1xudmFyIHdyaXRlT3ZlcmxvYWRpbmdGbiA9IGV4cG9ydHMud3JpdGVPdmVybG9hZGluZ0ZuID0gZnVuY3Rpb24gd3JpdGVPdmVybG9hZGluZ0ZuKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdmVybG9hZHPDuDEgPSBtYXAod3JpdGVGbk92ZXJsb2FkLCAoZm9ybSB8fCAwKVsnbWV0aG9kcyddKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IFtdLFxuICAgICAgICAgICAgICAgICdib2R5JzogdG9CbG9jayh7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ1N3aXRjaFN0YXRlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICdkaXNjcmltaW5hbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb21wdXRlZCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ICdhcmd1bWVudHMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogJ2xlbmd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nhc2VzJzogKGZvcm0gfHwgMClbJ3ZhcmlhZGljJ10gPyBvdmVybG9hZHPDuDEgOiBjb25qKG92ZXJsb2Fkc8O4MSwgZmFsbGJhY2tPdmVybG9hZCgpKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciB3cml0ZUZuT3ZlcmxvYWQgPSBleHBvcnRzLndyaXRlRm5PdmVybG9hZCA9IGZ1bmN0aW9uIHdyaXRlRm5PdmVybG9hZChmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zw7gxID0gKGZvcm0gfHwgMClbJ3BhcmFtcyddO1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzw7gxID0gKGZvcm0gfHwgMClbJ3ZhcmlhZGljJ10gPyBjb25qKHdyaXRlT3ZlcmxvYWRpbmdQYXJhbXMoYnV0bGFzdChwYXJhbXPDuDEpKSwgc3BsaWNlQmluZGluZyhmb3JtKSkgOiB3cml0ZU92ZXJsb2FkaW5nUGFyYW1zKHBhcmFtc8O4MSk7XG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50c8O4MSA9IHZlYyhjb25jYXQoYmluZGluZ3PDuDEsIChmb3JtIHx8IDApWydzdGF0ZW1lbnRzJ10pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgICAgICAgICAgJ3Rlc3QnOiAhKGZvcm0gfHwgMClbJ3ZhcmlhZGljJ10gPyB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiAoZm9ybSB8fCAwKVsnYXJpdHknXVxuICAgICAgICAgICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgJ2NvbnNlcXVlbnQnOiB3cml0ZUJvZHkoY29uaihmb3JtLCB7ICdzdGF0ZW1lbnRzJzogc3RhdGVtZW50c8O4MSB9KSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHdyaXRlU2ltcGxlRm4gPSBleHBvcnRzLndyaXRlU2ltcGxlRm4gPSBmdW5jdGlvbiB3cml0ZVNpbXBsZUZuKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2TDuDEgPSBmaXJzdCgoZm9ybSB8fCAwKVsnbWV0aG9kcyddKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXPDuDEgPSAobWV0aG9kw7gxIHx8IDApWyd2YXJpYWRpYyddID8gYnV0bGFzdCgobWV0aG9kw7gxIHx8IDApWydwYXJhbXMnXSkgOiAobWV0aG9kw7gxIHx8IDApWydwYXJhbXMnXTtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gKG1ldGhvZMO4MSB8fCAwKVsndmFyaWFkaWMnXSA/IGNvbmoobWV0aG9kw7gxLCB7ICdzdGF0ZW1lbnRzJzogdmVjKGNvbnMoc3BsaWNlQmluZGluZyhtZXRob2TDuDEpLCAobWV0aG9kw7gxIHx8IDApWydzdGF0ZW1lbnRzJ10pKSB9KSA6IG1ldGhvZMO4MTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IG1hcCh3cml0ZVZhciwgcGFyYW1zw7gxKSxcbiAgICAgICAgICAgICAgICAnYm9keSc6IHRvQmxvY2sod3JpdGVCb2R5KGJvZHnDuDEpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVzb2x2ZSA9IGV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcsO4MSA9IHNwbGl0KG5hbWUoZnJvbSksICcuJyk7XG4gICAgICAgICAgICB2YXIgcmVxdWlyZW1lbnTDuDEgPSBzcGxpdChuYW1lKHRvKSwgJy4nKTtcbiAgICAgICAgICAgIHZhciBpc1JlbGF0aXZlw7gxID0gIShuYW1lKGZyb20pID09PSBuYW1lKHRvKSkgJiYgZmlyc3QocmVxdWlyZXLDuDEpID09PSBmaXJzdChyZXF1aXJlbWVudMO4MSk7XG4gICAgICAgICAgICByZXR1cm4gaXNSZWxhdGl2ZcO4MSA/IGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbcO4MiA9IHJlcXVpcmVyw7gxO1xuICAgICAgICAgICAgICAgIHZhciB0b8O4MiA9IHJlcXVpcmVtZW50w7gxO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBmaXJzdChmcm9tw7gyKSA9PT0gZmlyc3QodG/DuDIpID8gKGxvb3BbMF0gPSByZXN0KGZyb23DuDIpLCBsb29wWzFdID0gcmVzdCh0b8O4MiksIGxvb3ApIDogam9pbignLycsIGNvbmNhdChbJy4nXSwgcmVwZWF0KGRlYyhjb3VudChmcm9tw7gyKSksICcuLicpLCB0b8O4MikpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGZyb23DuDIgPSBsb29wWzBdLCB0b8O4MiA9IGxvb3BbMV0sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgICAgICB9LmNhbGwodGhpcykgOiBqb2luKCcvJywgcmVxdWlyZW1lbnTDuDEpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBpZFRvTnMgPSBleHBvcnRzLmlkVG9OcyA9IGZ1bmN0aW9uIGlkVG9OcyhpZCkge1xuICAgICAgICByZXR1cm4gc3ltYm9sKHZvaWQgMCwgam9pbignKicsIHNwbGl0KG5hbWUoaWQpLCAnLicpKSk7XG4gICAgfTtcbnZhciB3cml0ZVJlcXVpcmUgPSBleHBvcnRzLndyaXRlUmVxdWlyZSA9IGZ1bmN0aW9uIHdyaXRlUmVxdWlyZShmb3JtLCByZXF1aXJlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5zQmluZGluZ8O4MSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ29wJzogJ2RlZicsXG4gICAgICAgICAgICAgICAgICAgICdpZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcCc6ICd2YXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9ybSc6IGlkVG9OcygoZm9ybSB8fCAwKVsnbnMnXSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2luaXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnb3AnOiAnaW52b2tlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYWxsZWUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wJzogJ3ZhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiBzeW1ib2wodm9pZCAwLCAncmVxdWlyZScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcmFtcyc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcCc6ICdjb25zdGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmb3JtJzogcmVzb2x2ZShyZXF1aXJlciwgKGZvcm0gfHwgMClbJ25zJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbnNBbGlhc8O4MSA9IChmb3JtIHx8IDApWydhbGlhcyddID8ge1xuICAgICAgICAgICAgICAgICAgICAnb3AnOiAnZGVmJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29wJzogJ3ZhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdpZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb3JtJzogaWRUb05zKChmb3JtIHx8IDApWydhbGlhcyddKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnaW5pdCc6IChuc0JpbmRpbmfDuDEgfHwgMClbJ2lkJ11cbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZXPDuDEgPSByZWR1Y2UoZnVuY3Rpb24gKHJlZmVyZW5jZXMsIGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmoocmVmZXJlbmNlcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29wJzogJ2RlZicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wJzogJ3ZhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiAoZm9ybSB8fCAwKVsncmVuYW1lJ10gfHwgKGZvcm0gfHwgMClbJ25hbWUnXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcCc6ICdtZW1iZXItZXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbXB1dGVkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6IChuc0JpbmRpbmfDuDEgfHwgMClbJ2lkJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3AnOiAndmFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmb3JtJzogKGZvcm0gfHwgMClbJ25hbWUnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgW10sIChmb3JtIHx8IDApWydyZWZlciddKTtcbiAgICAgICAgICAgIHJldHVybiB2ZWMoY29ucyhuc0JpbmRpbmfDuDEsIG5zQWxpYXPDuDEgPyBjb25zKG5zQWxpYXPDuDEsIHJlZmVyZW5jZXPDuDEpIDogcmVmZXJlbmNlc8O4MSkpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciB3cml0ZU5zID0gZXhwb3J0cy53cml0ZU5zID0gZnVuY3Rpb24gd3JpdGVOcyhmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZcO4MSA9IChmb3JtIHx8IDApWydmb3JtJ107XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXLDuDEgPSAoZm9ybSB8fCAwKVsnbmFtZSddO1xuICAgICAgICAgICAgdmFyIG5zQmluZGluZ8O4MSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ29wJzogJ2RlZicsXG4gICAgICAgICAgICAgICAgICAgICdvcmlnaW5hbC1mb3JtJzogbm9kZcO4MSxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29wJzogJ3ZhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdpZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmlnaW5hbC1mb3JtJzogZmlyc3Qobm9kZcO4MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9ybSc6IHN5bWJvbCh2b2lkIDAsICcqbnMqJylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2luaXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnb3AnOiAnZGljdGlvbmFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9ybSc6IG5vZGXDuDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAna2V5cyc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcCc6ICd2YXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdpZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29yaWdpbmFsLWZvcm0nOiBub2Rlw7gxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9ybSc6IHN5bWJvbCh2b2lkIDAsICdpZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcCc6ICd2YXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdpZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29yaWdpbmFsLWZvcm0nOiBub2Rlw7gxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9ybSc6IHN5bWJvbCh2b2lkIDAsICdkb2MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsdWVzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wJzogJ2NvbnN0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcmlnaW5hbC1mb3JtJzogKGZvcm0gfHwgMClbJ25hbWUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiBuYW1lKChmb3JtIHx8IDApWyduYW1lJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcCc6ICdjb25zdGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcmlnaW5hbC1mb3JtJzogbm9kZcO4MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0nOiAoZm9ybSB8fCAwKVsnZG9jJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVtZW50c8O4MSA9IHZlYyhjb25jYXQuYXBwbHkodm9pZCAwLCBtYXAoZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVJlcXVpcmUoJDEsIHJlcXVpcmVyw7gxKTtcbiAgICAgICAgICAgICAgICB9LCAoZm9ybSB8fCAwKVsncmVxdWlyZSddKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQmxvY2sobWFwKHdyaXRlLCB2ZWMoY29ucyhuc0JpbmRpbmfDuDEsIHJlcXVpcmVtZW50c8O4MSkpKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xuaW5zdGFsbFdyaXRlcignbnMnLCB3cml0ZU5zKTtcbnZhciB3cml0ZUZuID0gZXhwb3J0cy53cml0ZUZuID0gZnVuY3Rpb24gd3JpdGVGbihmb3JtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZcO4MSA9IGNvdW50KChmb3JtIHx8IDApWydtZXRob2RzJ10pID4gMSA/IHdyaXRlT3ZlcmxvYWRpbmdGbihmb3JtKSA6IHdyaXRlU2ltcGxlRm4oZm9ybSk7XG4gICAgICAgICAgICByZXR1cm4gY29uaihiYXNlw7gxLCB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAnaWQnOiAoZm9ybSB8fCAwKVsnaWQnXSA/IHdyaXRlVmFyKChmb3JtIHx8IDApWydpZCddKSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdHMnOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgJ3Jlc3QnOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgJ2dlbmVyYXRvcic6IGZhbHNlLFxuICAgICAgICAgICAgICAgICdleHByZXNzaW9uJzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxXcml0ZXIoJ2ZuJywgd3JpdGVGbik7XG52YXIgd3JpdGUgPSBleHBvcnRzLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9ww7gxID0gKGZvcm0gfHwgMClbJ29wJ107XG4gICAgICAgICAgICB2YXIgd3JpdGVyw7gxID0gaXNFcXVhbCgnaW52b2tlJywgKGZvcm0gfHwgMClbJ29wJ10pICYmIGlzRXF1YWwoJ3ZhcicsICgoZm9ybSB8fCAwKVsnY2FsbGVlJ10gfHwgMClbJ29wJ10pICYmIChfX3NwZWNpYWxzX18gfHwgMClbbmFtZSgoKGZvcm0gfHwgMClbJ2NhbGxlZSddIHx8IDApWydmb3JtJ10pXTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXLDuDEgPyB3cml0ZVNwZWNpYWwod3JpdGVyw7gxLCBmb3JtKSA6IHdyaXRlT3AoKGZvcm0gfHwgMClbJ29wJ10sIGZvcm0pO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciB3cml0ZV8gPSBleHBvcnRzLndyaXRlXyA9IGZ1bmN0aW9uIHdyaXRlXygpIHtcbiAgICAgICAgdmFyIGZvcm1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gbWFwKHdyaXRlU3RhdGVtZW50LCBmb3Jtcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ1Byb2dyYW0nLFxuICAgICAgICAgICAgICAgICdib2R5JzogYm9kecO4MSxcbiAgICAgICAgICAgICAgICAnbG9jJzogaW5oZXJpdExvY2F0aW9uKGJvZHnDuDEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBjb21waWxlID0gZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGUoe30sIGZvcm0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgZm9ybXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlKHdyaXRlXy5hcHBseSh2b2lkIDAsIGZvcm1zKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xudmFyIGdldE1hY3JvID0gZXhwb3J0cy5nZXRNYWNybyA9IGZ1bmN0aW9uIGdldE1hY3JvKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2FnZXQnKV0uY29uY2F0KFtsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdvcicpXS5jb25jYXQoW3RhcmdldF0sIFswXSkpXSwgW3Byb3BlcnR5XSkpO1xuICAgIH07XG5pbnN0YWxsTWFjcm8oJ2dldCcsIGdldE1hY3JvKTtcbnZhciBpbnN0YWxsTG9naWNhbE9wZXJhdG9yID0gZXhwb3J0cy5pbnN0YWxsTG9naWNhbE9wZXJhdG9yID0gZnVuY3Rpb24gaW5zdGFsbExvZ2ljYWxPcGVyYXRvcihjYWxsZWUsIG9wZXJhdG9yLCBmYWxsYmFjaykge1xuICAgICAgICB2YXIgd3JpdGVMb2dpY2FsT3BlcmF0b3IgPSBmdW5jdGlvbiB3cml0ZUxvZ2ljYWxPcGVyYXRvcigpIHtcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuw7gxID0gY291bnQob3BlcmFuZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKG7DuDEsIDApID8gd3JpdGVDb25zdGFudChmYWxsYmFjaykgOiBpc0VxdWFsKG7DuDEsIDEpID8gd3JpdGUoZmlyc3Qob3BlcmFuZHMpKSA6ICdlbHNlJyA/IHJlZHVjZShmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0Jzogd3JpdGUocmlnaHQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSwgd3JpdGUoZmlyc3Qob3BlcmFuZHMpKSwgcmVzdChvcGVyYW5kcykpIDogdm9pZCAwO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5zdGFsbFNwZWNpYWwoY2FsbGVlLCB3cml0ZUxvZ2ljYWxPcGVyYXRvcik7XG4gICAgfTtcbmluc3RhbGxMb2dpY2FsT3BlcmF0b3IoJ29yJywgJ3x8Jywgdm9pZCAwKTtcbmluc3RhbGxMb2dpY2FsT3BlcmF0b3IoJ2FuZCcsICcmJicsIHRydWUpO1xudmFyIGluc3RhbGxVbmFyeU9wZXJhdG9yID0gZXhwb3J0cy5pbnN0YWxsVW5hcnlPcGVyYXRvciA9IGZ1bmN0aW9uIGluc3RhbGxVbmFyeU9wZXJhdG9yKGNhbGxlZSwgb3BlcmF0b3IsIGlzUHJlZml4KSB7XG4gICAgICAgIHZhciB3cml0ZVVuYXJ5T3BlcmF0b3IgPSBmdW5jdGlvbiB3cml0ZVVuYXJ5T3BlcmF0b3IoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudChwYXJhbXMpID09PSAxID8ge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgJ29wZXJhdG9yJzogb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgJ2FyZ3VtZW50Jzogd3JpdGUoZmlyc3QocGFyYW1zKSksXG4gICAgICAgICAgICAgICAgJ3ByZWZpeCc6IGlzUHJlZml4XG4gICAgICAgICAgICB9IDogZXJyb3JBcmdDb3VudChjYWxsZWUsIGNvdW50KHBhcmFtcykpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5zdGFsbFNwZWNpYWwoY2FsbGVlLCB3cml0ZVVuYXJ5T3BlcmF0b3IpO1xuICAgIH07XG5pbnN0YWxsVW5hcnlPcGVyYXRvcignbm90JywgJyEnKTtcbmluc3RhbGxVbmFyeU9wZXJhdG9yKCdiaXQtbm90JywgJ34nKTtcbnZhciBpbnN0YWxsQmluYXJ5T3BlcmF0b3IgPSBleHBvcnRzLmluc3RhbGxCaW5hcnlPcGVyYXRvciA9IGZ1bmN0aW9uIGluc3RhbGxCaW5hcnlPcGVyYXRvcihjYWxsZWUsIG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciB3cml0ZUJpbmFyeU9wZXJhdG9yID0gZnVuY3Rpb24gd3JpdGVCaW5hcnlPcGVyYXRvcigpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50KHBhcmFtcykgPCAyID8gZXJyb3JBcmdDb3VudChjYWxsZWUsIGNvdW50KHBhcmFtcykpIDogcmVkdWNlKGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAnb3BlcmF0b3InOiBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAncmlnaHQnOiB3cml0ZShyaWdodClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgd3JpdGUoZmlyc3QocGFyYW1zKSksIHJlc3QocGFyYW1zKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnN0YWxsU3BlY2lhbChjYWxsZWUsIHdyaXRlQmluYXJ5T3BlcmF0b3IpO1xuICAgIH07XG5pbnN0YWxsQmluYXJ5T3BlcmF0b3IoJ2JpdC1hbmQnLCAnJicpO1xuaW5zdGFsbEJpbmFyeU9wZXJhdG9yKCdiaXQtb3InLCAnfCcpO1xuaW5zdGFsbEJpbmFyeU9wZXJhdG9yKCdiaXQteG9yJywgJ14nKTtcbmluc3RhbGxCaW5hcnlPcGVyYXRvcignYml0LXNoaWZ0LWxlZnQnLCAnPDwnKTtcbmluc3RhbGxCaW5hcnlPcGVyYXRvcignYml0LXNoaWZ0LXJpZ2h0JywgJz4+Jyk7XG5pbnN0YWxsQmluYXJ5T3BlcmF0b3IoJ2JpdC1zaGlmdC1yaWdodC16ZXJvLWZpbCcsICc+Pj4nKTtcbnZhciBpbnN0YWxsQXJpdGhtZXRpY09wZXJhdG9yID0gZXhwb3J0cy5pbnN0YWxsQXJpdGhtZXRpY09wZXJhdG9yID0gZnVuY3Rpb24gaW5zdGFsbEFyaXRobWV0aWNPcGVyYXRvcihjYWxsZWUsIG9wZXJhdG9yLCBpc1ZhbGlkLCBmYWxsYmFjaykge1xuICAgICAgICB2YXIgd3JpdGVCaW5hcnlPcGVyYXRvciA9IGZ1bmN0aW9uIHdyaXRlQmluYXJ5T3BlcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgJ29wZXJhdG9yJzogbmFtZShvcGVyYXRvciksXG4gICAgICAgICAgICAgICAgJ2xlZnQnOiBsZWZ0LFxuICAgICAgICAgICAgICAgICdyaWdodCc6IHdyaXRlKHJpZ2h0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdyaXRlQXJpdGhtZXRpY09wZXJhdG9yID0gZnVuY3Rpb24gd3JpdGVBcml0aG1ldGljT3BlcmF0b3IoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG7DuDEgPSBjb3VudChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkICYmICFpc1ZhbGlkKG7DuDEpID8gZXJyb3JBcmdDb3VudChuYW1lKGNhbGxlZSksIG7DuDEpIDogbsO4MSA9PSAwID8gd3JpdGVMaXRlcmFsKGZhbGxiYWNrKSA6IG7DuDEgPT0gMSA/IHJlZHVjZSh3cml0ZUJpbmFyeU9wZXJhdG9yLCB3cml0ZUxpdGVyYWwoZmFsbGJhY2spLCBwYXJhbXMpIDogJ2Vsc2UnID8gcmVkdWNlKHdyaXRlQmluYXJ5T3BlcmF0b3IsIHdyaXRlKGZpcnN0KHBhcmFtcykpLCByZXN0KHBhcmFtcykpIDogdm9pZCAwO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5zdGFsbFNwZWNpYWwoY2FsbGVlLCB3cml0ZUFyaXRobWV0aWNPcGVyYXRvcik7XG4gICAgfTtcbmluc3RhbGxBcml0aG1ldGljT3BlcmF0b3IoJysnLCAnKycsIHZvaWQgMCwgMCk7XG5pbnN0YWxsQXJpdGhtZXRpY09wZXJhdG9yKCctJywgJy0nLCBmdW5jdGlvbiAoJDEpIHtcbiAgICByZXR1cm4gJDEgPj0gMTtcbn0sIDApO1xuaW5zdGFsbEFyaXRobWV0aWNPcGVyYXRvcignKicsICcqJywgdm9pZCAwLCAxKTtcbmluc3RhbGxBcml0aG1ldGljT3BlcmF0b3Ioa2V5d29yZCgnLycpLCBrZXl3b3JkKCcvJyksIGZ1bmN0aW9uICgkMSkge1xuICAgIHJldHVybiAkMSA+PSAxO1xufSwgMSk7XG5pbnN0YWxsQXJpdGhtZXRpY09wZXJhdG9yKCdtb2QnLCBrZXl3b3JkKCclJyksIGZ1bmN0aW9uICgkMSkge1xuICAgIHJldHVybiAkMSA9PSAyO1xufSwgMSk7XG52YXIgaW5zdGFsbENvbXBhcmlzb25PcGVyYXRvciA9IGV4cG9ydHMuaW5zdGFsbENvbXBhcmlzb25PcGVyYXRvciA9IGZ1bmN0aW9uIGluc3RhbGxDb21wYXJpc29uT3BlcmF0b3IoY2FsbGVlLCBvcGVyYXRvciwgZmFsbGJhY2spIHtcbiAgICAgICAgdmFyIHdyaXRlQ29tcGFyaXNvbk9wZXJhdG9yID0gZnVuY3Rpb24gd3JpdGVDb21wYXJpc29uT3BlcmF0b3IoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JBcmdDb3VudChjYWxsZWUsIDApO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1NlcXVlbmNlKFtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGUoZm9ybSksXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlTGl0ZXJhbChmYWxsYmFjaylcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAnbGVmdCc6IHdyaXRlKGxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAncmlnaHQnOiB3cml0ZShyaWdodClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWR1Y2UoZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3BlcmF0b3InOiAnJiYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0JzogaXNFcXVhbCgnTG9naWNhbEV4cHJlc3Npb24nLCAobGVmdCB8fCAwKVsndHlwZSddKSA/ICgobGVmdCB8fCAwKVsncmlnaHQnXSB8fCAwKVsncmlnaHQnXSA6IChsZWZ0IHx8IDApWydyaWdodCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyaWdodCc6IHdyaXRlKHJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sIHdyaXRlQ29tcGFyaXNvbk9wZXJhdG9yKGxlZnQsIHJpZ2h0KSwgbW9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnN0YWxsU3BlY2lhbChjYWxsZWUsIHdyaXRlQ29tcGFyaXNvbk9wZXJhdG9yKTtcbiAgICB9O1xuaW5zdGFsbENvbXBhcmlzb25PcGVyYXRvcignPT0nLCAnPT0nLCB0cnVlKTtcbmluc3RhbGxDb21wYXJpc29uT3BlcmF0b3IoJz4nLCAnPicsIHRydWUpO1xuaW5zdGFsbENvbXBhcmlzb25PcGVyYXRvcignPj0nLCAnPj0nLCB0cnVlKTtcbmluc3RhbGxDb21wYXJpc29uT3BlcmF0b3IoJzwnLCAnPCcsIHRydWUpO1xuaW5zdGFsbENvbXBhcmlzb25PcGVyYXRvcignPD0nLCAnPD0nLCB0cnVlKTtcbnZhciBpc1dyaXRlSWRlbnRpY2FsID0gZXhwb3J0cy5pc1dyaXRlSWRlbnRpY2FsID0gZnVuY3Rpb24gaXNXcml0ZUlkZW50aWNhbCgpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHJldHVybiBjb3VudChwYXJhbXMpID09PSAyID8ge1xuICAgICAgICAgICAgJ3R5cGUnOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAnb3BlcmF0b3InOiAnPT09JyxcbiAgICAgICAgICAgICdsZWZ0Jzogd3JpdGUoZmlyc3QocGFyYW1zKSksXG4gICAgICAgICAgICAncmlnaHQnOiB3cml0ZShzZWNvbmQocGFyYW1zKSlcbiAgICAgICAgfSA6IGVycm9yQXJnQ291bnQoJ2lkZW50aWNhbD8nLCBjb3VudChwYXJhbXMpKTtcbiAgICB9O1xuaW5zdGFsbFNwZWNpYWwoJ2lkZW50aWNhbD8nLCBpc1dyaXRlSWRlbnRpY2FsKTtcbnZhciBpc1dyaXRlSW5zdGFuY2UgPSBleHBvcnRzLmlzV3JpdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIGlzV3JpdGVJbnN0YW5jZSgpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3LDuDEgPSBmaXJzdChwYXJhbXMpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlw7gxID0gc2Vjb25kKHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gY291bnQocGFyYW1zKSA8IDEgPyBlcnJvckFyZ0NvdW50KCdpbnN0YW5jZT8nLCBjb3VudChwYXJhbXMpKSA6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAnb3BlcmF0b3InOiAnaW5zdGFuY2VvZicsXG4gICAgICAgICAgICAgICAgJ2xlZnQnOiBpbnN0YW5jZcO4MSA/IHdyaXRlKGluc3RhbmNlw7gxKSA6IHdyaXRlQ29uc3RhbnQoaW5zdGFuY2XDuDEpLFxuICAgICAgICAgICAgICAgICdyaWdodCc6IHdyaXRlKGNvbnN0cnVjdG9yw7gxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsU3BlY2lhbCgnaW5zdGFuY2U/JywgaXNXcml0ZUluc3RhbmNlKTtcbnZhciBleHBhbmRBcHBseSA9IGV4cG9ydHMuZXhwYW5kQXBwbHkgPSBmdW5jdGlvbiBleHBhbmRBcHBseShmKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByZWZpeMO4MSA9IHZlYyhidXRsYXN0KHBhcmFtcykpO1xuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHkocHJlZml4w7gxKSA/IGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJy5hcHBseScpXS5jb25jYXQoW2ZdLCBbdm9pZCAwXSwgdmVjKHBhcmFtcykpKSA6IGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJy5hcHBseScpXS5jb25jYXQoW2ZdLCBbdm9pZCAwXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJy5jb25jYXQnKV0uY29uY2F0KFtwcmVmaXjDuDFdLCBbbGFzdChwYXJhbXMpXSkpXSkpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxNYWNybygnYXBwbHknLCBleHBhbmRBcHBseSk7XG52YXIgZXhwYW5kUHJpbnQgPSBleHBvcnRzLmV4cGFuZFByaW50ID0gZnVuY3Rpb24gZXhwYW5kUHJpbnQoYW5kRm9ybSkge1xuICAgICAgICB2YXIgbW9yZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICdQcmludHMgdGhlIG9iamVjdChzKSB0byB0aGUgb3V0cHV0IGZvciBodW1hbiBjb25zdW1wdGlvbi4nO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9ww7gxID0gd2l0aE1ldGEoc3ltYm9sKHZvaWQgMCwgJ2NvbnNvbGUubG9nJyksIG1ldGEoYW5kRm9ybSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QuYXBwbHkodm9pZCAwLCBbb3DDuDFdLmNvbmNhdCh2ZWMobW9yZSkpKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG5pbnN0YWxsTWFjcm8oJ3ByaW50Jywgd2l0aE1ldGEoZXhwYW5kUHJpbnQsIHsgJ2ltcGxpY2l0JzogWycmZm9ybSddIH0pKTtcbnZhciBleHBhbmRTdHIgPSBleHBvcnRzLmV4cGFuZFN0ciA9IGZ1bmN0aW9uIGV4cGFuZFN0cigpIHtcbiAgICAgICAgdmFyIGZvcm1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJysnKV0uY29uY2F0KFsnJ10sIHZlYyhmb3JtcykpKTtcbiAgICB9O1xuaW5zdGFsbE1hY3JvKCdzdHInLCBleHBhbmRTdHIpO1xudmFyIGV4cGFuZERlYnVnID0gZXhwb3J0cy5leHBhbmREZWJ1ZyA9IGZ1bmN0aW9uIGV4cGFuZERlYnVnKCkge1xuICAgICAgICByZXR1cm4gc3ltYm9sKHZvaWQgMCwgJ2RlYnVnZ2VyJyk7XG4gICAgfTtcbmluc3RhbGxNYWNybygnZGVidWdnZXIhJywgZXhwYW5kRGVidWcpO1xudmFyIGV4cGFuZEFzc2VydCA9IGV4cG9ydHMuZXhwYW5kQXNzZXJ0ID0gZnVuY3Rpb24gZXhwYW5kQXNzZXJ0KCkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kQXNzZXJ0KHgsICcnKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm3DuDEgPSBwclN0cih4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnaWYnKV0uY29uY2F0KFtsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdub3QnKV0uY29uY2F0KFt4XSkpXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ3Rocm93JyldLmNvbmNhdChbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnRXJyb3InKV0uY29uY2F0KFtsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdzdHInKV0uY29uY2F0KFsnQXNzZXJ0IGZhaWxlZDogJ10sIFttZXNzYWdlXSwgW2Zvcm3DuDFdKSldKSldKSldKSk7XG4gICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbmluc3RhbGxNYWNybygnYXNzZXJ0JywgZXhwYW5kQXNzZXJ0KTtcbnZhciBleHBhbmREZWZwcm90b2NvbCA9IGV4cG9ydHMuZXhwYW5kRGVmcHJvdG9jb2wgPSBmdW5jdGlvbiBleHBhbmREZWZwcm90b2NvbChhbmRFbnYsIGlkKSB7XG4gICAgICAgIHZhciBmb3JtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbnPDuDEgPSAoKChhbmRFbnYgfHwgMClbJ25zJ10gfHwgMClbJ25hbWUnXSB8fCAwKVsnbmFtZSddO1xuICAgICAgICAgICAgdmFyIHByb3RvY29sTmFtZcO4MSA9IG5hbWUoaWQpO1xuICAgICAgICAgICAgdmFyIHNwZWPDuDEgPSByZWR1Y2UoZnVuY3Rpb24gKHNwZWMsIGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduYXR1cmVzw7gxID0gKHNwZWMgfHwgMClbJ3NpZ25hdHVyZXMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2ROYW1lw7gxID0gZmlyc3QoZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zw7gxID0gbWFwKG5hbWUsIHNlY29uZChmb3JtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWTDuDIgPSBpZFRvTnMoJycgKyBuc8O4MSArICckJyArIHByb3RvY29sTmFtZcO4MSArICckJyArIG5hbWUobWV0aG9kTmFtZcO4MSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZElkw7gxID0gdHJhbnNsYXRlSWRlbnRpZmllcldvcmQoaWTDuDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmooc3BlYywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaWduYXR1cmVzJzogYXNzb2Moc2lnbmF0dXJlc8O4MSwgbWV0aG9kTmFtZcO4MSwgcGFyYW1zw7gxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWV0aG9kcyc6IGFzc29jKChzcGVjIHx8IDApWydtZXRob2RzJ10sIG1ldGhvZE5hbWXDuDEsIG1ldGhvZElkw7gxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm5zJzogY29uaigoc3BlYyB8fCAwKVsnZm5zJ10sIGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2RlZm4nKV0uY29uY2F0KFttZXRob2ROYW1lw7gxXSwgW1tzeW1ib2wodm9pZCAwLCAnaW5zdGFuY2UnKV0uY29uY2F0KCldLCBbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnLmFwcGx5JyldLmNvbmNhdChbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnYWdldCcpXS5jb25jYXQoW3N5bWJvbCh2b2lkIDAsICdpbnN0YW5jZScpXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ3F1b3RlJyldLmNvbmNhdChbaWTDuDJdKSldKSldLCBbc3ltYm9sKHZvaWQgMCwgJ2luc3RhbmNlJyldLCBbc3ltYm9sKHZvaWQgMCwgJ2FyZ3VtZW50cycpXSkpXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICdmbnMnOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgJ21ldGhvZHMnOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgJ3NpZ25hdHVyZXMnOiB7fVxuICAgICAgICAgICAgICAgIH0sIGZvcm1zKTtcbiAgICAgICAgICAgIHZhciBmbnPDuDEgPSAoc3BlY8O4MSB8fCAwKVsnZm5zJ107XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2zDuDEgPSB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6ICcnICsgbnPDuDEgKyAnLycgKyBwcm90b2NvbE5hbWXDuDEsXG4gICAgICAgICAgICAgICAgICAgICdtZXRob2RzJzogKHNwZWPDuDEgfHwgMClbJ21ldGhvZHMnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3NpZ25hdHVyZXMnOiAoc3BlY8O4MSB8fCAwKVsnc2lnbmF0dXJlcyddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmFwcGx5KHZvaWQgMCwgW3dpdGhNZXRhKHN5bWJvbCh2b2lkIDAsICdkbycpLCB7ICdibG9jayc6IHRydWUgfSldLmNvbmNhdChbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnZGVmJyldLmNvbmNhdChbaWRdLCBbcHJvdG9jb2zDuDFdKSldLCB2ZWMoZm5zw7gxKSkpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxNYWNybygnZGVmcHJvdG9jb2wnLCB3aXRoTWV0YShleHBhbmREZWZwcm90b2NvbCwgeyAnaW1wbGljaXQnOiBbJyZlbnYnXSB9KSk7XG52YXIgZXhwYW5kRGVmdHlwZSA9IGV4cG9ydHMuZXhwYW5kRGVmdHlwZSA9IGZ1bmN0aW9uIGV4cGFuZERlZnR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgICAgIHZhciBmb3JtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHlwZUluaXTDuDEgPSBtYXAoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdzZXQhJyldLmNvbmNhdChbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnYWdldCcpXS5jb25jYXQoW3N5bWJvbCh2b2lkIDAsICd0aGlzJyldLCBbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAncXVvdGUnKV0uY29uY2F0KFtmaWVsZF0pKV0pKV0sIFtmaWVsZF0pKTtcbiAgICAgICAgICAgICAgICB9LCBmaWVsZHMpO1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yw7gxID0gY29uaih0eXBlSW5pdMO4MSwgc3ltYm9sKHZvaWQgMCwgJ3RoaXMnKSk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kSW5pdMO4MSA9IG1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2RlZicpXS5jb25jYXQoW2ZpZWxkXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2FnZXQnKV0uY29uY2F0KFtzeW1ib2wodm9pZCAwLCAndGhpcycpXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ3F1b3RlJyldLmNvbmNhdChbZmllbGRdKSldKSldKSk7XG4gICAgICAgICAgICAgICAgfSwgZmllbGRzKTtcbiAgICAgICAgICAgIHZhciBtYWtlTWV0aG9kw7gxID0gZnVuY3Rpb24gKHByb3RvY29sLCBmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWXDuDEgPSBmaXJzdChmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtc8O4MSA9IHNlY29uZChmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHnDuDEgPSByZXN0KHJlc3QoZm9ybSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnc2V0IScpXS5jb25jYXQoW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2FnZXQnKV0uY29uY2F0KFtsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICcuLXByb3RvdHlwZScpXS5jb25jYXQoW25hbWVdKSldLCBbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnYWdldCcpXS5jb25jYXQoW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJy4tbWV0aG9kcycpXS5jb25jYXQoW3Byb3RvY29sXSkpXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ3F1b3RlJyldLmNvbmNhdChbbWV0aG9kTmFtZcO4MV0pKV0pKV0pKV0sIFtsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdmbicpXS5jb25jYXQoW3BhcmFtc8O4MV0sIHZlYyhtZXRob2RJbml0w7gxKSwgdmVjKGJvZHnDuDEpKSldKSk7XG4gICAgICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzYXRpc2Z5w7gxID0gZnVuY3Rpb24gKHByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ3NldCEnKV0uY29uY2F0KFtsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdhZ2V0JyldLmNvbmNhdChbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnLi1wcm90b3R5cGUnKV0uY29uY2F0KFtuYW1lXSkpXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2FnZXQnKV0uY29uY2F0KFtwcm90b2NvbF0sIFtsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdxdW90ZScpXS5jb25jYXQoW3N5bWJvbCh2b2lkIDAsICdpZCcpXSkpXSkpXSkpXSwgW3RydWVdKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGJvZHnDuDEgPSByZWR1Y2UoZnVuY3Rpb24gKHR5cGUsIGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9ybSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0xpc3QoZm9ybSkgPyBjb25qKHR5cGUsIHsgJ2JvZHknOiBjb25qKCh0eXBlIHx8IDApWydib2R5J10sIG1ha2VNZXRob2TDuDEoKHR5cGUgfHwgMClbJ3Byb3RvY29sJ10sIGZvcm0pKSB9KSA6IGNvbmoodHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3RvY29sJzogZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib2R5JzogY29uaigodHlwZSB8fCAwKVsnYm9keSddLCBzYXRpc2Z5w7gxKGZvcm0pKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICdwcm90b2NvbCc6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgJ2JvZHknOiBbXVxuICAgICAgICAgICAgICAgIH0sIGZvcm1zKTtcbiAgICAgICAgICAgIHZhciBtZXRob2Rzw7gxID0gKGJvZHnDuDEgfHwgMClbJ2JvZHknXTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdkZWYnKV0uY29uY2F0KFtuYW1lXSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2RvJyldLmNvbmNhdChbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnZGVmbi0nKV0uY29uY2F0KFtuYW1lXSwgW2ZpZWxkc10sIHZlYyhjb25zdHJ1Y3RvcsO4MSkpKV0sIHZlYyhtZXRob2Rzw7gxKSwgW25hbWVdKSldKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xuaW5zdGFsbE1hY3JvKCdkZWZ0eXBlJywgZXhwYW5kRGVmdHlwZSk7XG5pbnN0YWxsTWFjcm8oJ2RlZnJlY29yZCcsIGV4cGFuZERlZnR5cGUpOyIsIntcbiAgICB2YXIgX25zXyA9IHtcbiAgICAgICAgICAgIGlkOiAnd2lzcC5jb21waWxlcicsXG4gICAgICAgICAgICBkb2M6IHZvaWQgMFxuICAgICAgICB9O1xuICAgIHZhciB3aXNwX2FuYWx5emVyID0gcmVxdWlyZSgnLi9hbmFseXplcicpO1xuICAgIHZhciBhbmFseXplID0gd2lzcF9hbmFseXplci5hbmFseXplO1xuICAgIHZhciB3aXNwX3JlYWRlciA9IHJlcXVpcmUoJy4vcmVhZGVyJyk7XG4gICAgdmFyIHJlYWRfID0gd2lzcF9yZWFkZXIucmVhZF87XG4gICAgdmFyIHJlYWQgPSB3aXNwX3JlYWRlci5yZWFkO1xuICAgIHZhciBwdXNoQmFja1JlYWRlciA9IHdpc3BfcmVhZGVyLnB1c2hCYWNrUmVhZGVyO1xuICAgIHZhciB3aXNwX3N0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5nJyk7XG4gICAgdmFyIHJlcGxhY2UgPSB3aXNwX3N0cmluZy5yZXBsYWNlO1xuICAgIHZhciB3aXNwX3NlcXVlbmNlID0gcmVxdWlyZSgnLi9zZXF1ZW5jZScpO1xuICAgIHZhciBtYXAgPSB3aXNwX3NlcXVlbmNlLm1hcDtcbiAgICB2YXIgY29uaiA9IHdpc3Bfc2VxdWVuY2UuY29uajtcbiAgICB2YXIgY29ucyA9IHdpc3Bfc2VxdWVuY2UuY29ucztcbiAgICB2YXIgdmVjID0gd2lzcF9zZXF1ZW5jZS52ZWM7XG4gICAgdmFyIGZpcnN0ID0gd2lzcF9zZXF1ZW5jZS5maXJzdDtcbiAgICB2YXIgcmVzdCA9IHdpc3Bfc2VxdWVuY2UucmVzdDtcbiAgICB2YXIgaXNFbXB0eSA9IHdpc3Bfc2VxdWVuY2UuaXNFbXB0eTtcbiAgICB2YXIgY291bnQgPSB3aXNwX3NlcXVlbmNlLmNvdW50O1xuICAgIHZhciB3aXNwX3J1bnRpbWUgPSByZXF1aXJlKCcuL3J1bnRpbWUnKTtcbiAgICB2YXIgaXNFcnJvciA9IHdpc3BfcnVudGltZS5pc0Vycm9yO1xuICAgIHZhciBpc0VxdWFsID0gd2lzcF9ydW50aW1lLmlzRXF1YWw7XG4gICAgdmFyIHdpc3BfYXN0ID0gcmVxdWlyZSgnLi9hc3QnKTtcbiAgICB2YXIgbmFtZSA9IHdpc3BfYXN0Lm5hbWU7XG4gICAgdmFyIHdpc3BfYmFja2VuZF9lc2NvZGVnZW5fZ2VuZXJhdG9yID0gcmVxdWlyZSgnLi9iYWNrZW5kL2VzY29kZWdlbi9nZW5lcmF0b3InKTtcbiAgICB2YXIgZ2VuZXJhdGVKcyA9IHdpc3BfYmFja2VuZF9lc2NvZGVnZW5fZ2VuZXJhdG9yLmdlbmVyYXRlO1xuICAgIHZhciBiYXNlNjRFbmNvZGUgPSByZXF1aXJlKCdiYXNlNjQtZW5jb2RlJyk7XG4gICAgdmFyIGJ0b2EgPSBiYXNlNjRFbmNvZGU7XG59XG52YXIgZ2VuZXJhdGUgPSBleHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGVKcztcbnZhciByZWFkRm9ybSA9IGV4cG9ydHMucmVhZEZvcm0gPSBmdW5jdGlvbiByZWFkRm9ybShyZWFkZXIsIGVvZikge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWQocmVhZGVyLCBmYWxzZSwgZW9mLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9O1xudmFyIHJlYWRGb3JtcyA9IGV4cG9ydHMucmVhZEZvcm1zID0gZnVuY3Rpb24gcmVhZEZvcm1zKHNvdXJjZSwgdXJpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVhZGVyw7gxID0gcHVzaEJhY2tSZWFkZXIoc291cmNlLCB1cmkpO1xuICAgICAgICAgICAgdmFyIGVvZsO4MSA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybXPDuDEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybcO4MSA9IHJlYWRGb3JtKHJlYWRlcsO4MSwgZW9mw7gxKTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyID0gaXNFcnJvcihmb3Jtw7gxKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb3Jtcyc6IGZvcm1zw7gxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJzogZm9ybcO4MVxuICAgICAgICAgICAgICAgICAgICB9IDogZm9ybcO4MSA9PT0gZW9mw7gxID8geyAnZm9ybXMnOiBmb3Jtc8O4MSB9IDogJ2Vsc2UnID8gKGxvb3BbMF0gPSBjb25qKGZvcm1zw7gxLCBmb3Jtw7gxKSwgbG9vcFsxXSA9IHJlYWRGb3JtKHJlYWRlcsO4MSwgZW9mw7gxKSwgbG9vcCkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZm9ybXPDuDEgPSBsb29wWzBdLCBmb3Jtw7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgYW5hbHl6ZUZvcm0gPSBleHBvcnRzLmFuYWx5emVGb3JtID0gZnVuY3Rpb24gYW5hbHl6ZUZvcm0oZW52LCBmb3JtKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5hbHl6ZShlbnYsIGZvcm0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbnZhciBhbmFseXplRm9ybXMgPSBleHBvcnRzLmFuYWx5emVGb3JtcyA9IGZ1bmN0aW9uIGFuYWx5emVGb3Jtcyhmb3Jtcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgbm9kZXPDuDEgPSBbXTtcbiAgICAgICAgICAgIHZhciBmb3Jtc8O4MiA9IGZvcm1zO1xuICAgICAgICAgICAgdmFyIGVudsO4MSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2xvY2Fscyc6IHt9LFxuICAgICAgICAgICAgICAgICAgICAnYmluZGluZ3MnOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZcO4MSA9IGFuYWx5emVGb3JtKGVudsO4MSwgZmlyc3QoZm9ybXPDuDIpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5zw7gxID0gaXNFcXVhbCgobm9kZcO4MSB8fCAwKVsnb3AnXSwgJ25zJykgPyBub2Rlw7gxIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNFcnJvcihub2Rlw7gxKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhc3QnOiBub2Rlc8O4MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcic6IG5vZGXDuDFcbiAgICAgICAgICAgICAgICAgICAgfSA6IGNvdW50KGZvcm1zw7gyKSA8PSAxID8geyAnYXN0JzogY29uaihub2Rlc8O4MSwgbm9kZcO4MSkgfSA6ICdlbHNlJyA/IChsb29wWzBdID0gY29uaihub2Rlc8O4MSwgbm9kZcO4MSksIGxvb3BbMV0gPSByZXN0KGZvcm1zw7gyKSwgbG9vcFsyXSA9IGNvbmooZW52w7gxLCB7ICducyc6IG5zw7gxIH0pLCBsb29wKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChub2Rlc8O4MSA9IGxvb3BbMF0sIGZvcm1zw7gyID0gbG9vcFsxXSwgZW52w7gxID0gbG9vcFsyXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBjb21waWxlID0gZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZShzb3VyY2UsIHt9KTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlVXJpw7gxID0gKG9wdGlvbnMgfHwgMClbJ3NvdXJjZS11cmknXSB8fCBuYW1lKCdhbm9ueW1vdXMud2lzcCcpO1xuICAgICAgICAgICAgICAgIHZhciBmb3Jtc8O4MSA9IHJlYWRGb3Jtcyhzb3VyY2UsIHNvdXJjZVVyacO4MSk7XG4gICAgICAgICAgICAgICAgdmFyIGFzdMO4MSA9IChmb3Jtc8O4MSB8fCAwKVsnZXJyb3InXSA/IGZvcm1zw7gxIDogYW5hbHl6ZUZvcm1zKChmb3Jtc8O4MSB8fCAwKVsnZm9ybXMnXSk7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dMO4MSA9IChhc3TDuDEgfHwgMClbJ2Vycm9yJ10gPyBhc3TDuDEgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGUuYXBwbHkodm9pZCAwLCB2ZWMoY29ucyhjb25qKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZSc6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZS11cmknOiBzb3VyY2VVcmnDuDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGFzdMO4MSB8fCAwKVsnYXN0J10pKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ICdlcnJvcic6IGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdMO4MSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzb3VyY2UtdXJpJzogc291cmNlVXJpw7gxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FzdCc6IChhc3TDuDEgfHwgMClbJ2FzdCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm1zJzogKGZvcm1zw7gxIHx8IDApWydmb3JtcyddXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmoob3B0aW9ucywgb3V0cHV0w7gxLCByZXN1bHTDuDEpO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG52YXIgZXZhbHVhdGUgPSBleHBvcnRzLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0w7gxID0gY29tcGlsZShzb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIChvdXRwdXTDuDEgfHwgMClbJ2Vycm9yJ10gPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IChvdXRwdXTDuDEgfHwgMClbJ2Vycm9yJ107XG4gICAgICAgICAgICB9KSgpIDogZXZhbCgob3V0cHV0w7gxIHx8IDApWydjb2RlJ10pO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTsiLCJ7XG4gICAgdmFyIF9uc18gPSB7XG4gICAgICAgICAgICBpZDogJ3dpc3AuZW5naW5lLmJyb3dzZXInLFxuICAgICAgICAgICAgZG9jOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICB2YXIgd2lzcF9ydW50aW1lID0gcmVxdWlyZSgnLi8uLi9ydW50aW1lJyk7XG4gICAgdmFyIHN0ciA9IHdpc3BfcnVudGltZS5zdHI7XG4gICAgdmFyIHdpc3Bfc2VxdWVuY2UgPSByZXF1aXJlKCcuLy4uL3NlcXVlbmNlJyk7XG4gICAgdmFyIHJlc3QgPSB3aXNwX3NlcXVlbmNlLnJlc3Q7XG4gICAgdmFyIHdpc3BfcmVhZGVyID0gcmVxdWlyZSgnLi8uLi9yZWFkZXInKTtcbiAgICB2YXIgcmVhZF8gPSB3aXNwX3JlYWRlci5yZWFkXztcbiAgICB2YXIgcmVhZEZyb21TdHJpbmcgPSB3aXNwX3JlYWRlci5yZWFkRnJvbVN0cmluZztcbiAgICB2YXIgd2lzcF9jb21waWxlciA9IHJlcXVpcmUoJy4vLi4vY29tcGlsZXInKTtcbiAgICB2YXIgY29tcGlsZV8gPSB3aXNwX2NvbXBpbGVyLmNvbXBpbGVfO1xufVxudmFyIGV2YWx1YXRlID0gZXhwb3J0cy5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKGNvZGUsIHVybCkge1xuICAgICAgICByZXR1cm4gZXZhbChjb21waWxlXyhyZWFkXyhjb2RlLCB1cmwpKSk7XG4gICAgfTtcbnZhciBydW4gPSBleHBvcnRzLnJ1biA9IGZ1bmN0aW9uIHJ1bihjb2RlLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGNvbXBpbGVfKHJlYWRfKGNvZGUsIHVybCkpKSgpO1xuICAgIH07XG52YXIgbG9hZCA9IGV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIGxvYWQodXJsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlID8gcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi93aXNwJykgOiB2b2lkIDA7XG4gICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCA/IHJlcXVlc3Quc3RhdHVzID09PSAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAyMDAgPyBjYWxsYmFjayhydW4ocmVxdWVzdC5yZXNwb25zZVRleHQsIHVybCkpIDogY2FsbGJhY2soJ0NvdWxkIG5vdCBsb2FkJykgOiB2b2lkIDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXF1ZXN0LnNlbmQobnVsbCk7XG4gICAgfTtcbnZhciBydW5TY3JpcHRzID0gZXhwb3J0cy5ydW5TY3JpcHRzID0gZnVuY3Rpb24gcnVuU2NyaXB0cygpIHtcbiAgICAgICAgdmFyIHNjcmlwdHMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLCBmdW5jdGlvbiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC50eXBlID09PSAnYXBwbGljYXRpb24vd2lzcCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHMubGVuZ3RoID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzY3JpcHTDuDEgPSBzY3JpcHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdMO4MS5zcmMgPyBsb2FkKHNjcmlwdMO4MS5zcmMsIG5leHQpIDogbmV4dChydW4oc2NyaXB0w7gxLmlubmVySFRNTCkpO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpIDogdm9pZCAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG5kb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgPyBydW5TY3JpcHRzKCkgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgcnVuU2NyaXB0cywgZmFsc2UpIDogd2luZG93LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCBydW5TY3JpcHRzKTsiLCJ7XG4gICAgdmFyIF9uc18gPSB7XG4gICAgICAgICAgICBpZDogJ3dpc3AuZXhwYW5kZXInLFxuICAgICAgICAgICAgZG9jOiAnd2lzcCBzeW50YXggYW5kIG1hY3JvIGV4cGFuZGVyIG1vZHVsZSdcbiAgICAgICAgfTtcbiAgICB2YXIgd2lzcF9hc3QgPSByZXF1aXJlKCcuL2FzdCcpO1xuICAgIHZhciBtZXRhID0gd2lzcF9hc3QubWV0YTtcbiAgICB2YXIgd2l0aE1ldGEgPSB3aXNwX2FzdC53aXRoTWV0YTtcbiAgICB2YXIgaXNTeW1ib2wgPSB3aXNwX2FzdC5pc1N5bWJvbDtcbiAgICB2YXIgaXNLZXl3b3JkID0gd2lzcF9hc3QuaXNLZXl3b3JkO1xuICAgIHZhciBpc1F1b3RlID0gd2lzcF9hc3QuaXNRdW90ZTtcbiAgICB2YXIgc3ltYm9sID0gd2lzcF9hc3Quc3ltYm9sO1xuICAgIHZhciBuYW1lc3BhY2UgPSB3aXNwX2FzdC5uYW1lc3BhY2U7XG4gICAgdmFyIG5hbWUgPSB3aXNwX2FzdC5uYW1lO1xuICAgIHZhciBpc1VucXVvdGUgPSB3aXNwX2FzdC5pc1VucXVvdGU7XG4gICAgdmFyIGlzVW5xdW90ZVNwbGljaW5nID0gd2lzcF9hc3QuaXNVbnF1b3RlU3BsaWNpbmc7XG4gICAgdmFyIHdpc3Bfc2VxdWVuY2UgPSByZXF1aXJlKCcuL3NlcXVlbmNlJyk7XG4gICAgdmFyIGlzTGlzdCA9IHdpc3Bfc2VxdWVuY2UuaXNMaXN0O1xuICAgIHZhciBsaXN0ID0gd2lzcF9zZXF1ZW5jZS5saXN0O1xuICAgIHZhciBjb25qID0gd2lzcF9zZXF1ZW5jZS5jb25qO1xuICAgIHZhciBwYXJ0aXRpb24gPSB3aXNwX3NlcXVlbmNlLnBhcnRpdGlvbjtcbiAgICB2YXIgc2VxID0gd2lzcF9zZXF1ZW5jZS5zZXE7XG4gICAgdmFyIGlzRW1wdHkgPSB3aXNwX3NlcXVlbmNlLmlzRW1wdHk7XG4gICAgdmFyIG1hcCA9IHdpc3Bfc2VxdWVuY2UubWFwO1xuICAgIHZhciB2ZWMgPSB3aXNwX3NlcXVlbmNlLnZlYztcbiAgICB2YXIgaXNFdmVyeSA9IHdpc3Bfc2VxdWVuY2UuaXNFdmVyeTtcbiAgICB2YXIgY29uY2F0ID0gd2lzcF9zZXF1ZW5jZS5jb25jYXQ7XG4gICAgdmFyIGZpcnN0ID0gd2lzcF9zZXF1ZW5jZS5maXJzdDtcbiAgICB2YXIgc2Vjb25kID0gd2lzcF9zZXF1ZW5jZS5zZWNvbmQ7XG4gICAgdmFyIHRoaXJkID0gd2lzcF9zZXF1ZW5jZS50aGlyZDtcbiAgICB2YXIgcmVzdCA9IHdpc3Bfc2VxdWVuY2UucmVzdDtcbiAgICB2YXIgbGFzdCA9IHdpc3Bfc2VxdWVuY2UubGFzdDtcbiAgICB2YXIgYnV0bGFzdCA9IHdpc3Bfc2VxdWVuY2UuYnV0bGFzdDtcbiAgICB2YXIgaW50ZXJsZWF2ZSA9IHdpc3Bfc2VxdWVuY2UuaW50ZXJsZWF2ZTtcbiAgICB2YXIgY29ucyA9IHdpc3Bfc2VxdWVuY2UuY29ucztcbiAgICB2YXIgY291bnQgPSB3aXNwX3NlcXVlbmNlLmNvdW50O1xuICAgIHZhciBzb21lID0gd2lzcF9zZXF1ZW5jZS5zb21lO1xuICAgIHZhciBhc3NvYyA9IHdpc3Bfc2VxdWVuY2UuYXNzb2M7XG4gICAgdmFyIHJlZHVjZSA9IHdpc3Bfc2VxdWVuY2UucmVkdWNlO1xuICAgIHZhciBmaWx0ZXIgPSB3aXNwX3NlcXVlbmNlLmZpbHRlcjtcbiAgICB2YXIgaXNTZXEgPSB3aXNwX3NlcXVlbmNlLmlzU2VxO1xuICAgIHZhciB3aXNwX3J1bnRpbWUgPSByZXF1aXJlKCcuL3J1bnRpbWUnKTtcbiAgICB2YXIgaXNOaWwgPSB3aXNwX3J1bnRpbWUuaXNOaWw7XG4gICAgdmFyIGlzRGljdGlvbmFyeSA9IHdpc3BfcnVudGltZS5pc0RpY3Rpb25hcnk7XG4gICAgdmFyIGlzVmVjdG9yID0gd2lzcF9ydW50aW1lLmlzVmVjdG9yO1xuICAgIHZhciBrZXlzID0gd2lzcF9ydW50aW1lLmtleXM7XG4gICAgdmFyIHZhbHMgPSB3aXNwX3J1bnRpbWUudmFscztcbiAgICB2YXIgaXNTdHJpbmcgPSB3aXNwX3J1bnRpbWUuaXNTdHJpbmc7XG4gICAgdmFyIGlzTnVtYmVyID0gd2lzcF9ydW50aW1lLmlzTnVtYmVyO1xuICAgIHZhciBpc0Jvb2xlYW4gPSB3aXNwX3J1bnRpbWUuaXNCb29sZWFuO1xuICAgIHZhciBpc0RhdGUgPSB3aXNwX3J1bnRpbWUuaXNEYXRlO1xuICAgIHZhciBpc1JlUGF0dGVybiA9IHdpc3BfcnVudGltZS5pc1JlUGF0dGVybjtcbiAgICB2YXIgaXNFdmVuID0gd2lzcF9ydW50aW1lLmlzRXZlbjtcbiAgICB2YXIgaXNFcXVhbCA9IHdpc3BfcnVudGltZS5pc0VxdWFsO1xuICAgIHZhciBtYXggPSB3aXNwX3J1bnRpbWUubWF4O1xuICAgIHZhciBpbmMgPSB3aXNwX3J1bnRpbWUuaW5jO1xuICAgIHZhciBkZWMgPSB3aXNwX3J1bnRpbWUuZGVjO1xuICAgIHZhciBkaWN0aW9uYXJ5ID0gd2lzcF9ydW50aW1lLmRpY3Rpb25hcnk7XG4gICAgdmFyIHN1YnMgPSB3aXNwX3J1bnRpbWUuc3VicztcbiAgICB2YXIgd2lzcF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZycpO1xuICAgIHZhciBzcGxpdCA9IHdpc3Bfc3RyaW5nLnNwbGl0O1xufVxudmFyIF9fbWFjcm9zX18gPSBleHBvcnRzLl9fbWFjcm9zX18gPSB7fTtcbnZhciBleHBhbmQgPSBmdW5jdGlvbiBleHBhbmQoZXhwYW5kZXIsIGZvcm0sIGVudikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YcO4MSA9IG1ldGEoZm9ybSkgfHwge307XG4gICAgICAgIHZhciBwYXJtYXPDuDEgPSByZXN0KGZvcm0pO1xuICAgICAgICB2YXIgaW1wbGljaXTDuDEgPSBtYXAoZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWwoJyZmb3JtJywgJDEpID8gZm9ybSA6IGlzRXF1YWwoJyZlbnYnLCAkMSkgPyBlbnYgOiAnZWxzZScgPyAkMSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH0sIChtZXRhKGV4cGFuZGVyKSB8fCAwKVsnaW1wbGljaXQnXSB8fCBbXSk7XG4gICAgICAgIHZhciBwYXJhbXPDuDEgPSB2ZWMoY29uY2F0KGltcGxpY2l0w7gxLCB2ZWMocmVzdChmb3JtKSkpKTtcbiAgICAgICAgdmFyIGV4cGFuc2lvbsO4MSA9IGV4cGFuZGVyLmFwcGx5KHZvaWQgMCwgcGFyYW1zw7gxKTtcbiAgICAgICAgcmV0dXJuIGV4cGFuc2lvbsO4MSA/IHdpdGhNZXRhKGV4cGFuc2lvbsO4MSwgY29uaihtZXRhZGF0YcO4MSwgbWV0YShleHBhbnNpb27DuDEpKSkgOiBleHBhbnNpb27DuDE7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBpbnN0YWxsTWFjcm8gPSBleHBvcnRzLmluc3RhbGxNYWNybyA9IGZ1bmN0aW9uIGluc3RhbGxNYWNybyhvcCwgZXhwYW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIChfX21hY3Jvc19fIHx8IDApW25hbWUob3ApXSA9IGV4cGFuZGVyO1xuICAgIH07XG52YXIgbWFjcm8gPSBmdW5jdGlvbiBtYWNybyhvcCkge1xuICAgIHJldHVybiBpc1N5bWJvbChvcCkgJiYgKF9fbWFjcm9zX18gfHwgMClbbmFtZShvcCldO1xufTtcbnZhciBpc01ldGhvZFN5bnRheCA9IGV4cG9ydHMuaXNNZXRob2RTeW50YXggPSBmdW5jdGlvbiBpc01ldGhvZFN5bnRheChvcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkw7gxID0gaXNTeW1ib2wob3ApICYmIG5hbWUob3ApO1xuICAgICAgICAgICAgcmV0dXJuIGlkw7gxICYmICcuJyA9PT0gZmlyc3QoaWTDuDEpICYmICEoJy0nID09PSBzZWNvbmQoaWTDuDEpKSAmJiAhKCcuJyA9PT0gaWTDuDEpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBpc0ZpZWxkU3ludGF4ID0gZXhwb3J0cy5pc0ZpZWxkU3ludGF4ID0gZnVuY3Rpb24gaXNGaWVsZFN5bnRheChvcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkw7gxID0gaXNTeW1ib2wob3ApICYmIG5hbWUob3ApO1xuICAgICAgICAgICAgcmV0dXJuIGlkw7gxICYmICcuJyA9PT0gZmlyc3QoaWTDuDEpICYmICctJyA9PT0gc2Vjb25kKGlkw7gxKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgaXNOZXdTeW50YXggPSBleHBvcnRzLmlzTmV3U3ludGF4ID0gZnVuY3Rpb24gaXNOZXdTeW50YXgob3ApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZMO4MSA9IGlzU3ltYm9sKG9wKSAmJiBuYW1lKG9wKTtcbiAgICAgICAgICAgIHJldHVybiBpZMO4MSAmJiAnLicgPT09IGxhc3QoaWTDuDEpICYmICEoJy4nID09PSBpZMO4MSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIG1ldGhvZFN5bnRheCA9IGV4cG9ydHMubWV0aG9kU3ludGF4ID0gZnVuY3Rpb24gbWV0aG9kU3ludGF4KG9wLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3BNZXRhw7gxID0gbWV0YShvcCk7XG4gICAgICAgICAgICB2YXIgZm9ybVN0YXJ0w7gxID0gKG9wTWV0YcO4MSB8fCAwKVsnc3RhcnQnXTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNZXRhw7gxID0gbWV0YSh0YXJnZXQpO1xuICAgICAgICAgICAgdmFyIG1lbWJlcsO4MSA9IHdpdGhNZXRhKHN5bWJvbChzdWJzKG5hbWUob3ApLCAxKSksIGNvbmoob3BNZXRhw7gxLCB7XG4gICAgICAgICAgICAgICAgICAgICdzdGFydCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lJzogKGZvcm1TdGFydMO4MSB8fCAwKVsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbic6IGluYygoZm9ybVN0YXJ0w7gxIHx8IDApWydjb2x1bW4nXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHZhciBhZ2V0w7gxID0gd2l0aE1ldGEoc3ltYm9sKHZvaWQgMCwgJ2FnZXQnKSwgY29uaihvcE1ldGHDuDEsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2VuZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lJzogKGZvcm1TdGFydMO4MSB8fCAwKVsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbic6IGluYygoZm9ybVN0YXJ0w7gxIHx8IDApWydjb2x1bW4nXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHZhciBtZXRob2TDuDEgPSB3aXRoTWV0YShsaXN0LmFwcGx5KHZvaWQgMCwgW2FnZXTDuDFdLmNvbmNhdChbdGFyZ2V0XSwgW2xpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ3F1b3RlJyldLmNvbmNhdChbbWVtYmVyw7gxXSkpXSkpLCBjb25qKG9wTWV0YcO4MSwgeyAnZW5kJzogKG1ldGEodGFyZ2V0KSB8fCAwKVsnZW5kJ10gfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmlsKHRhcmdldCkgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdNYWxmb3JtZWQgbWV0aG9kIGV4cHJlc3Npb24sIGV4cGVjdGluZyAoLm1ldGhvZCBvYmplY3QgLi4uKScpO1xuICAgICAgICAgICAgfSkoKSA6IGxpc3QuYXBwbHkodm9pZCAwLCBbbWV0aG9kw7gxXS5jb25jYXQodmVjKHBhcmFtcykpKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgZmllbGRTeW50YXggPSBleHBvcnRzLmZpZWxkU3ludGF4ID0gZnVuY3Rpb24gZmllbGRTeW50YXgoZmllbGQsIHRhcmdldCkge1xuICAgICAgICB2YXIgbW9yZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGHDuDEgPSBtZXRhKGZpZWxkKTtcbiAgICAgICAgICAgIHZhciBzdGFydMO4MSA9IChtZXRhZGF0YcO4MSB8fCAwKVsnc3RhcnQnXTtcbiAgICAgICAgICAgIHZhciBlbmTDuDEgPSAobWV0YWRhdGHDuDEgfHwgMClbJ2VuZCddO1xuICAgICAgICAgICAgdmFyIG1lbWJlcsO4MSA9IHdpdGhNZXRhKHN5bWJvbChzdWJzKG5hbWUoZmllbGQpLCAyKSksIGNvbmoobWV0YWRhdGHDuDEsIHtcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXJ0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUnOiAoc3RhcnTDuDEgfHwgMClbJ2xpbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2x1bW4nOiAoc3RhcnTDuDEgfHwgMClbJ2NvbHVtbiddICsgMlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmlsKHRhcmdldCkgfHwgY291bnQobW9yZSkgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdNYWxmb3JtZWQgbWVtYmVyIGV4cHJlc3Npb24sIGV4cGVjdGluZyAoLi1tZW1iZXIgdGFyZ2V0KScpO1xuICAgICAgICAgICAgfSkoKSA6IGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2FnZXQnKV0uY29uY2F0KFt0YXJnZXRdLCBbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAncXVvdGUnKV0uY29uY2F0KFttZW1iZXLDuDFdKSldKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIG5ld1N5bnRheCA9IGV4cG9ydHMubmV3U3ludGF4ID0gZnVuY3Rpb24gbmV3U3ludGF4KG9wKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkw7gxID0gbmFtZShvcCk7XG4gICAgICAgICAgICB2YXIgaWRNZXRhw7gxID0gKGlkw7gxIHx8IDApWydtZXRhJ107XG4gICAgICAgICAgICB2YXIgcmVuYW1lw7gxID0gc3VicyhpZMO4MSwgMCwgZGVjKGNvdW50KGlkw7gxKSkpO1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yw7gxID0gd2l0aE1ldGEoc3ltYm9sKHJlbmFtZcO4MSksIGNvbmooaWRNZXRhw7gxLCB7XG4gICAgICAgICAgICAgICAgICAgICdlbmQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbGluZSc6ICgoaWRNZXRhw7gxIHx8IDApWydlbmQnXSB8fCAwKVsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbic6IGRlYygoKGlkTWV0YcO4MSB8fCAwKVsnZW5kJ10gfHwgMClbJ2NvbHVtbiddKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yw7gxID0gd2l0aE1ldGEoc3ltYm9sKHZvaWQgMCwgJ25ldycpLCBjb25qKGlkTWV0YcO4MSwge1xuICAgICAgICAgICAgICAgICAgICAnc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbGluZSc6ICgoaWRNZXRhw7gxIHx8IDApWydlbmQnXSB8fCAwKVsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbic6IGRlYygoKGlkTWV0YcO4MSB8fCAwKVsnZW5kJ10gfHwgMClbJ2NvbHVtbiddKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ25ldycpXS5jb25jYXQoW2NvbnN0cnVjdG9yw7gxXSwgdmVjKHBhcmFtcykpKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIga2V5d29yZEludm9rZSA9IGV4cG9ydHMua2V5d29yZEludm9rZSA9IGZ1bmN0aW9uIGtleXdvcmRJbnZva2Uoa2V5d29yZCwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdnZXQnKV0uY29uY2F0KFt0YXJnZXRdLCBba2V5d29yZF0pKTtcbiAgICB9O1xudmFyIGRlc3VnYXIgPSBmdW5jdGlvbiBkZXN1Z2FyKGV4cGFuZGVyLCBmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3VnYXJlZMO4MSA9IGV4cGFuZGVyLmFwcGx5KHZvaWQgMCwgdmVjKGZvcm0pKTtcbiAgICAgICAgdmFyIG1ldGFkYXRhw7gxID0gY29uaih7fSwgbWV0YShmb3JtKSwgbWV0YShkZXN1Z2FyZWTDuDEpKTtcbiAgICAgICAgcmV0dXJuIHdpdGhNZXRhKGRlc3VnYXJlZMO4MSwgbWV0YWRhdGHDuDEpO1xuICAgIH0uY2FsbCh0aGlzKTtcbn07XG52YXIgbWFjcm9leHBhbmQxID0gZXhwb3J0cy5tYWNyb2V4cGFuZDEgPSBmdW5jdGlvbiBtYWNyb2V4cGFuZDEoZm9ybSwgZW52KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3DDuDEgPSBpc0xpc3QoZm9ybSkgJiYgZmlyc3QoZm9ybSk7XG4gICAgICAgICAgICB2YXIgZXhwYW5kZXLDuDEgPSBtYWNybyhvcMO4MSk7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kZXLDuDEgPyBleHBhbmQoZXhwYW5kZXLDuDEsIGZvcm0sIGVudikgOiBpc0tleXdvcmQob3DDuDEpID8gZGVzdWdhcihrZXl3b3JkSW52b2tlLCBmb3JtKSA6IGlzRmllbGRTeW50YXgob3DDuDEpID8gZGVzdWdhcihmaWVsZFN5bnRheCwgZm9ybSkgOiBpc01ldGhvZFN5bnRheChvcMO4MSkgPyBkZXN1Z2FyKG1ldGhvZFN5bnRheCwgZm9ybSkgOiBpc05ld1N5bnRheChvcMO4MSkgPyBkZXN1Z2FyKG5ld1N5bnRheCwgZm9ybSkgOiAnZWxzZScgPyBmb3JtIDogdm9pZCAwO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBtYWNyb2V4cGFuZCA9IGV4cG9ydHMubWFjcm9leHBhbmQgPSBmdW5jdGlvbiBtYWNyb2V4cGFuZChmb3JtLCBlbnYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsw7gxID0gZm9ybTtcbiAgICAgICAgICAgIHZhciBleHBhbmRlZMO4MSA9IG1hY3JvZXhwYW5kMShmb3JtLCBlbnYpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gb3JpZ2luYWzDuDEgPT09IGV4cGFuZGVkw7gxID8gb3JpZ2luYWzDuDEgOiAobG9vcFswXSA9IGV4cGFuZGVkw7gxLCBsb29wWzFdID0gbWFjcm9leHBhbmQxKGV4cGFuZGVkw7gxLCBlbnYpLCBsb29wKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG9yaWdpbmFsw7gxID0gbG9vcFswXSwgZXhwYW5kZWTDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHN5bnRheFF1b3RlID0gZXhwb3J0cy5zeW50YXhRdW90ZSA9IGZ1bmN0aW9uIHN5bnRheFF1b3RlKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGlzU3ltYm9sKGZvcm0pID8gbGlzdChzeW1ib2wodm9pZCAwLCAncXVvdGUnKSwgZm9ybSkgOiBpc0tleXdvcmQoZm9ybSkgPyBsaXN0KHN5bWJvbCh2b2lkIDAsICdxdW90ZScpLCBmb3JtKSA6IGlzTnVtYmVyKGZvcm0pIHx8IGlzU3RyaW5nKGZvcm0pIHx8IGlzQm9vbGVhbihmb3JtKSB8fCBpc05pbChmb3JtKSB8fCBpc1JlUGF0dGVybihmb3JtKSA/IGZvcm0gOiBpc1VucXVvdGUoZm9ybSkgPyBzZWNvbmQoZm9ybSkgOiBpc1VucXVvdGVTcGxpY2luZyhmb3JtKSA/IHJlYWRlckVycm9yKCdJbGxlZ2FsIHVzZSBvZiBgfkBgIGV4cHJlc3Npb24sIGNhbiBvbmx5IGJlIHByZXNlbnQgaW4gYSBsaXN0JykgOiBpc0VtcHR5KGZvcm0pID8gZm9ybSA6IGlzRGljdGlvbmFyeShmb3JtKSA/IGxpc3Qoc3ltYm9sKHZvaWQgMCwgJ2FwcGx5JyksIHN5bWJvbCh2b2lkIDAsICdkaWN0aW9uYXJ5JyksIGNvbnMoc3ltYm9sKHZvaWQgMCwgJy5jb25jYXQnKSwgc2VxdWVuY2VFeHBhbmQoY29uY2F0LmFwcGx5KHZvaWQgMCwgc2VxKGZvcm0pKSkpKSA6IGlzVmVjdG9yKGZvcm0pID8gY29ucyhzeW1ib2wodm9pZCAwLCAnLmNvbmNhdCcpLCBzZXF1ZW5jZUV4cGFuZChmb3JtKSkgOiBpc0xpc3QoZm9ybSkgPyBpc0VtcHR5KGZvcm0pID8gY29ucyhzeW1ib2wodm9pZCAwLCAnbGlzdCcpLCB2b2lkIDApIDogbGlzdChzeW1ib2wodm9pZCAwLCAnYXBwbHknKSwgc3ltYm9sKHZvaWQgMCwgJ2xpc3QnKSwgY29ucyhzeW1ib2wodm9pZCAwLCAnLmNvbmNhdCcpLCBzZXF1ZW5jZUV4cGFuZChmb3JtKSkpIDogJ2Vsc2UnID8gcmVhZGVyRXJyb3IoJ1Vua25vd24gQ29sbGVjdGlvbiB0eXBlJykgOiB2b2lkIDA7XG4gICAgfTtcbnZhciBzeW50YXhRdW90ZUV4cGFuZCA9IGV4cG9ydHMuc3ludGF4UXVvdGVFeHBhbmQgPSBzeW50YXhRdW90ZTtcbnZhciB1bnF1b3RlU3BsaWNpbmdFeHBhbmQgPSBleHBvcnRzLnVucXVvdGVTcGxpY2luZ0V4cGFuZCA9IGZ1bmN0aW9uIHVucXVvdGVTcGxpY2luZ0V4cGFuZChmb3JtKSB7XG4gICAgICAgIHJldHVybiBpc1ZlY3Rvcihmb3JtKSA/IGZvcm0gOiBsaXN0KHN5bWJvbCh2b2lkIDAsICd2ZWMnKSwgZm9ybSk7XG4gICAgfTtcbnZhciBzZXF1ZW5jZUV4cGFuZCA9IGV4cG9ydHMuc2VxdWVuY2VFeHBhbmQgPSBmdW5jdGlvbiBzZXF1ZW5jZUV4cGFuZChmb3Jtcykge1xuICAgICAgICByZXR1cm4gbWFwKGZ1bmN0aW9uIChmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNVbnF1b3RlKGZvcm0pID8gW3NlY29uZChmb3JtKV0gOiBpc1VucXVvdGVTcGxpY2luZyhmb3JtKSA/IHVucXVvdGVTcGxpY2luZ0V4cGFuZChzZWNvbmQoZm9ybSkpIDogJ2Vsc2UnID8gW3N5bnRheFF1b3RlRXhwYW5kKGZvcm0pXSA6IHZvaWQgMDtcbiAgICAgICAgfSwgZm9ybXMpO1xuICAgIH07XG5pbnN0YWxsTWFjcm8oJ3N5bnRheC1xdW90ZScsIHN5bnRheFF1b3RlKTtcbnZhciBub3RFcXVhbCA9IGV4cG9ydHMubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbCgpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICByZXR1cm4gbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnbm90JyldLmNvbmNhdChbbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnPScpXS5jb25jYXQodmVjKGJvZHkpKSldKSk7XG4gICAgfTtcbmluc3RhbGxNYWNybygnbm90PScsIG5vdEVxdWFsKTtcbnZhciBleHBhbmRDb25kID0gZXhwb3J0cy5leHBhbmRDb25kID0gZnVuY3Rpb24gZXhwYW5kQ29uZCgpIHtcbiAgICAgICAgdmFyIGNsYXVzZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICByZXR1cm4gIWlzRW1wdHkoY2xhdXNlcykgPyBsaXN0KHN5bWJvbCh2b2lkIDAsICdpZicpLCBmaXJzdChjbGF1c2VzKSwgaXNFbXB0eShyZXN0KGNsYXVzZXMpKSA/IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignY29uZCByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBmb3JtcycpO1xuICAgICAgICB9KSgpIDogc2Vjb25kKGNsYXVzZXMpLCBjb25zKHN5bWJvbCh2b2lkIDAsICdjb25kJyksIHJlc3QocmVzdChjbGF1c2VzKSkpKSA6IHZvaWQgMDtcbiAgICB9O1xuaW5zdGFsbE1hY3JvKCdjb25kJywgZXhwYW5kQ29uZCk7XG52YXIgZXhwYW5kRGVmbiA9IGV4cG9ydHMuZXhwYW5kRGVmbiA9IGZ1bmN0aW9uIGV4cGFuZERlZm4oYW5kRm9ybSwgbmFtZSkge1xuICAgICAgICB2YXIgZG9jUGx1c01ldGFQbHVzQm9keSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZG9jw7gxID0gaXNTdHJpbmcoZmlyc3QoZG9jUGx1c01ldGFQbHVzQm9keSkpID8gZmlyc3QoZG9jUGx1c01ldGFQbHVzQm9keSkgOiB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgbWV0YVBsdXNCb2R5w7gxID0gZG9jw7gxID8gcmVzdChkb2NQbHVzTWV0YVBsdXNCb2R5KSA6IGRvY1BsdXNNZXRhUGx1c0JvZHk7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGHDuDEgPSBpc0RpY3Rpb25hcnkoZmlyc3QobWV0YVBsdXNCb2R5w7gxKSkgPyBjb25qKHsgJ2RvYyc6IGRvY8O4MSB9LCBmaXJzdChtZXRhUGx1c0JvZHnDuDEpKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gbWV0YWRhdGHDuDEgPyByZXN0KG1ldGFQbHVzQm9kecO4MSkgOiBtZXRhUGx1c0JvZHnDuDE7XG4gICAgICAgICAgICB2YXIgaWTDuDEgPSB3aXRoTWV0YShuYW1lLCBjb25qKG1ldGEobmFtZSkgfHwge30sIG1ldGFkYXRhw7gxKSk7XG4gICAgICAgICAgICB2YXIgZm7DuDEgPSB3aXRoTWV0YShsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdmbicpXS5jb25jYXQoW2lkw7gxXSwgdmVjKGJvZHnDuDEpKSksIG1ldGEoYW5kRm9ybSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QuYXBwbHkodm9pZCAwLCBbc3ltYm9sKHZvaWQgMCwgJ2RlZicpXS5jb25jYXQoW2lkw7gxXSwgW2Zuw7gxXSkpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbmluc3RhbGxNYWNybygnZGVmbicsIHdpdGhNZXRhKGV4cGFuZERlZm4sIHsgJ2ltcGxpY2l0JzogWycmZm9ybSddIH0pKTtcbnZhciBleHBhbmRQcml2YXRlRGVmbiA9IGV4cG9ydHMuZXhwYW5kUHJpdmF0ZURlZm4gPSBmdW5jdGlvbiBleHBhbmRQcml2YXRlRGVmbihuYW1lKSB7XG4gICAgICAgIHZhciBib2R5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YcO4MSA9IGNvbmoobWV0YShuYW1lKSB8fCB7fSwgeyAncHJpdmF0ZSc6IHRydWUgfSk7XG4gICAgICAgICAgICB2YXIgaWTDuDEgPSB3aXRoTWV0YShuYW1lLCBtZXRhZGF0YcO4MSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5hcHBseSh2b2lkIDAsIFtzeW1ib2wodm9pZCAwLCAnZGVmbicpXS5jb25jYXQoW2lkw7gxXSwgdmVjKGJvZHkpKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xuaW5zdGFsbE1hY3JvKCdkZWZuLScsIGV4cGFuZFByaXZhdGVEZWZuKTsiLCJ2YXIgQnVmZmVyPXJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfQnVmZmVyXCIpO21vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xyXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcclxuICByZXR1cm4gbmV3IEJ1ZmZlcihpbnB1dCkudG9TdHJpbmcoJ2Jhc2U2NCcpXHJcbn0iLCJ2YXIgZ2xvYmFsPXR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fTsvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1pY2hhZWwgRmljYXJyYSA8ZXNjb2RlZ2VuLmNvcHlyaWdodEBtaWNoYWVsLmZpY2FycmEubWU+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMyBJcmFrbGkgR296YWxpc2h2aWxpIDxyZm9iaWNAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgUm9iZXJ0IEd1c3QtQmFyZG9uIDxkb25hdGVAcm9iZXJ0Lmd1c3QtYmFyZG9uLm9yZz5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvaG4gRnJlZW1hbiA8amZyZWVtYW4wOEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMS0yMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgZ2VuZXJhdGVTdGF0ZW1lbnQ6dHJ1ZSwgZ2VuZXJhdGVFeHByZXNzaW9uOnRydWUsIHJlcXVpcmU6dHJ1ZSwgZ2xvYmFsOnRydWUqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU3ludGF4LFxuICAgICAgICBQcmVjZWRlbmNlLFxuICAgICAgICBCaW5hcnlQcmVjZWRlbmNlLFxuICAgICAgICBTb3VyY2VOb2RlLFxuICAgICAgICBlc3RyYXZlcnNlLFxuICAgICAgICBlc3V0aWxzLFxuICAgICAgICBpc0FycmF5LFxuICAgICAgICBiYXNlLFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIGpzb24sXG4gICAgICAgIHJlbnVtYmVyLFxuICAgICAgICBoZXhhZGVjaW1hbCxcbiAgICAgICAgcXVvdGVzLFxuICAgICAgICBlc2NhcGVsZXNzLFxuICAgICAgICBuZXdsaW5lLFxuICAgICAgICBzcGFjZSxcbiAgICAgICAgcGFyZW50aGVzZXMsXG4gICAgICAgIHNlbWljb2xvbnMsXG4gICAgICAgIHNhZmVDb25jYXRlbmF0aW9uLFxuICAgICAgICBkaXJlY3RpdmUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBwYXJzZSxcbiAgICAgICAgc291cmNlTWFwLFxuICAgICAgICBGT1JNQVRfTUlOSUZZLFxuICAgICAgICBGT1JNQVRfREVGQVVMVFM7XG5cbiAgICBlc3RyYXZlcnNlID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpO1xuICAgIGVzdXRpbHMgPSByZXF1aXJlKCdlc3V0aWxzJyk7XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiAnQ29tcHJlaGVuc2lvbkJsb2NrJyxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246ICdDb21wcmVoZW5zaW9uRXhwcmVzc2lvbicsXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6ICdEaXJlY3RpdmVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50JyxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogJ05ld0V4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdFBhdHRlcm46ICdPYmplY3RQYXR0ZXJuJyxcbiAgICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXG5cbiAgICB9O1xuXG4gICAgUHJlY2VkZW5jZSA9IHtcbiAgICAgICAgU2VxdWVuY2U6IDAsXG4gICAgICAgIFlpZWxkOiAxLFxuICAgICAgICBBc3NpZ25tZW50OiAxLFxuICAgICAgICBDb25kaXRpb25hbDogMixcbiAgICAgICAgQXJyb3dGdW5jdGlvbjogMixcbiAgICAgICAgTG9naWNhbE9SOiAzLFxuICAgICAgICBMb2dpY2FsQU5EOiA0LFxuICAgICAgICBCaXR3aXNlT1I6IDUsXG4gICAgICAgIEJpdHdpc2VYT1I6IDYsXG4gICAgICAgIEJpdHdpc2VBTkQ6IDcsXG4gICAgICAgIEVxdWFsaXR5OiA4LFxuICAgICAgICBSZWxhdGlvbmFsOiA5LFxuICAgICAgICBCaXR3aXNlU0hJRlQ6IDEwLFxuICAgICAgICBBZGRpdGl2ZTogMTEsXG4gICAgICAgIE11bHRpcGxpY2F0aXZlOiAxMixcbiAgICAgICAgVW5hcnk6IDEzLFxuICAgICAgICBQb3N0Zml4OiAxNCxcbiAgICAgICAgQ2FsbDogMTUsXG4gICAgICAgIE5ldzogMTYsXG4gICAgICAgIE1lbWJlcjogMTcsXG4gICAgICAgIFByaW1hcnk6IDE4XG4gICAgfTtcblxuICAgIEJpbmFyeVByZWNlZGVuY2UgPSB7XG4gICAgICAgICd8fCc6IFByZWNlZGVuY2UuTG9naWNhbE9SLFxuICAgICAgICAnJiYnOiBQcmVjZWRlbmNlLkxvZ2ljYWxBTkQsXG4gICAgICAgICd8JzogUHJlY2VkZW5jZS5CaXR3aXNlT1IsXG4gICAgICAgICdeJzogUHJlY2VkZW5jZS5CaXR3aXNlWE9SLFxuICAgICAgICAnJic6IFByZWNlZGVuY2UuQml0d2lzZUFORCxcbiAgICAgICAgJz09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJyE9JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJz09PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICchPT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnaXMnOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnaXNudCc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICc8JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPic6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJzw9JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPj0nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICdpbic6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJ2luc3RhbmNlb2YnOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc8PCc6IFByZWNlZGVuY2UuQml0d2lzZVNISUZULFxuICAgICAgICAnPj4nOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJz4+Pic6IFByZWNlZGVuY2UuQml0d2lzZVNISUZULFxuICAgICAgICAnKyc6IFByZWNlZGVuY2UuQWRkaXRpdmUsXG4gICAgICAgICctJzogUHJlY2VkZW5jZS5BZGRpdGl2ZSxcbiAgICAgICAgJyonOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlLFxuICAgICAgICAnJSc6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmUsXG4gICAgICAgICcvJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICBiYXNlOiBudWxsLFxuICAgICAgICAgICAgcGFyc2U6IG51bGwsXG4gICAgICAgICAgICBjb21tZW50OiBmYWxzZSxcbiAgICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJyAgICAnLFxuICAgICAgICAgICAgICAgICAgICBiYXNlOiAwLFxuICAgICAgICAgICAgICAgICAgICBhZGp1c3RNdWx0aWxpbmVDb21tZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3bGluZTogJ1xcbicsXG4gICAgICAgICAgICAgICAgc3BhY2U6ICcgJyxcbiAgICAgICAgICAgICAgICBqc29uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW51bWJlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgaGV4YWRlY2ltYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1b3RlczogJ3NpbmdsZScsXG4gICAgICAgICAgICAgICAgZXNjYXBlbGVzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyZW50aGVzZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbjogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3o6IHtcbiAgICAgICAgICAgICAgICBzdGFybGVzc0dlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyZW50aGVzaXplZENvbXByZWhlbnNpb25CbG9jazogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IG51bGwsXG4gICAgICAgICAgICBzb3VyY2VNYXBSb290OiBudWxsLFxuICAgICAgICAgICAgc291cmNlTWFwV2l0aENvZGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHZlcmJhdGltOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nUmVwZWF0KHN0ciwgbnVtKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgICBmb3IgKG51bSB8PSAwOyBudW0gPiAwOyBudW0gPj4+PSAxLCBzdHIgKz0gc3RyKSB7XG4gICAgICAgICAgICBpZiAobnVtICYgMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIGlmICghaXNBcnJheSkge1xuICAgICAgICBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIHRoZSBub24gU291cmNlTWFwIGVudmlyb25tZW50XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZU1vY2sobGluZSwgY29sdW1uLCBmaWxlbmFtZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW4oaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gaW5wdXQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuKGlucHV0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgU291cmNlTm9kZU1vY2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0dGVuKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICBTb3VyY2VOb2RlTW9jay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIHJlcyA9ICcnLCBpLCBpeiwgbm9kZTtcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTb3VyY2VOb2RlTW9jaykge1xuICAgICAgICAgICAgICAgIHJlcyArPSBub2RlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyArPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIFNvdXJjZU5vZGVNb2NrLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiByZXBsYWNlUmlnaHQocGF0dGVybiwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgU291cmNlTm9kZU1vY2spIHtcbiAgICAgICAgICAgIGxhc3QucmVwbGFjZVJpZ2h0KHBhdHRlcm4sIHJlcGxhY2VtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3QucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTb3VyY2VOb2RlTW9jay5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4oc2VwKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgaXogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGl6ID4gMCkge1xuICAgICAgICAgICAgLS1pejtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZHJlbltpXSwgc2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRyZW5baXpdKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhc0xpbmVUZXJtaW5hdG9yKHN0cikge1xuICAgICAgICByZXR1cm4gKC9bXFxyXFxuXS9nKS50ZXN0KHN0cik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kc1dpdGhMaW5lVGVybWluYXRvcihzdHIpIHtcbiAgICAgICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW4gJiYgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3Ioc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZXBseSh0YXJnZXQsIG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBrZXksIHZhbDtcblxuICAgICAgICBmdW5jdGlvbiBpc0hhc2hPYmplY3QodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0ICYmICEodGFyZ2V0IGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG92ZXJyaWRlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSGFzaE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hhc2hPYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVEZWVwbHkodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHVwZGF0ZURlZXBseSh7fSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHBvaW50LCB0ZW1wLCBleHBvbmVudCwgcG9zO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtZXJpYyBsaXRlcmFsIHdob3NlIHZhbHVlIGlzIE5hTicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWVyaWMgbGl0ZXJhbCB3aG9zZSB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAxIC8gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24gPyAnbnVsbCcgOiByZW51bWJlciA/ICcxZTQwMCcgOiAnMWUrNDAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9ICcnICsgdmFsdWU7XG4gICAgICAgIGlmICghcmVudW1iZXIgfHwgcmVzdWx0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludCA9IHJlc3VsdC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmICghanNvbiAmJiByZXN1bHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzMCAgLyogMCAqLyAmJiBwb2ludCA9PT0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSAwO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKCdlKycsICdlJyk7XG4gICAgICAgIGV4cG9uZW50ID0gMDtcbiAgICAgICAgaWYgKChwb3MgPSB0ZW1wLmluZGV4T2YoJ2UnKSkgPiAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCA9ICt0ZW1wLnNsaWNlKHBvcyArIDEpO1xuICAgICAgICAgICAgdGVtcCA9IHRlbXAuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQgPj0gMCkge1xuICAgICAgICAgICAgZXhwb25lbnQgLT0gdGVtcC5sZW5ndGggLSBwb2ludCAtIDE7XG4gICAgICAgICAgICB0ZW1wID0gKyh0ZW1wLnNsaWNlKDAsIHBvaW50KSArIHRlbXAuc2xpY2UocG9pbnQgKyAxKSkgKyAnJztcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSAwO1xuICAgICAgICB3aGlsZSAodGVtcC5jaGFyQ29kZUF0KHRlbXAubGVuZ3RoICsgcG9zIC0gMSkgPT09IDB4MzAgIC8qIDAgKi8pIHtcbiAgICAgICAgICAgIC0tcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgIT09IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50IC09IHBvcztcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9uZW50ICE9PSAwKSB7XG4gICAgICAgICAgICB0ZW1wICs9ICdlJyArIGV4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGVtcC5sZW5ndGggPCByZXN1bHQubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIChoZXhhZGVjaW1hbCAmJiB2YWx1ZSA+IDFlMTIgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlICYmICh0ZW1wID0gJzB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSkubGVuZ3RoIDwgcmVzdWx0Lmxlbmd0aCkpICYmXG4gICAgICAgICAgICAgICAgK3RlbXAgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSB2YWxpZCBSZWdFeHAgZXhwcmVzc2lvbi5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2l2IEVuZ2luZVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgIC8vIG5vdCBoYW5kbGluZyAnXFwnIGFuZCBoYW5kbGluZyBcXHUyMDI4IG9yIFxcdTIwMjkgdG8gdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKChjaCAmIH4xKSA9PT0gMHgyMDI4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAndScgOiAnXFxcXHUnKSArICgoY2ggPT09IDB4MjAyOCkgPyAnMjAyOCcgOiAnMjAyOScpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHsgIC8vIFxcbiwgXFxyXG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAnJyA6ICdcXFxcJykgKyAoKGNoID09PSAxMCkgPyAnbicgOiAncicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVJlZ0V4cChyZWcpIHtcbiAgICAgICAgdmFyIG1hdGNoLCByZXN1bHQsIGZsYWdzLCBpLCBpeiwgY2gsIGNoYXJhY3RlckluQnJhY2ssIHByZXZpb3VzSXNCYWNrc2xhc2g7XG5cbiAgICAgICAgcmVzdWx0ID0gcmVnLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHJlZy5zb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZmxhZyBmcm9tIHRvU3RyaW5nIHJlc3VsdFxuICAgICAgICAgICAgbWF0Y2ggPSByZXN1bHQubWF0Y2goL1xcLyhbXi9dKikkLyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxhZ3MgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHJlZy5zb3VyY2UubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGNoID0gcmVnLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJJbkJyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDkzKSB7ICAvLyBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0NykgeyAgLy8gL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA5MSkgeyAgLy8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gY2ggPT09IDkyOyAgLy8gXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBuZXcgUmVnRXhwKFwiXFxcXFxcbicpIGlzIHByb3ZpZGVkLCBjcmVhdGUgL1xcbi9cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlrZSAvXFxcXFsvXS9cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcvJyArIHJlc3VsdCArICcvJyArIGZsYWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNvZGUsIG5leHQpIHtcbiAgICAgICAgdmFyIGhleCwgcmVzdWx0ID0gJ1xcXFwnO1xuXG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIDB4MDggIC8qIFxcYiAqLzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAnYic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDBDICAvKiBcXGYgKi86XG4gICAgICAgICAgICByZXN1bHQgKz0gJ2YnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOSAgLyogXFx0ICovOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICd0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaGV4ID0gY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChqc29uIHx8IGNvZGUgPiAweEZGKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd1JyArICcwMDAwJy5zbGljZShoZXgubGVuZ3RoKSArIGhleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDAwICYmICFlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQobmV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMEIgIC8qIFxcdiAqLykgeyAvLyAnXFx2J1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneDBCJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd4JyArICcwMCcuc2xpY2UoaGV4Lmxlbmd0aCkgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlRGlzYWxsb3dlZENoYXJhY3Rlcihjb2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnXFxcXCc7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIDB4NUMgIC8qIFxcICovOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MEEgIC8qIFxcbiAqLzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAnbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDBEICAvKiBcXHIgKi86XG4gICAgICAgICAgICByZXN1bHQgKz0gJ3InO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyMDI4OlxuICAgICAgICAgICAgcmVzdWx0ICs9ICd1MjAyOCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDIwMjk6XG4gICAgICAgICAgICByZXN1bHQgKz0gJ3UyMDI5JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3RseSBjbGFzc2lmaWVkIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVEaXJlY3RpdmUoc3RyKSB7XG4gICAgICAgIHZhciBpLCBpeiwgY29kZSwgcXVvdGU7XG5cbiAgICAgICAgcXVvdGUgPSBxdW90ZXMgPT09ICdkb3VibGUnID8gJ1wiJyA6ICdcXCcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0ci5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyNyAgLyogJyAqLykge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJ1wiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAgLyogXCIgKi8pIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICdcXCcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdW90ZSArIHN0ciArIHF1b3RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLCBpLCBsZW4sIGNvZGUsIHNpbmdsZVF1b3RlcyA9IDAsIGRvdWJsZVF1b3RlcyA9IDAsIHNpbmdsZSwgcXVvdGU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyNyAgLyogJyAqLykge1xuICAgICAgICAgICAgICAgICsrc2luZ2xlUXVvdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICAvKiBcIiAqLykge1xuICAgICAgICAgICAgICAgICsrZG91YmxlUXVvdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJGICAvKiAvICovICYmIGpzb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKSB8fCBjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVEaXNhbGxvd2VkQ2hhcmFjdGVyKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoanNvbiAmJiBjb2RlIDwgMHgyMCAgLyogU1AgKi8pIHx8ICEoanNvbiB8fCBlc2NhcGVsZXNzIHx8IChjb2RlID49IDB4MjAgIC8qIFNQICovICYmIGNvZGUgPD0gMHg3RSAgLyogfiAqLykpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUFsbG93ZWRDaGFyYWN0ZXIoY29kZSwgc3RyLmNoYXJDb2RlQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2luZ2xlID0gIShxdW90ZXMgPT09ICdkb3VibGUnIHx8IChxdW90ZXMgPT09ICdhdXRvJyAmJiBkb3VibGVRdW90ZXMgPCBzaW5nbGVRdW90ZXMpKTtcbiAgICAgICAgcXVvdGUgPSBzaW5nbGUgPyAnXFwnJyA6ICdcIic7XG5cbiAgICAgICAgaWYgKCEoc2luZ2xlID8gc2luZ2xlUXVvdGVzIDogZG91YmxlUXVvdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlICsgcmVzdWx0ICsgcXVvdGU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHF1b3RlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKChjb2RlID09PSAweDI3ICAvKiAnICovICYmIHNpbmdsZSkgfHwgKGNvZGUgPT09IDB4MjIgIC8qIFwiICovICYmICFzaW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHF1b3RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvU291cmNlTm9kZShnZW5lcmF0ZWQsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZCBpbnN0YW5jZW9mIFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBzb3VyY2VNYXAsIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShub2RlLmxvYy5zdGFydC5saW5lLCBub2RlLmxvYy5zdGFydC5jb2x1bW4sIChzb3VyY2VNYXAgPT09IHRydWUgPyBub2RlLmxvYy5zb3VyY2UgfHwgbnVsbCA6IHNvdXJjZU1hcCksIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vRW1wdHlTcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIChzcGFjZSkgPyBzcGFjZSA6ICcgJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqb2luKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0U291cmNlID0gdG9Tb3VyY2VOb2RlKGxlZnQpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByaWdodFNvdXJjZSA9IHRvU291cmNlTm9kZShyaWdodCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGxlZnRDaGFyQ29kZSA9IGxlZnRTb3VyY2UuY2hhckNvZGVBdChsZWZ0U291cmNlLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgcmlnaHRDaGFyQ29kZSA9IHJpZ2h0U291cmNlLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUgfHxcbiAgICAgICAgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnQobGVmdENoYXJDb2RlKSAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydChyaWdodENoYXJDb2RlKSB8fFxuICAgICAgICBsZWZ0Q2hhckNvZGUgPT09IDB4MkYgIC8qIC8gKi8gJiYgcmlnaHRDaGFyQ29kZSA9PT0gMHg2OSAgLyogaSAqLykgeyAvLyBpbmZpeCB3b3JkIG9wZXJhdG9ycyBhbGwgc3RhcnQgd2l0aCBgaWBcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgbm9FbXB0eVNwYWNlKCksIHJpZ2h0XTtcbiAgICAgICAgfSBlbHNlIGlmIChlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGxlZnRDaGFyQ29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IobGVmdENoYXJDb2RlKSB8fFxuICAgICAgICAgICAgICAgIGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UocmlnaHRDaGFyQ29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IocmlnaHRDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGVmdCwgc3BhY2UsIHJpZ2h0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRJbmRlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gW2Jhc2UsIHN0bXRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhJbmRlbnQoZm4pIHtcbiAgICAgICAgdmFyIHByZXZpb3VzQmFzZSwgcmVzdWx0O1xuICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICBiYXNlICs9IGluZGVudDtcbiAgICAgICAgcmVzdWx0ID0gZm4uY2FsbCh0aGlzLCBiYXNlKTtcbiAgICAgICAgYmFzZSA9IHByZXZpb3VzQmFzZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVTcGFjZXMoc3RyKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihzdHIuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0ci5sZW5ndGggLSAxKSAtIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRqdXN0TXVsdGlsaW5lQ29tbWVudCh2YWx1ZSwgc3BlY2lhbEJhc2UpIHtcbiAgICAgICAgdmFyIGFycmF5LCBpLCBsZW4sIGxpbmUsIGosIHNwYWNlcywgcHJldmlvdXNCYXNlO1xuXG4gICAgICAgIGFycmF5ID0gdmFsdWUuc3BsaXQoL1xcclxcbnxbXFxyXFxuXS8pO1xuICAgICAgICBzcGFjZXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIC8vIGZpcnN0IGxpbmUgZG9lc24ndCBoYXZlIGluZGVudGF0aW9uXG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBsaW5lID0gYXJyYXlbaV07XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbGluZS5sZW5ndGggJiYgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShsaW5lLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwYWNlcyA+IGopIHtcbiAgICAgICAgICAgICAgICBzcGFjZXMgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjaWFsQmFzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHBhdHRlcm4gbGlrZVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICB2YXIgdCA9IDIwOyAgLypcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAqIHRoaXMgaXMgY29tbWVudFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICAgICAgaWYgKGFycmF5WzFdW3NwYWNlc10gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxCYXNlICs9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2UgPSBzcGVjaWFsQmFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcGFjZXMgJiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gLypcbiAgICAgICAgICAgICAgICAvLyAgKlxuICAgICAgICAgICAgICAgIC8vICAqL1xuICAgICAgICAgICAgICAgIC8vIElmIHNwYWNlcyBhcmUgb2RkIG51bWJlciwgYWJvdmUgcGF0dGVybiBpcyBjb25zaWRlcmVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIHdhc3RlIDEgc3BhY2UuXG4gICAgICAgICAgICAgICAgLS1zcGFjZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gdG9Tb3VyY2VOb2RlKGFkZEluZGVudChhcnJheVtpXS5zbGljZShzcGFjZXMpKSkuam9pbignJyk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlID0gcHJldmlvdXNCYXNlO1xuXG4gICAgICAgIHJldHVybiBhcnJheS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCwgc3BlY2lhbEJhc2UpIHtcbiAgICAgICAgaWYgKGNvbW1lbnQudHlwZSA9PT0gJ0xpbmUnKSB7XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGhMaW5lVGVybWluYXRvcihjb21tZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnLy8nICsgY29tbWVudC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBMaW5lVGVybWluYXRvclxuICAgICAgICAgICAgICAgIHJldHVybiAnLy8nICsgY29tbWVudC52YWx1ZSArICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5mb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQgJiYgL1tcXG5cXHJdLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRqdXN0TXVsdGlsaW5lQ29tbWVudCgnLyonICsgY29tbWVudC52YWx1ZSArICcqLycsIHNwZWNpYWxCYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy8qJyArIGNvbW1lbnQudmFsdWUgKyAnKi8nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnRzVG9TdGF0ZW1lbnQoc3RtdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNvbW1lbnQsIHNhdmUsIHRhaWxpbmdUb1N0YXRlbWVudCwgc3BlY2lhbEJhc2UsIGZyYWdtZW50O1xuXG4gICAgICAgIGlmIChzdG10LmxlYWRpbmdDb21tZW50cyAmJiBzdG10LmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzYXZlID0gcmVzdWx0O1xuXG4gICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGlmIChzYWZlQ29uY2F0ZW5hdGlvbiAmJiBzdG10LnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtICYmIHN0bXQuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBzdG10LmxlYWRpbmdDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCldO1xuICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGUoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZnJhZ21lbnQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KHNhdmUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdG10LnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgIHRhaWxpbmdUb1N0YXRlbWVudCA9ICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShyZXN1bHQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgc3BlY2lhbEJhc2UgPSBzdHJpbmdSZXBlYXQoJyAnLCBjYWxjdWxhdGVTcGFjZXModG9Tb3VyY2VOb2RlKFtiYXNlLCByZXN1bHQsIGluZGVudF0pLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0bXQudHJhaWxpbmdDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LnRyYWlsaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhaWxpbmdUb1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGFyZ2V0IGxpa2UgZm9sbG93aW5nIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgdCA9IDIwOyAgLyoqXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKiBUaGlzIGlzIGNvbW1lbnQgb2YgdFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBpbmRlbnRdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgc3BlY2lhbEJhc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50LCBzcGVjaWFsQmFzZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGxlbiAtIDEgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgJ1xcbiddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXplKHRleHQsIGN1cnJlbnQsIHNob3VsZCkge1xuICAgICAgICBpZiAoY3VycmVudCA8IHNob3VsZCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHRleHQsICcpJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF5YmVCbG9jayhzdG10LCBzZW1pY29sb25PcHRpb25hbCwgZnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgIHZhciByZXN1bHQsIG5vTGVhZGluZ0NvbW1lbnQ7XG5cbiAgICAgICAgbm9MZWFkaW5nQ29tbWVudCA9ICFleHRyYS5jb21tZW50IHx8ICFzdG10LmxlYWRpbmdDb21tZW50cztcblxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgbm9MZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzcGFjZSwgZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdCwgeyBmdW5jdGlvbkJvZHk6IGZ1bmN0aW9uQm9keSB9KV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguRW1wdHlTdGF0ZW1lbnQgJiYgbm9MZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuICc7JztcbiAgICAgICAgfVxuXG4gICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW25ld2xpbmUsIGFkZEluZGVudChnZW5lcmF0ZVN0YXRlbWVudChzdG10LCB7IHNlbWljb2xvbk9wdGlvbmFsOiBzZW1pY29sb25PcHRpb25hbCwgZnVuY3Rpb25Cb2R5OiBmdW5jdGlvbkJvZHkgfSkpXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXliZUJsb2NrU3VmZml4KHN0bXQsIHJlc3VsdCkge1xuICAgICAgICB2YXIgZW5kcyA9IGVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiAoIWV4dHJhLmNvbW1lbnQgfHwgIXN0bXQubGVhZGluZ0NvbW1lbnRzKSAmJiAhZW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIHNwYWNlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIGJhc2VdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVzdWx0LCBuZXdsaW5lLCBiYXNlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVZlcmJhdGltKGV4cHIsIG9wdGlvbikge1xuICAgICAgICB2YXIgaSwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBleHByW2V4dHJhLnZlcmJhdGltXS5zcGxpdCgvXFxyXFxufFxcbi8pO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBuZXdsaW5lICsgYmFzZSArIHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIG9wdGlvbi5wcmVjZWRlbmNlKTtcbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZShyZXN1bHQsIGV4cHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSWRlbnRpZmllcihub2RlKSB7XG4gICAgICAgIHJldHVybiB0b1NvdXJjZU5vZGUobm9kZS5uYW1lLCBub2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUZ1bmN0aW9uQm9keShub2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGksIGxlbiwgZXhwciwgYXJyb3c7XG5cbiAgICAgICAgYXJyb3cgPSBub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcblxuICAgICAgICBpZiAoYXJyb3cgJiYgbm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmIG5vZGUucGFyYW1zWzBdLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBhcmcgPT4geyB9IGNhc2VcbiAgICAgICAgICAgIHJlc3VsdCA9IFtnZW5lcmF0ZUlkZW50aWZpZXIobm9kZS5wYXJhbXNbMF0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsnKCddO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5wYXJhbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUlkZW50aWZpZXIobm9kZS5wYXJhbXNbaV0pKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlLCAnPT4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIGV4cHIgPSBnZW5lcmF0ZUV4cHJlc3Npb24obm9kZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChleHByLnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBleHByID0gWycoJywgZXhwciwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4cHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWF5YmVCbG9jayhub2RlLmJvZHksIGZhbHNlLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwciwgb3B0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICBwcmVjZWRlbmNlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnRQcmVjZWRlbmNlLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgIGZyYWdtZW50LFxuICAgICAgICAgICAgbXVsdGlsaW5lLFxuICAgICAgICAgICAgbGVmdENoYXJDb2RlLFxuICAgICAgICAgICAgbGVmdFNvdXJjZSxcbiAgICAgICAgICAgIHJpZ2h0Q2hhckNvZGUsXG4gICAgICAgICAgICBhbGxvd0luLFxuICAgICAgICAgICAgYWxsb3dDYWxsLFxuICAgICAgICAgICAgYWxsb3dVbnBhcmVudGhlc2l6ZWROZXcsXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBwcmVjZWRlbmNlID0gb3B0aW9uLnByZWNlZGVuY2U7XG4gICAgICAgIGFsbG93SW4gPSBvcHRpb24uYWxsb3dJbjtcbiAgICAgICAgYWxsb3dDYWxsID0gb3B0aW9uLmFsbG93Q2FsbDtcbiAgICAgICAgdHlwZSA9IGV4cHIudHlwZSB8fCBvcHRpb24udHlwZTtcblxuICAgICAgICBpZiAoZXh0cmEudmVyYmF0aW0gJiYgZXhwci5oYXNPd25Qcm9wZXJ0eShleHRyYS52ZXJiYXRpbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVZlcmJhdGltKGV4cHIsIG9wdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uOlxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBhbGxvd0luIHw9IChQcmVjZWRlbmNlLlNlcXVlbmNlIDwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbnNbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgYWxsb3dJbiB8PSAoUHJlY2VkZW5jZS5Bc3NpZ25tZW50IDwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkNhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArIGV4cHIub3BlcmF0b3IgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGFsbG93SW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246XG4gICAgICAgICAgICBhbGxvd0luIHw9IChQcmVjZWRlbmNlLkFycm93RnVuY3Rpb24gPCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShnZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKSwgUHJlY2VkZW5jZS5BcnJvd0Z1bmN0aW9uLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGFsbG93SW4gfD0gKFByZWNlZGVuY2UuQ29uZGl0aW9uYWwgPCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnRlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuTG9naWNhbE9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnPycgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY29uc2VxdWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnOicgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYWx0ZXJuYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLkNvbmRpdGlvbmFsLFxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbjpcbiAgICAgICAgY2FzZSBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGN1cnJlbnRQcmVjZWRlbmNlID0gQmluYXJ5UHJlY2VkZW5jZVtleHByLm9wZXJhdG9yXTtcblxuICAgICAgICAgICAgYWxsb3dJbiB8PSAoY3VycmVudFByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKTtcblxuICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogY3VycmVudFByZWNlZGVuY2UsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0U291cmNlID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKGxlZnRTb3VyY2UuY2hhckNvZGVBdChsZWZ0U291cmNlLmxlbmd0aCAtIDEpID09PSAweDJGIC8qIC8gKi8gJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnQoZXhwci5vcGVyYXRvci5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtmcmFnbWVudCwgbm9FbXB0eVNwYWNlKCksIGV4cHIub3BlcmF0b3JdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKGZyYWdtZW50LCBleHByLm9wZXJhdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCwge1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IGN1cnJlbnRQcmVjZWRlbmNlICsgMSxcbiAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChleHByLm9wZXJhdG9yID09PSAnLycgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5jaGFyQXQoMCkgPT09ICcvJyB8fFxuICAgICAgICAgICAgZXhwci5vcGVyYXRvci5zbGljZSgtMSkgPT09ICc8JyAmJiBmcmFnbWVudC50b1N0cmluZygpLnNsaWNlKDAsIDMpID09PSAnIS0tJykge1xuICAgICAgICAgICAgICAgIC8vIElmICcvJyBjb25jYXRzIHdpdGggJy8nIG9yIGA8YCBjb25jYXRzIHdpdGggYCEtLWAsIGl0IGlzIGludGVycHJldGVkIGFzIGNvbW1lbnQgc3RhcnRcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJ2luJyAmJiAhYWxsb3dJbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgY3VycmVudFByZWNlZGVuY2UsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IFtnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUsIHtcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkNhbGwsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dVbnBhcmVudGhlc2l6ZWROZXc6IGZhbHNlXG4gICAgICAgICAgICB9KV07XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHByWydhcmd1bWVudHMnXS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlRXhwcmVzc2lvbihleHByWydhcmd1bWVudHMnXVtpXSwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG5cbiAgICAgICAgICAgIGlmICghYWxsb3dDYWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWycoJywgcmVzdWx0LCAnKSddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkNhbGwsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguTmV3RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGxlbiA9IGV4cHJbJ2FyZ3VtZW50cyddLmxlbmd0aDtcbiAgICAgICAgICAgIGFsbG93VW5wYXJlbnRoZXNpemVkTmV3ID0gb3B0aW9uLmFsbG93VW5wYXJlbnRoZXNpemVkTmV3ID09PSB1bmRlZmluZWQgfHwgb3B0aW9uLmFsbG93VW5wYXJlbnRoZXNpemVkTmV3O1xuXG4gICAgICAgICAgICByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgICduZXcnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmNhbGxlZSwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLk5ldyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dVbnBhcmVudGhlc2l6ZWROZXc6IGFsbG93VW5wYXJlbnRoZXNpemVkTmV3ICYmICFwYXJlbnRoZXNlcyAmJiBsZW4gPT09IDBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFhbGxvd1VucGFyZW50aGVzaXplZE5ldyB8fCBwYXJlbnRoZXNlcyB8fCBsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJygnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHJbJ2FyZ3VtZW50cyddW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5OZXcsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IFtnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5vYmplY3QsIHtcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkNhbGwsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IGFsbG93Q2FsbCxcbiAgICAgICAgICAgICAgICBhbGxvd1VucGFyZW50aGVzaXplZE5ldzogZmFsc2VcbiAgICAgICAgICAgIH0pXTtcblxuICAgICAgICAgICAgaWYgKGV4cHIuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnWycsIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnR5LCB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogYWxsb3dDYWxsXG4gICAgICAgICAgICAgICAgfSksICddJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9iamVjdC50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2YgZXhwci5vYmplY3QudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGFsbCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDEuIE5vIGZsb2F0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgMi4gRG9uJ3QgaGF2ZSBleHBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAzLiBUaGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBkZWNpbWFsIGRpZ2l0XG4gICAgICAgICAgICAgICAgICAgIC8vICAgNC4gTm90IGhleGFkZWNpbWFsIE9SIG9jdGFsIG51bWJlciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhZGQgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmluZGV4T2YoJy4nKSA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhL1tlRXhYXS8udGVzdChmcmFnbWVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoZnJhZ21lbnQuY2hhckNvZGVBdChmcmFnbWVudC5sZW5ndGggLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZyYWdtZW50Lmxlbmd0aCA+PSAyICYmIGZyYWdtZW50LmNoYXJDb2RlQXQoMCkgPT09IDQ4KSAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuJywgZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIucHJvcGVydHkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5NZW1iZXIsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguVW5hcnlFeHByZXNzaW9uOlxuICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwge1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuVW5hcnksXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc3BhY2UgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihleHByLm9wZXJhdG9yLCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvci5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSwgdm9pZCwgdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBgdHlwZW9mIFtdYCwgbm90IGB0eXBlb2ZbXWBcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGluc2VydGluZyBzcGFjZXMgYmV0d2VlbiBvcGVyYXRvciBhbmQgYXJndW1lbnQgaWYgaXQgaXMgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlrZSwgYCFjb25kYFxuICAgICAgICAgICAgICAgICAgICBsZWZ0U291cmNlID0gdG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdENoYXJDb2RlID0gbGVmdFNvdXJjZS5jaGFyQ29kZUF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2hhckNvZGUgPSBmcmFnbWVudC50b1N0cmluZygpLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgobGVmdENoYXJDb2RlID09PSAweDJCICAvKiArICovIHx8IGxlZnRDaGFyQ29kZSA9PT0gMHgyRCAgLyogLSAqLykgJiYgbGVmdENoYXJDb2RlID09PSByaWdodENoYXJDb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydChsZWZ0Q2hhckNvZGUpICYmIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0KHJpZ2h0Q2hhckNvZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCksIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuVW5hcnksIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguWWllbGRFeHByZXNzaW9uOlxuICAgICAgICAgICAgaWYgKGV4cHIuZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAneWllbGQqJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3lpZWxkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLmFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5ZaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5ZaWVsZCwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5VcGRhdGVFeHByZXNzaW9uOlxuICAgICAgICAgICAgaWYgKGV4cHIucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlVuYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLlVuYXJ5LFxuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuUG9zdGZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLm9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuUG9zdGZpeCxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb246XG4gICAgICAgICAgICByZXN1bHQgPSAnZnVuY3Rpb24nO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5pZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCArIHNwYWNlLCBnZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5UGF0dGVybjpcbiAgICAgICAgY2FzZSBTeW50YXguQXJyYXlFeHByZXNzaW9uOlxuICAgICAgICAgICAgaWYgKCFleHByLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdbXSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aWxpbmUgPSBleHByLmVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgICAgICAgICByZXN1bHQgPSBbJ1snLCBtdWx0aWxpbmUgPyBuZXdsaW5lIDogJyddO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwci5lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cHIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycsIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmVsZW1lbnRzW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmUgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGJhc2UgOiAnJywgJ10nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlByb3BlcnR5OlxuICAgICAgICAgICAgaWYgKGV4cHIua2luZCA9PT0gJ2dldCcgfHwgZXhwci5raW5kID09PSAnc2V0Jykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5raW5kLCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIua2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwci52YWx1ZSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5zaG9ydGhhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIua2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcqJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIua2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSwgZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzonICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci52YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5PYmplY3RFeHByZXNzaW9uOlxuICAgICAgICAgICAgaWYgKCFleHByLnByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3t9JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11bHRpbGluZSA9IGV4cHIucHJvcGVydGllcy5sZW5ndGggPiAxO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvcGVydHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIW11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgIC8vIGlzc3VlcyA0XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHRyYW5zZm9ybSBmcm9tXG4gICAgICAgICAgICAgICAgLy8gICBkZWphdnUuQ2xhc3MuZGVjbGFyZSh7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgbWV0aG9kMjogZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgICAgICAvLyAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgLy8gICBkZWphdnUuQ2xhc3MuZGVjbGFyZSh7bWV0aG9kMjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIH19KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0xpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gWyAneycsIHNwYWNlLCBmcmFnbWVudCwgc3BhY2UsICd9JyBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsgJ3snLCBuZXdsaW5lLCBpbmRlbnQsIGZyYWdtZW50IF07XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGVudCwgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydGllc1tpXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhc2UsICd9Jyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5PYmplY3RQYXR0ZXJuOlxuICAgICAgICAgICAgaWYgKCFleHByLnByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3t9JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS52YWx1ZS50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5LnNob3J0aGFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gWyd7JywgbXVsdGlsaW5lID8gbmV3bGluZSA6ICcnIF07XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBpbmRlbnQgOiAnJywgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydGllc1tpXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIChtdWx0aWxpbmUgPyBuZXdsaW5lIDogc3BhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobXVsdGlsaW5lICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBiYXNlIDogJycsICd9Jyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5UaGlzRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9ICd0aGlzJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwcik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5MaXRlcmFsOlxuICAgICAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoJ3JhdycpICYmIHBhcnNlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gcGFyc2UoZXhwci5yYXcpLmJvZHlbMF0uZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhdy50eXBlID09PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhdy52YWx1ZSA9PT0gZXhwci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHIucmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdXNlIHJhdyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnbnVsbCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBlc2NhcGVTdHJpbmcoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZU51bWJlcihleHByLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByLnZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZWdFeHAoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Db21wcmVoZW5zaW9uRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAnWycsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYm9keSwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHByLmJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJsb2Nrc1tpXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgJ2lmJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmZpbHRlciwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEubW96LnBhcmVudGhlc2l6ZWRDb21wcmVoZW5zaW9uQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsgJygnLCBmcmFnbWVudCwgJyknIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkNvbXByZWhlbnNpb25CbG9jazpcbiAgICAgICAgICAgIGlmIChleHByLmxlZnQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5sZWZ0LmtpbmQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVN0YXRlbWVudChleHByLmxlZnQuZGVjbGFyYXRpb25zWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkNhbGwsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oZnJhZ21lbnQsIGV4cHIub2YgPyAnb2YnIDogJ2luJyk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oZnJhZ21lbnQsIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnJpZ2h0LCB7XG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBpZiAoZXh0cmEubW96LnBhcmVudGhlc2l6ZWRDb21wcmVoZW5zaW9uQmxvY2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbICdmb3InICsgc3BhY2UgKyAnKCcsIGZyYWdtZW50LCAnKScgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbignZm9yJyArIHNwYWNlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGV4cHJlc3Npb24gdHlwZTogJyArIGV4cHIudHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlKHJlc3VsdCwgZXhwcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdCwgb3B0aW9uKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdCwgbm9kZSwgYWxsb3dJbiwgZnVuY3Rpb25Cb2R5LCBkaXJlY3RpdmVDb250ZXh0LCBmcmFnbWVudCwgc2VtaWNvbG9uO1xuXG4gICAgICAgIGFsbG93SW4gPSB0cnVlO1xuICAgICAgICBzZW1pY29sb24gPSAnOyc7XG4gICAgICAgIGZ1bmN0aW9uQm9keSA9IGZhbHNlO1xuICAgICAgICBkaXJlY3RpdmVDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgIGFsbG93SW4gPSBvcHRpb24uYWxsb3dJbiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbi5hbGxvd0luO1xuICAgICAgICAgICAgaWYgKCFzZW1pY29sb25zICYmIG9wdGlvbi5zZW1pY29sb25PcHRpb25hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbiA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Cb2R5ID0gb3B0aW9uLmZ1bmN0aW9uQm9keTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZUNvbnRleHQgPSBvcHRpb24uZGlyZWN0aXZlQ29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc3RtdC50eXBlKSB7XG4gICAgICAgIGNhc2UgU3ludGF4LkJsb2NrU3RhdGVtZW50OlxuICAgICAgICAgICAgcmVzdWx0ID0gWyd7JywgbmV3bGluZV07XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0bXQuYm9keS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudChnZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbWljb2xvbk9wdGlvbmFsOiBpID09PSBsZW4gLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlQ29udGV4dDogZnVuY3Rpb25Cb2R5XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KCd9JykpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQnJlYWtTdGF0ZW1lbnQ6XG4gICAgICAgICAgICBpZiAoc3RtdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdicmVhayAnICsgc3RtdC5sYWJlbC5uYW1lICsgc2VtaWNvbG9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnYnJlYWsnICsgc2VtaWNvbG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQ29udGludWVTdGF0ZW1lbnQ6XG4gICAgICAgICAgICBpZiAoc3RtdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdjb250aW51ZSAnICsgc3RtdC5sYWJlbC5uYW1lICsgc2VtaWNvbG9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnY29udGludWUnICsgc2VtaWNvbG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRGlyZWN0aXZlU3RhdGVtZW50OlxuICAgICAgICAgICAgaWYgKHN0bXQucmF3KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RtdC5yYXcgKyBzZW1pY29sb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGVzY2FwZURpcmVjdGl2ZShzdG10LmRpcmVjdGl2ZSkgKyBzZW1pY29sb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Eb1doaWxlU3RhdGVtZW50OlxuICAgICAgICAgICAgLy8gQmVjYXVzZSBgZG8gNDIgd2hpbGUgKGNvbmQpYCBpcyBTeW50YXggRXJyb3IuIFdlIG5lZWQgc2VtaWNvbG9uLlxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbignZG8nLCBtYXliZUJsb2NrKHN0bXQuYm9keSkpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbWF5YmVCbG9ja1N1ZmZpeChzdG10LmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICd3aGlsZScgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICcpJyArIHNlbWljb2xvblxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5DYXRjaENsYXVzZTpcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2NhdGNoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5wYXJhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1heWJlQmxvY2soc3RtdC5ib2R5KSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5EZWJ1Z2dlclN0YXRlbWVudDpcbiAgICAgICAgICAgIHJlc3VsdCA9ICdkZWJ1Z2dlcicgKyBzZW1pY29sb247XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5FbXB0eVN0YXRlbWVudDpcbiAgICAgICAgICAgIHJlc3VsdCA9ICc7JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ6XG4gICAgICAgICAgICByZXN1bHQgPSBbZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIC8vIDEyLjQgJ3snLCAnZnVuY3Rpb24nIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgcG9zaXRpb24uXG4gICAgICAgICAgICAvLyB3cmFwIGV4cHJlc3Npb24gd2l0aCBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0b1NvdXJjZU5vZGUocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50LmNoYXJBdCgwKSA9PT0gJ3snIHx8IChmcmFnbWVudC5zbGljZSgwLCA4KSA9PT0gJ2Z1bmN0aW9uJyAmJiAnICgnLmluZGV4T2YoZnJhZ21lbnQuY2hhckF0KDgpKSA+PSAwKSB8fCAoZGlyZWN0aXZlICYmIGRpcmVjdGl2ZUNvbnRleHQgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5MaXRlcmFsICYmIHR5cGVvZiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnKCcsIHJlc3VsdCwgJyknICsgc2VtaWNvbG9uXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VtaWNvbG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjpcbiAgICAgICAgICAgIGlmIChzdG10LmluaXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgJz0nLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaW5pdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlSWRlbnRpZmllcihzdG10LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXN1bHQgPSBbc3RtdC5raW5kXTtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgcGF0aCBmb3JcbiAgICAgICAgICAgIC8vIHZhciB4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gfTtcbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgc3RtdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAmJlxuICAgICAgICAgICAgICAgICAgICBzdG10LmRlY2xhcmF0aW9uc1swXS5pbml0LnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSwgZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbnNbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJblxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVmFyaWFibGVEZWNsYXJhdG9yIGlzIHR5cGVkIGFzIFN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICAvLyBidXQgam9pbmVkIHdpdGggY29tbWEgKG5vdCBMaW5lVGVybWluYXRvcikuXG4gICAgICAgICAgICAgICAgLy8gU28gaWYgY29tbWVudCBpcyBhdHRhY2hlZCB0byB0YXJnZXQgbm9kZSwgd2Ugc2hvdWxkIHNwZWNpYWxpemUuXG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBzdG10LmRlY2xhcmF0aW9uc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdcXG4nLCBhZGRJbmRlbnQoZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGFsbG93SW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSwgZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGFsbG93SW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHN0bXQuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudCAmJiBub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUsIGFkZEluZGVudChnZW5lcmF0ZVN0YXRlbWVudChub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGFsbG93SW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSwgZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChzZW1pY29sb24pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguVGhyb3dTdGF0ZW1lbnQ6XG4gICAgICAgICAgICByZXN1bHQgPSBbam9pbihcbiAgICAgICAgICAgICAgICAndGhyb3cnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmFyZ3VtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLCBzZW1pY29sb25dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguVHJ5U3RhdGVtZW50OlxuICAgICAgICAgICAgcmVzdWx0ID0gWyd0cnknLCBtYXliZUJsb2NrKHN0bXQuYmxvY2spXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1heWJlQmxvY2tTdWZmaXgoc3RtdC5ibG9jaywgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChzdG10LmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gb2xkIGludGVyZmFjZVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0bXQuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlcnNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyc1tpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgaW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5oYW5kbGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBzdG10Lmd1YXJkZWRIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlci5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RtdC5ndWFyZGVkSGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGdlbmVyYXRlU3RhdGVtZW50KHN0bXQuZ3VhcmRlZEhhbmRsZXJzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXliZUJsb2NrU3VmZml4KHN0bXQuZ3VhcmRlZEhhbmRsZXJzW2ldLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWydmaW5hbGx5JywgbWF5YmVCbG9jayhzdG10LmZpbmFsaXplcildKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlN3aXRjaFN0YXRlbWVudDpcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N3aXRjaCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZGlzY3JpbWluYW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgJyknICsgc3BhY2UgKyAneycgKyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0bXQuY2FzZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdG10LmNhc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KGdlbmVyYXRlU3RhdGVtZW50KHN0bXQuY2FzZXNbaV0sIHtzZW1pY29sb25PcHRpb25hbDogaSA9PT0gbGVuIC0gMX0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoJ30nKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Td2l0Y2hDYXNlOlxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luKCdjYXNlJywgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICc6J1xuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnZGVmYXVsdDonXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSBzdG10LmNvbnNlcXVlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gJiYgc3RtdC5jb25zZXF1ZW50WzBdLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IG1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gbGVuICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQoZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5jb25zZXF1ZW50W2ldLCB7c2VtaWNvbG9uT3B0aW9uYWw6IGkgPT09IGxlbiAtIDEgJiYgc2VtaWNvbG9uID09PSAnJ30pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgIT09IGxlbiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGUoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguSWZTdGF0ZW1lbnQ6XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdpZicgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdG10LmFsdGVybmF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50KSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF5YmVCbG9ja1N1ZmZpeChzdG10LmNvbnNlcXVlbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuYWx0ZXJuYXRlLnR5cGUgPT09IFN5bnRheC5JZlN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWydlbHNlICcsIGdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYWx0ZXJuYXRlLCB7c2VtaWNvbG9uT3B0aW9uYWw6IHNlbWljb2xvbiA9PT0gJyd9KV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBqb2luKCdlbHNlJywgbWF5YmVCbG9jayhzdG10LmFsdGVybmF0ZSwgc2VtaWNvbG9uID09PSAnJykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50LCBzZW1pY29sb24gPT09ICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Gb3JTdGF0ZW1lbnQ6XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ2ZvcicgKyBzcGFjZSArICcoJ107XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5pbml0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZVN0YXRlbWVudChzdG10LmluaXQsIHthbGxvd0luOiBmYWxzZX0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksICc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UsIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLCAnOycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlLCBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC51cGRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLCAnKScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1heWJlQmxvY2soc3RtdC5ib2R5LCBzZW1pY29sb24gPT09ICcnKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Gb3JJblN0YXRlbWVudDpcbiAgICAgICAgICAgIHJlc3VsdCA9IFsnZm9yJyArIHNwYWNlICsgJygnXTtcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmxlZnQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdG10LmxlZnQua2luZCArIG5vRW1wdHlTcGFjZSgpLCBnZW5lcmF0ZVN0YXRlbWVudChzdG10LmxlZnQuZGVjbGFyYXRpb25zWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5DYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICdpbicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtqb2luKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnJpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICksICcpJ107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1heWJlQmxvY2soc3RtdC5ib2R5LCBzZW1pY29sb24gPT09ICcnKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5MYWJlbGVkU3RhdGVtZW50OlxuICAgICAgICAgICAgcmVzdWx0ID0gW3N0bXQubGFiZWwubmFtZSArICc6JywgbWF5YmVCbG9jayhzdG10LmJvZHksIHNlbWljb2xvbiA9PT0gJycpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlByb2dyYW06XG4gICAgICAgICAgICBsZW4gPSBzdG10LmJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0ID0gW3NhZmVDb25jYXRlbmF0aW9uICYmIGxlbiA+IDAgPyAnXFxuJyA6ICcnXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbWljb2xvbk9wdGlvbmFsOiAhc2FmZUNvbmNhdGVuYXRpb24gJiYgaSA9PT0gbGVuIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZUNvbnRleHQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4gJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgICAgcmVzdWx0ID0gWyhzdG10LmdlbmVyYXRvciAmJiAhZXh0cmEubW96LnN0YXJsZXNzR2VuZXJhdG9yID8gJ2Z1bmN0aW9uKiAnIDogJ2Z1bmN0aW9uICcpLFxuICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlSWRlbnRpZmllcihzdG10LmlkKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZ1bmN0aW9uQm9keShzdG10KV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XG4gICAgICAgICAgICBpZiAoc3RtdC5hcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtqb2luKFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuJyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuYXJndW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSwgc2VtaWNvbG9uXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWydyZXR1cm4nICsgc2VtaWNvbG9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LldoaWxlU3RhdGVtZW50OlxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnd2hpbGUnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKHN0bXQuYm9keSwgc2VtaWNvbG9uID09PSAnJykpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguV2l0aFN0YXRlbWVudDpcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGgnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10Lm9iamVjdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1heWJlQmxvY2soc3RtdC5ib2R5LCBzZW1pY29sb24gPT09ICcnKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN0YXRlbWVudCB0eXBlOiAnICsgc3RtdC50eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBjb21tZW50c1xuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhZGRDb21tZW50c1RvU3RhdGVtZW50KHN0bXQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZShyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtICYmICFzYWZlQ29uY2F0ZW5hdGlvbiAmJiBuZXdsaW5lID09PSAnJyAmJiAgZnJhZ21lbnQuY2hhckF0KGZyYWdtZW50Lmxlbmd0aCAtIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdG9Tb3VyY2VOb2RlKHJlc3VsdCkucmVwbGFjZVJpZ2h0KC9cXHMrJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b1NvdXJjZU5vZGUocmVzdWx0LCBzdG10KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCksIHJlc3VsdCwgcGFpcjtcblxuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPYnNvbGV0ZSBvcHRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICBgb3B0aW9ucy5pbmRlbnRgXG4gICAgICAgICAgICAvLyAgIGBvcHRpb25zLmJhc2VgXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiB0aGVtLCB3ZSBjYW4gdXNlIGBvcHRpb24uZm9ybWF0LmluZGVudGAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGUgPSBvcHRpb25zLmluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cGRhdGVEZWVwbHkoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaW5kZW50ID0gb3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHN0cmluZ1JlcGVhdChpbmRlbnQsIG9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGluZGVudCA9IG9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZTtcbiAgICAgICAgICAgIGJhc2UgPSBzdHJpbmdSZXBlYXQoaW5kZW50LCBvcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IG9wdGlvbnMuZm9ybWF0Lmpzb247XG4gICAgICAgIHJlbnVtYmVyID0gb3B0aW9ucy5mb3JtYXQucmVudW1iZXI7XG4gICAgICAgIGhleGFkZWNpbWFsID0ganNvbiA/IGZhbHNlIDogb3B0aW9ucy5mb3JtYXQuaGV4YWRlY2ltYWw7XG4gICAgICAgIHF1b3RlcyA9IGpzb24gPyAnZG91YmxlJyA6IG9wdGlvbnMuZm9ybWF0LnF1b3RlcztcbiAgICAgICAgZXNjYXBlbGVzcyA9IG9wdGlvbnMuZm9ybWF0LmVzY2FwZWxlc3M7XG4gICAgICAgIG5ld2xpbmUgPSBvcHRpb25zLmZvcm1hdC5uZXdsaW5lO1xuICAgICAgICBzcGFjZSA9IG9wdGlvbnMuZm9ybWF0LnNwYWNlO1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQuY29tcGFjdCkge1xuICAgICAgICAgICAgbmV3bGluZSA9IHNwYWNlID0gaW5kZW50ID0gYmFzZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudGhlc2VzID0gb3B0aW9ucy5mb3JtYXQucGFyZW50aGVzZXM7XG4gICAgICAgIHNlbWljb2xvbnMgPSBvcHRpb25zLmZvcm1hdC5zZW1pY29sb25zO1xuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbiA9IG9wdGlvbnMuZm9ybWF0LnNhZmVDb25jYXRlbmF0aW9uO1xuICAgICAgICBkaXJlY3RpdmUgPSBvcHRpb25zLmRpcmVjdGl2ZTtcbiAgICAgICAgcGFyc2UgPSBqc29uID8gbnVsbCA6IG9wdGlvbnMucGFyc2U7XG4gICAgICAgIHNvdXJjZU1hcCA9IG9wdGlvbnMuc291cmNlTWFwO1xuICAgICAgICBleHRyYSA9IG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHNvdXJjZU1hcCkge1xuICAgICAgICAgICAgaWYgKCFleHBvcnRzLmJyb3dzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgZW52aXJvbm1lbnQgaXMgbm9kZS5qc1xuICAgICAgICAgICAgICAgIC8vIEFuZCBwcmV2ZW50IGZyb20gaW5jbHVkaW5nIHNvdXJjZS1tYXAgYnkgYnJvd3NlcmlmeVxuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSByZXF1aXJlKCdzb3VyY2UtbWFwJykuU291cmNlTm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgU291cmNlTm9kZSA9IGdsb2JhbC5zb3VyY2VNYXAuU291cmNlTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlTW9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgU3ludGF4LkJsb2NrU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5CcmVha1N0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguQ2F0Y2hDbGF1c2U6XG4gICAgICAgIGNhc2UgU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5EaXJlY3RpdmVTdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LkRvV2hpbGVTdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LkRlYnVnZ2VyU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5FbXB0eVN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguRm9yU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5Gb3JJblN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgY2FzZSBTeW50YXguSWZTdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LlByb2dyYW06XG4gICAgICAgIGNhc2UgU3ludGF4LlJldHVyblN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguU3dpdGNoU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5Td2l0Y2hDYXNlOlxuICAgICAgICBjYXNlIFN5bnRheC5UaHJvd1N0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguVHJ5U3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I6XG4gICAgICAgIGNhc2UgU3ludGF4LldoaWxlU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5XaXRoU3RhdGVtZW50OlxuICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcbiAgICAgICAgY2FzZSBTeW50YXguQXJyYXlFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5BcnJheVBhdHRlcm46XG4gICAgICAgIGNhc2UgU3ludGF4LkJpbmFyeUV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjpcbiAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgY2FzZSBTeW50YXguTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBTeW50YXguTG9naWNhbEV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4Lk5ld0V4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4Lk9iamVjdEV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4Lk9iamVjdFBhdHRlcm46XG4gICAgICAgIGNhc2UgU3ludGF4LlByb3BlcnR5OlxuICAgICAgICBjYXNlIFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LlRoaXNFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5VbmFyeUV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LlVwZGF0ZUV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LllpZWxkRXhwcmVzc2lvbjpcblxuICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVFeHByZXNzaW9uKG5vZGUsIHtcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlOiAnICsgbm9kZS50eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHBhaXIgPSByZXN1bHQudG9TdHJpbmdXaXRoU291cmNlTWFwKHtcbiAgICAgICAgICAgIGZpbGU6IG9wdGlvbnMuZmlsZSxcbiAgICAgICAgICAgIHNvdXJjZVJvb3Q6IG9wdGlvbnMuc291cmNlTWFwUm9vdFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VDb250ZW50KSB7XG4gICAgICAgICAgICBwYWlyLm1hcC5zZXRTb3VyY2VDb250ZW50KG9wdGlvbnMuc291cmNlTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNvdXJjZUNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwV2l0aENvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWlyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhaXIubWFwLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgRk9STUFUX01JTklGWSA9IHtcbiAgICAgICAgaW5kZW50OiB7XG4gICAgICAgICAgICBzdHlsZTogJycsXG4gICAgICAgICAgICBiYXNlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlbnVtYmVyOiB0cnVlLFxuICAgICAgICBoZXhhZGVjaW1hbDogdHJ1ZSxcbiAgICAgICAgcXVvdGVzOiAnYXV0bycsXG4gICAgICAgIGVzY2FwZWxlc3M6IHRydWUsXG4gICAgICAgIGNvbXBhY3Q6IHRydWUsXG4gICAgICAgIHBhcmVudGhlc2VzOiBmYWxzZSxcbiAgICAgICAgc2VtaWNvbG9uczogZmFsc2VcbiAgICB9O1xuXG4gICAgRk9STUFUX0RFRkFVTFRTID0gZ2V0RGVmYXVsdE9wdGlvbnMoKS5mb3JtYXQ7XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICAgIGV4cG9ydHMuYXR0YWNoQ29tbWVudHMgPSBlc3RyYXZlcnNlLmF0dGFjaENvbW1lbnRzO1xuICAgIGV4cG9ydHMuYnJvd3NlciA9IGZhbHNlO1xuICAgIGV4cG9ydHMuRk9STUFUX01JTklGWSA9IEZPUk1BVF9NSU5JRlk7XG4gICAgZXhwb3J0cy5GT1JNQVRfREVGQVVMVFMgPSBGT1JNQVRfREVGQVVMVFM7XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKmpzbGludCB2YXJzOmZhbHNlLCBiaXR3aXNlOnRydWUqL1xuLypqc2hpbnQgaW5kZW50OjQqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlLCBkZWZpbmU6dHJ1ZSovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsXG4gICAgLy8gYW5kIHBsYWluIGJyb3dzZXIgbG9hZGluZyxcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzdHJhdmVyc2UgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU3ludGF4LFxuICAgICAgICBpc0FycmF5LFxuICAgICAgICBWaXNpdG9yT3B0aW9uLFxuICAgICAgICBWaXNpdG9yS2V5cyxcbiAgICAgICAgQlJFQUssXG4gICAgICAgIFNLSVA7XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcbiAgICAgICAgQ2xhc3NCb2R5OiAnQ2xhc3NCb2R5JyxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogJ0NsYXNzRGVjbGFyYXRpb24nLFxuICAgICAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogJ0RpcmVjdGl2ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246ICdNZXRob2REZWZpbml0aW9uJyxcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogJ05ld0V4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdFBhdHRlcm46ICdPYmplY3RQYXR0ZXJuJyxcbiAgICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlnbm9yZUpTSGludEVycm9yKCkgeyB9XG5cbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZXBDb3B5KG9iaikge1xuICAgICAgICB2YXIgcmV0ID0ge30sIGtleSwgdmFsO1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBkZWVwQ29weSh2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iaikge1xuICAgICAgICB2YXIgcmV0ID0ge30sIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlnbm9yZUpTSGludEVycm9yKHNoYWxsb3dDb3B5KTtcblxuICAgIC8vIGJhc2VkIG9uIExMVk0gbGliYysrIHVwcGVyX2JvdW5kIC8gbG93ZXJfYm91bmRcbiAgICAvLyBNSVQgTGljZW5zZVxuXG4gICAgZnVuY3Rpb24gdXBwZXJCb3VuZChhcnJheSwgZnVuYykge1xuICAgICAgICB2YXIgZGlmZiwgbGVuLCBpLCBjdXJyZW50O1xuXG4gICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgZGlmZiA9IGxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpICsgZGlmZjtcbiAgICAgICAgICAgIGlmIChmdW5jKGFycmF5W2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IGRpZmY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gZGlmZiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgZnVuYykge1xuICAgICAgICB2YXIgZGlmZiwgbGVuLCBpLCBjdXJyZW50O1xuXG4gICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgZGlmZiA9IGxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpICsgZGlmZjtcbiAgICAgICAgICAgIGlmIChmdW5jKGFycmF5W2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gZGlmZiArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbiA9IGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGlnbm9yZUpTSGludEVycm9yKGxvd2VyQm91bmQpO1xuXG4gICAgVmlzaXRvcktleXMgPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycmF5UGF0dGVybjogWydlbGVtZW50cyddLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogWydwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiBbJ2JvZHknXSxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6IFsncGFyYW0nLCAnYm9keSddLFxuICAgICAgICBDbGFzc0JvZHk6IFsnYm9keSddLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiBbJ2lkJywgJ2JvZHknLCAnc3VwZXJDbGFzcyddLFxuICAgICAgICBDbGFzc0V4cHJlc3Npb246IFsnaWQnLCAnYm9keScsICdzdXBlckNsYXNzJ10sXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogWydib2R5JywgJ3Rlc3QnXSxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBbJ2V4cHJlc3Npb24nXSxcbiAgICAgICAgRm9yU3RhdGVtZW50OiBbJ2luaXQnLCAndGVzdCcsICd1cGRhdGUnLCAnYm9keSddLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIElkZW50aWZpZXI6IFtdLFxuICAgICAgICBJZlN0YXRlbWVudDogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIExpdGVyYWw6IFtdLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBbJ2xhYmVsJywgJ2JvZHknXSxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBbJ29iamVjdCcsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIE9iamVjdFBhdHRlcm46IFsncHJvcGVydGllcyddLFxuICAgICAgICBQcm9ncmFtOiBbJ2JvZHknXSxcbiAgICAgICAgUHJvcGVydHk6IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIFJldHVyblN0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246IFsnZXhwcmVzc2lvbnMnXSxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBbJ2Rpc2NyaW1pbmFudCcsICdjYXNlcyddLFxuICAgICAgICBTd2l0Y2hDYXNlOiBbJ3Rlc3QnLCAnY29uc2VxdWVudCddLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogW10sXG4gICAgICAgIFRocm93U3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFRyeVN0YXRlbWVudDogWydibG9jaycsICdoYW5kbGVycycsICdoYW5kbGVyJywgJ2d1YXJkZWRIYW5kbGVycycsICdmaW5hbGl6ZXInXSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbnMnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBbJ2lkJywgJ2luaXQnXSxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IFsndGVzdCcsICdib2R5J10sXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IFsnb2JqZWN0JywgJ2JvZHknXSxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J11cbiAgICB9O1xuXG4gICAgLy8gdW5pcXVlIGlkXG4gICAgQlJFQUsgPSB7fTtcbiAgICBTS0lQID0ge307XG5cbiAgICBWaXNpdG9yT3B0aW9uID0ge1xuICAgICAgICBCcmVhazogQlJFQUssXG4gICAgICAgIFNraXA6IFNLSVBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKHBhcmVudCwga2V5KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbdGhpcy5rZXldID0gbm9kZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRWxlbWVudChub2RlLCBwYXRoLCB3cmFwLCByZWYpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy53cmFwID0gd3JhcDtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29udHJvbGxlcigpIHsgfVxuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBwcm9wZXJ0eSBwYXRoIGFycmF5IGZyb20gcm9vdCB0byBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgICAgICAgdmFyIGksIGl6LCBqLCBqeiwgcmVzdWx0LCBlbGVtZW50O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvUGF0aChyZXN1bHQsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwganogPSBwYXRoLmxlbmd0aDsgaiA8IGp6OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aFtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvb3Qgbm9kZVxuICAgICAgICBpZiAoIXRoaXMuX19jdXJyZW50LnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBpcyBzZW50aW5lbCwgc2Vjb25kIG5vZGUgaXMgcm9vdCBlbGVtZW50XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAyLCBpeiA9IHRoaXMuX19sZWF2ZWxpc3QubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuX19sZWF2ZWxpc3RbaV07XG4gICAgICAgICAgICBhZGRUb1BhdGgocmVzdWx0LCBlbGVtZW50LnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRvUGF0aChyZXN1bHQsIHRoaXMuX19jdXJyZW50LnBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIGFycmF5IG9mIHBhcmVudCBlbGVtZW50c1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiBwYXJlbnRzKCkge1xuICAgICAgICB2YXIgaSwgaXosIHJlc3VsdDtcblxuICAgICAgICAvLyBmaXJzdCBub2RlIGlzIHNlbnRpbmVsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IHRoaXMuX19sZWF2ZWxpc3QubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fX2xlYXZlbGlzdFtpXS5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY3VycmVudC5ub2RlO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2V4ZWN1dGUgPSBmdW5jdGlvbiBfX2V4ZWN1dGUoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzLCByZXN1bHQ7XG5cbiAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHByZXZpb3VzICA9IHRoaXMuX19jdXJyZW50O1xuICAgICAgICB0aGlzLl9fY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2suY2FsbCh0aGlzLCBlbGVtZW50Lm5vZGUsIHRoaXMuX19sZWF2ZWxpc3RbdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGggLSAxXS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fY3VycmVudCA9IHByZXZpb3VzO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBub3RpZnkgY29udHJvbCBza2lwIC8gYnJlYWtcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoZmxhZykge1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBmbGFnO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gc2tpcCBjaGlsZCBub2RlcyBvZiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShTS0lQKTtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIGJyZWFrIHRyYXZlcnNhbHNcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZVsnYnJlYWsnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoQlJFQUspO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2luaXRpYWxpemUgPSBmdW5jdGlvbihyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHRoaXMudmlzaXRvciA9IHZpc2l0b3I7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuX193b3JrbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fbGVhdmVsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWw7XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG51bGwpKTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCByZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGVsZW1lbnQud3JhcCB8fCBub2RlLnR5cGU7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IFZpc2l0b3JLZXlzW25vZGVUeXBlXTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50MiAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uIHx8IG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybikgJiYgJ3Byb3BlcnRpZXMnID09PSBjYW5kaWRhdGVzW2N1cnJlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBub2RlVHlwZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWwsXG4gICAgICAgICAgICBvdXRlcixcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZShyb290LCB2aXNpdG9yKTtcblxuICAgICAgICBzZW50aW5lbCA9IHt9O1xuXG4gICAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgICB3b3JrbGlzdCA9IHRoaXMuX193b3JrbGlzdDtcbiAgICAgICAgbGVhdmVsaXN0ID0gdGhpcy5fX2xlYXZlbGlzdDtcblxuICAgICAgICAvLyBpbml0aWFsaXplXG4gICAgICAgIG91dGVyID0ge1xuICAgICAgICAgICAgcm9vdDogcm9vdFxuICAgICAgICB9O1xuICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQocm9vdCwgbnVsbCwgbnVsbCwgbmV3IFJlZmVyZW5jZShvdXRlciwgJ3Jvb3QnKSk7XG4gICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBudWxsLFxuICAgICAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBCUkVBSyAmJiB0YXJnZXQgIT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgdGFyZ2V0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IuZW50ZXIsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAvLyBzbyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHVuZGVmaW5lZCBhbmQgbnVsbCBpbiB0aGlzIHBsYWNlXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBCUkVBSyAmJiB0YXJnZXQgIT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZWYucmVwbGFjZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgdGFyZ2V0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub2RlIG1heSBiZSBudWxsXG4gICAgICAgICAgICBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFNLSVAgfHwgdGFyZ2V0ID09PSBTS0lQKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGVUeXBlID0gZWxlbWVudC53cmFwIHx8IG5vZGUudHlwZTtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBWaXNpdG9yS2V5c1tub2RlVHlwZV07XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudCAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlc1tjdXJyZW50XTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChjYW5kaWRhdGUsIGtleSwgbnVsbCwgbmV3IFJlZmVyZW5jZShub2RlLCBrZXkpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVbY3VycmVudDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uICYmICdwcm9wZXJ0aWVzJyA9PT0gY2FuZGlkYXRlc1tjdXJyZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbmV3IFJlZmVyZW5jZShjYW5kaWRhdGUsIGN1cnJlbnQyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBuZXcgUmVmZXJlbmNlKGNhbmRpZGF0ZSwgY3VycmVudDIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIudHJhdmVyc2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucmVwbGFjZShyb290LCB2aXNpdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmRDb21tZW50UmFuZ2UoY29tbWVudCwgdG9rZW5zKSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG5cbiAgICAgICAgdGFyZ2V0ID0gdXBwZXJCb3VuZCh0b2tlbnMsIGZ1bmN0aW9uIHNlYXJjaCh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLnJhbmdlWzBdID4gY29tbWVudC5yYW5nZVswXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gW2NvbW1lbnQucmFuZ2VbMF0sIGNvbW1lbnQucmFuZ2VbMV1dO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0IC09IDE7XG4gICAgICAgIGlmICh0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdID0gdG9rZW5zW3RhcmdldF0ucmFuZ2VbMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hDb21tZW50cyh0cmVlLCBwcm92aWRlZENvbW1lbnRzLCB0b2tlbnMpIHtcbiAgICAgICAgLy8gQXQgZmlyc3QsIHdlIHNob3VsZCBjYWxjdWxhdGUgZXh0ZW5kZWQgY29tbWVudCByYW5nZXMuXG4gICAgICAgIHZhciBjb21tZW50cyA9IFtdLCBjb21tZW50LCBsZW4sIGksIGN1cnNvcjtcblxuICAgICAgICBpZiAoIXRyZWUucmFuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0YWNoQ29tbWVudHMgbmVlZHMgcmFuZ2UgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRva2VucyBhcnJheSBpcyBlbXB0eSwgd2UgYXR0YWNoIGNvbW1lbnRzIHRvIHRyZWUgYXMgJ2xlYWRpbmdDb21tZW50cydcbiAgICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZWRDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gWzAsIHRyZWUucmFuZ2VbMF1dO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLmxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKGV4dGVuZENvbW1lbnRSYW5nZShkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIEpvaG4gRnJlZW1hbidzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPiBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPT09IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdIDwgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdID09PSBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSAnMS4zLjMtZGV2JztcbiAgICBleHBvcnRzLlN5bnRheCA9IFN5bnRheDtcbiAgICBleHBvcnRzLnRyYXZlcnNlID0gdHJhdmVyc2U7XG4gICAgZXhwb3J0cy5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gYXR0YWNoQ29tbWVudHM7XG4gICAgZXhwb3J0cy5WaXNpdG9yS2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgIGV4cG9ydHMuVmlzaXRvck9wdGlvbiA9IFZpc2l0b3JPcHRpb247XG4gICAgZXhwb3J0cy5Db250cm9sbGVyID0gQ29udHJvbGxlcjtcbn0pKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFJlZ2V4O1xuXG4gICAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cbiAgICBSZWdleCA9IHtcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMFxcdTA4QTItXFx1MDhBQ1xcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdGXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzNcXHUwQzM1LVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkYwXFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFDXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OTdcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3OTNcXHVBN0EwLVxcdUE3QUFcXHVBN0Y4LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTgwLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMFxcdTA4QTItXFx1MDhBQ1xcdTA4RTQtXFx1MDhGRVxcdTA5MDAtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAxLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzNcXHUwQzM1LVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MlxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDJcXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGMFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFDXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFEMDAtXFx1MURFNlxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OTdcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3OTNcXHVBN0EwLVxcdUE3QUFcXHVBN0Y4LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0JcXHVBQTgwLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTI2XFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gNDggJiYgY2ggPD0gNTcpOyAgIC8vIDAuLjlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiBpc0RlY2ltYWxEaWdpdChjaCkgfHwgKDk3IDw9IGNoICYmIGNoIDw9IDEwMikgfHwgKDY1IDw9IGNoICYmIGNoIDw9IDcwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA+PSA0OCAmJiBjaCA8PSA1NSk7ICAgLy8gMC4uN1xuICAgIH1cblxuICAgIC8vIDcuMiBXaGl0ZSBTcGFjZVxuXG4gICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjApIHx8IChjaCA9PT0gMHgwOSkgfHwgKGNoID09PSAweDBCKSB8fCAoY2ggPT09IDB4MEMpIHx8IChjaCA9PT0gMHhBMCkgfHxcbiAgICAgICAgICAgIChjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgxODBFLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNoKSA+PSAwKTtcbiAgICB9XG5cbiAgICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gICAgfVxuXG4gICAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAzNikgfHwgKGNoID09PSA5NSkgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gNjUgJiYgY2ggPD0gOTApIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgICAgKGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA9PT0gOTIpIHx8ICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAzNikgfHwgKGNoID09PSA5NSkgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gNjUgJiYgY2ggPD0gOTApIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgICAgKGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSA0OCAmJiBjaCA8PSA1NykgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgICAoY2ggPT09IDkyKSB8fCAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRGVjaW1hbERpZ2l0OiBpc0RlY2ltYWxEaWdpdCxcbiAgICAgICAgaXNIZXhEaWdpdDogaXNIZXhEaWdpdCxcbiAgICAgICAgaXNPY3RhbERpZ2l0OiBpc09jdGFsRGlnaXQsXG4gICAgICAgIGlzV2hpdGVTcGFjZTogaXNXaGl0ZVNwYWNlLFxuICAgICAgICBpc0xpbmVUZXJtaW5hdG9yOiBpc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gICAgICAgIGlzSWRlbnRpZmllclBhcnQ6IGlzSWRlbnRpZmllclBhcnRcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZEVTNihpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIC8vIHlpZWxkIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhcyBrZXl3b3JkIHVuZGVyIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgaWQgPT09ICd5aWVsZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkRVM2KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fCAoaWQgPT09ICd0cnknKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZShpZCkge1xuICAgICAgICB2YXIgaSwgaXosIGNoO1xuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gaWQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKCFjb2RlLmlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBjaCA9PT0gOTIpIHsgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IGlkLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICghY29kZS5pc0lkZW50aWZpZXJQYXJ0KGNoKSB8fCBjaCA9PT0gOTIpIHsgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0tleXdvcmRFUzU6IGlzS2V5d29yZEVTNSxcbiAgICAgICAgaXNLZXl3b3JkRVM2OiBpc0tleXdvcmRFUzYsXG4gICAgICAgIGlzUmVzdHJpY3RlZFdvcmQ6IGlzUmVzdHJpY3RlZFdvcmQsXG4gICAgICAgIGlzSWRlbnRpZmllck5hbWU6IGlzSWRlbnRpZmllck5hbWVcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBleHBvcnRzLmNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcbiAgICBleHBvcnRzLmtleXdvcmQgPSByZXF1aXJlKCcuL2tleXdvcmQnKTtcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICAgKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAgICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICAgKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICAgKi9cbiAgQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBpc0R1cGxpY2F0ZSA9IHRoaXMuaGFzKGFTdHIpO1xuICAgIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV0gPSBpZHg7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1NldFN0cmluZyhhU3RyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gICAgaWYgKHRoaXMuaGFzKGFTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICAgKlxuICAgKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICAgKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICAgKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICB9O1xuXG4gIGV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4gIC8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuICAvLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbiAgLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4gIC8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbiAgLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4gIC8vXG4gIC8vICAgQ29udGludWF0aW9uXG4gIC8vICAgfCAgICBTaWduXG4gIC8vICAgfCAgICB8XG4gIC8vICAgViAgICBWXG4gIC8vICAgMTAxMDExXG5cbiAgdmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4gIC8vIGJpbmFyeTogMDExMTExXG4gIHZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogaXMgcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICAgKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIGlzIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAgICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gICAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgICAgPyAtc2hpZnRlZFxuICAgICAgOiBzaGlmdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgIHZhciBkaWdpdDtcblxuICAgIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gICAgZG8ge1xuICAgICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICBpZiAodmxxID4gMCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICAgIH1cbiAgICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gICAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gICAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoaSA+PSBzdHJMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgICAgfVxuICAgICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckF0KGkrKykpO1xuICAgICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICAgIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGZyb21WTFFTaWduZWQocmVzdWx0KSxcbiAgICAgIHJlc3Q6IGFTdHIuc2xpY2UoaSlcbiAgICB9O1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGNoYXJUb0ludE1hcCA9IHt9O1xuICB2YXIgaW50VG9DaGFyTWFwID0ge307XG5cbiAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gICAgLnNwbGl0KCcnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaCwgaW5kZXgpIHtcbiAgICAgIGNoYXJUb0ludE1hcFtjaF0gPSBpbmRleDtcbiAgICAgIGludFRvQ2hhck1hcFtpbmRleF0gPSBjaDtcbiAgICB9KTtcblxuICAvKipcbiAgICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0X2VuY29kZShhTnVtYmVyKSB7XG4gICAgaWYgKGFOdW1iZXIgaW4gaW50VG9DaGFyTWFwKSB7XG4gICAgICByZXR1cm4gaW50VG9DaGFyTWFwW2FOdW1iZXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIGFOdW1iZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBkaWdpdCB0byBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZGVjb2RlKGFDaGFyKSB7XG4gICAgaWYgKGFDaGFyIGluIGNoYXJUb0ludE1hcCkge1xuICAgICAgcmV0dXJuIGNoYXJUb0ludE1hcFthQ2hhcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgYSB2YWxpZCBiYXNlIDY0IGRpZ2l0OiBcIiArIGFDaGFyKTtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gICAqL1xuICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAvL1xuICAgIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgbmV4dFxuICAgIC8vICAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgbGVzcyB0aGFuIHRoYXQgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHdoaWNoIGlzIGxlc3MgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZVxuICAgIC8vICAgICAgcmV0dXJuIG51bGwuXG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gICAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICByZXR1cm4gYUhheXN0YWNrW21pZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIC8vIGFIYXlzdGFja1ttaWRdIGlzIGdyZWF0ZXIgdGhhbiBvdXIgbmVlZGxlLlxuICAgICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpZCBub3QgZmluZCBhbiBleGFjdCBtYXRjaCwgcmV0dXJuIHRoZSBuZXh0IGNsb3Nlc3Qgb25lXG4gICAgICAvLyAodGVybWluYXRpb24gY2FzZSAyKS5cbiAgICAgIHJldHVybiBhSGF5c3RhY2tbbWlkXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhSGF5c3RhY2tbbWlkXSBpcyBsZXNzIHRoYW4gb3VyIG5lZWRsZS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMikgb3IgKDMpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgcmV0dXJuIGFMb3cgPCAwXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGFIYXlzdGFja1thTG93XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gICAqIHRoZSBuZXh0IGxvd2VzdCB2YWx1ZSBjaGVja2VkIGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gICAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAgICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAgICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICAgKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gICAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gICAqL1xuICBleHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKSB7XG4gICAgcmV0dXJuIGFIYXlzdGFjay5sZW5ndGggPiAwXG4gICAgICA/IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSlcbiAgICAgIDogbnVsbDtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuXG4gIC8qKlxuICAgKiBBIFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAgICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gICAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAgICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICAgKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICAgKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAgICogICAtIGZpbGU6IFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAgICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gICAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAgIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICAgIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICAgIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gICAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAgIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAgIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzbWM7XG4gICAgfTtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBtYXBwaW5nU2VwYXJhdG9yID0gL15bLDtdLztcbiAgICAgIHZhciBzdHIgPSBhU3RyO1xuICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICB2YXIgdGVtcDtcblxuICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHIuY2hhckF0KDApID09PSAnLCcpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IHt9O1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG5cbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5fc291cmNlcy5hdChwcmV2aW91c1NvdXJjZSArIHRlbXAudmFsdWUpO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IG1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgbWFwcGluZ1NlcGFyYXRvci50ZXN0KHN0ci5jaGFyQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSB0aGlzLl9uYW1lcy5hdChwcmV2aW91c05hbWUgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvcikge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvcik7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICYmIHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsaWJsZS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3RcbiAgICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290KSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gICAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICAgKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gICAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgKiBAcGFyYW0gYU9yZGVyXG4gICAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICAgKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgICB2YXIgbWFwcGluZ3M7XG4gICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgc291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0pLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICAgKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBUbyBjcmVhdGUgYSBuZXcgb25lLCB5b3UgbXVzdCBwYXNzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIHNvdXJjZVJvb3Q6IEFuIG9wdGlvbmFsIHJvb3QgZm9yIGFsbCBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICB9XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG5cbiAgICAgIGlmIChzb3VyY2UgJiYgIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLnB1c2goe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhU291cmNlQ29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlKSB7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoIWFTb3VyY2VGaWxlKSB7XG4gICAgICAgIGFTb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwiYVNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgICAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAgICAgYVNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIGFTb3VyY2VGaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcImFTb3VyY2VGaWxlXCJcbiAgICAgIHRoaXMuX21hcHBpbmdzLmZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBhU291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgb3JpZ2luYWwuc291cmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9PSBudWxsICYmIG1hcHBpbmcubmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGUgaWRlbnRpZmllciBuYW1lIGlmIGl0J3MgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgICAvLyBpbiBib3RoIFNvdXJjZU1hcHNcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAgICpcbiAgICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICAgKiAgICAgIHRva2VuLlxuICAgKlxuICAgKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAgICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICAvLyBDYXNlIDEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgICAgb3JnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICAvLyBUaGUgbWFwcGluZ3MgbXVzdCBiZSBndWFyYW50ZWVkIHRvIGJlIGluIHNvcnRlZCBvcmRlciBiZWZvcmUgd2Ugc3RhcnRcbiAgICAgIC8vIHNlcmlhbGl6aW5nIHRoZW0gb3IgZWxzZSB0aGUgZ2VuZXJhdGVkIGxpbmUgbnVtYmVycyAod2hpY2ggYXJlIGRlZmluZWRcbiAgICAgIC8vIHZpYSB0aGUgJzsnIHNlcGFyYXRvcnMpIHdpbGwgYmUgYWxsIG1lc3NlZCB1cC4gTm90ZTogaXQgbWlnaHQgYmUgbW9yZVxuICAgICAgLy8gcGVyZm9ybWFudCB0byBtYWludGFpbiB0aGUgc29ydGluZyBhcyB3ZSBpbnNlcnQgdGhlbSwgcmF0aGVyIHRoYW4gYXMgd2VcbiAgICAgIC8vIHNlcmlhbGl6ZSB0aGVtLCBidXQgdGhlIGJpZyBPIGlzIHRoZSBzYW1lIGVpdGhlciB3YXkuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX21hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hcHBpbmcgPSB0aGlzLl9tYXBwaW5nc1tpXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJzsnO1xuICAgICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyhtYXBwaW5nLCB0aGlzLl9tYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFTb3VyY2VSb290KSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkpXG4gICAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgICB2YXIgbWFwID0ge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgICBmaWxlOiB0aGlzLl9maWxlLFxuICAgICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCkge1xuICAgICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09PSB1bmRlZmluZWQgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09PSB1bmRlZmluZWQgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09PSB1bmRlZmluZWQgPyBudWxsIDogYU5hbWU7XG4gICAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICpcbiAgICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKi9cbiAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXkuXG4gICAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgKyBcIlxcblwiKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZnVsbCBsaW5lcyB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBjb2RlICs9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgKyBcIlxcblwiO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKTtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgcmVhY2hlZCB0aGUgY29ycmVjdCBsaW5lLCB3ZSBhZGQgY29kZSB1bnRpbCB3ZVxuICAgICAgICAgICAgLy8gcmVhY2ggdGhlIGNvcnJlY3QgY29sdW1uIHRvby5cbiAgICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgICAgIGNvZGUgKz0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIFNvdXJjZU5vZGUuXG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCByZW1haW5pbmdMaW5lcy5qb2luKFwiXFxuXCIpKTtcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUgfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rIGluc3RhbmNlb2YgU291cmNlTm9kZSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAgICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICAgKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAgICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gICAqXG4gICAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgICB2YXIgbmV3Q2hpbGRyZW47XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICAgIH1cbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAgICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICAgKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHN0ciArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gICAqIG1hcC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICAgIGNvZGU6IFwiXCIsXG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNodW5rLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gLyhbXFx3K1xcLS5dKyk6XFwvXFwvKChcXHcrOlxcdyspQCk/KFtcXHcuXSspPyg6KFxcZCspKT8oXFxTKyk/LztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKy87XG5cbiAgZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICAgIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgICBhdXRoOiBtYXRjaFszXSxcbiAgICAgIGhvc3Q6IG1hdGNoWzRdLFxuICAgICAgcG9ydDogbWF0Y2hbNl0sXG4gICAgICBwYXRoOiBtYXRjaFs3XVxuICAgIH07XG4gIH1cbiAgZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG4gIGZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgICB2YXIgdXJsID0gYVBhcnNlZFVybC5zY2hlbWUgKyBcIjovL1wiO1xuICAgIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyBcIkBcIlxuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICB2YXIgdXJsO1xuXG4gICAgaWYgKGFQYXRoLm1hdGNoKHVybFJlZ2V4cCkgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09PSAnLycgJiYgKHVybCA9IHVybFBhcnNlKGFSb290KSkpIHtcbiAgICAgIHVybC5wYXRoID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJyArIGFQYXRoO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgLyoqXG4gICAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAgICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuICBleHBvcnRzLnRvU2V0U3RyaW5nID0gdG9TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuIGFTdHIuc3Vic3RyKDEpO1xuICB9XG4gIGV4cG9ydHMuZnJvbVNldFN0cmluZyA9IGZyb21TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09IFwiL1wiICYmIHVybCAmJiB1cmwucGF0aCA9PSBcIi9cIikge1xuICAgICAgcmV0dXJuIGFQYXRoLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSA9PT0gMFxuICAgICAgPyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSlcbiAgICAgIDogYVBhdGg7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICB2YXIgczEgPSBhU3RyMSB8fCBcIlwiO1xuICAgIHZhciBzMiA9IGFTdHIyIHx8IFwiXCI7XG4gICAgcmV0dXJuIChzMSA+IHMyKSAtIChzMSA8IHMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcDtcblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmVcbiAgICogY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM7XG5cbn0pO1xuIiwidmFyIHByb2Nlc3M9cmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLF9fZmlsZW5hbWU9XCIvbm9kZV9tb2R1bGVzL3dpc3Avbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanNcIjsvKiogdmltOiBldDp0cz00OnN3PTQ6c3RzPTRcbiAqIEBsaWNlbnNlIGFtZGVmaW5lIDAuMS4wIENvcHlyaWdodCAoYykgMjAxMSwgVGhlIERvam8gRm91bmRhdGlvbiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIG9yIG5ldyBCU0QgbGljZW5zZS5cbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vanJidXJrZS9hbWRlZmluZSBmb3IgZGV0YWlsc1xuICovXG5cbi8qanNsaW50IG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcHJvY2VzcyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWZpbmUgZm9yIG5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIHRoZSBcIm1vZHVsZVwiIG9iamVjdCB0aGF0IGlzIGRlZmluZWQgYnkgTm9kZSBmb3IgdGhlXG4gKiBjdXJyZW50IG1vZHVsZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXF1aXJlRm5dLiBOb2RlJ3MgcmVxdWlyZSBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnQgbW9kdWxlLlxuICogSXQgb25seSBuZWVkcyB0byBiZSBwYXNzZWQgaW4gTm9kZSB2ZXJzaW9ucyBiZWZvcmUgMC41LCB3aGVuIG1vZHVsZS5yZXF1aXJlXG4gKiBkaWQgbm90IGV4aXN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGRlZmluZSBmdW5jdGlvbiB0aGF0IGlzIHVzYWJsZSBmb3IgdGhlIGN1cnJlbnQgbm9kZVxuICogbW9kdWxlLlxuICovXG5mdW5jdGlvbiBhbWRlZmluZShtb2R1bGUsIHJlcXVpcmVGbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZGVmaW5lQ2FjaGUgPSB7fSxcbiAgICAgICAgbG9hZGVyQ2FjaGUgPSB7fSxcbiAgICAgICAgYWxyZWFkeUNhbGxlZCA9IGZhbHNlLFxuICAgICAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgICAgICBtYWtlUmVxdWlyZSwgc3RyaW5nUmVxdWlyZTtcblxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSAuIGFuZCAuLiBmcm9tIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAgICogSXQgd2lsbCBrZWVwIGEgbGVhZGluZyBwYXRoIHNlZ21lbnQgaWYgYSAuLiB3aWxsIGJlY29tZVxuICAgICAqIHRoZSBmaXJzdCBwYXRoIHNlZ21lbnQsIHRvIGhlbHAgd2l0aCBtb2R1bGUgbmFtZSBsb29rdXBzLFxuICAgICAqIHdoaWNoIGFjdCBsaWtlIHBhdGhzLCBidXQgY2FuIGJlIHJlbWFwcGVkLiBCdXQgdGhlIGVuZCByZXN1bHQsXG4gICAgICogYWxsIHBhdGhzIHRoYXQgdXNlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGxvb2sgbm9ybWFsaXplZC5cbiAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBNT0RJRklFUyB0aGUgaW5wdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJ5IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1Eb3RzKGFyeSkge1xuICAgICAgICB2YXIgaSwgcGFydDtcbiAgICAgICAgZm9yIChpID0gMDsgYXJ5W2ldOyBpKz0gMSkge1xuICAgICAgICAgICAgcGFydCA9IGFyeVtpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIChhcnlbMl0gPT09ICcuLicgfHwgYXJ5WzBdID09PSAnLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICAvL0VuZCBvZiB0aGUgbGluZS4gS2VlcCBhdCBsZWFzdCBvbmUgbm9uLWRvdFxuICAgICAgICAgICAgICAgICAgICAvL3BhdGggc2VnbWVudCBhdCB0aGUgZnJvbnQgc28gaXQgY2FuIGJlIG1hcHBlZFxuICAgICAgICAgICAgICAgICAgICAvL2NvcnJlY3RseSB0byBkaXNrLiBPdGhlcndpc2UsIHRoZXJlIGlzIGxpa2VseVxuICAgICAgICAgICAgICAgICAgICAvL25vIHBhdGggbWFwcGluZyBmb3IgYSBwYXRoIHN0YXJ0aW5nIHdpdGggJy4uJy5cbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBzdGlsbCBmYWlsLCBidXQgY2F0Y2hlcyB0aGUgbW9zdCByZWFzb25hYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlcyBvZiAuLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyeS5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XG4gICAgICAgIHZhciBiYXNlUGFydHM7XG5cbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxuICAgICAgICBpZiAobmFtZSAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAvL0lmIGhhdmUgYSBiYXNlIG5hbWUsIHRyeSB0byBub3JtYWxpemUgYWdhaW5zdCBpdCxcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBhc3N1bWUgaXQgaXMgYSB0b3AtbGV2ZWwgcmVxdWlyZSB0aGF0IHdpbGxcbiAgICAgICAgICAgIC8vYmUgcmVsYXRpdmUgdG8gYmFzZVVybCBpbiB0aGUgZW5kLlxuICAgICAgICAgICAgaWYgKGJhc2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZU5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5jb25jYXQobmFtZS5zcGxpdCgnLycpKTtcbiAgICAgICAgICAgICAgICB0cmltRG90cyhiYXNlUGFydHMpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBiYXNlUGFydHMuam9pbignLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBub3JtYWxpemUoKSBmdW5jdGlvbiBwYXNzZWQgdG8gYSBsb2FkZXIgcGx1Z2luJ3NcbiAgICAgKiBub3JtYWxpemUgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoaWQpIHtcbiAgICAgICAgZnVuY3Rpb24gbG9hZCh2YWx1ZSkge1xuICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkLmZyb21UZXh0ID0gZnVuY3Rpb24gKGlkLCB0ZXh0KSB7XG4gICAgICAgICAgICAvL1RoaXMgb25lIGlzIGRpZmZpY3VsdCBiZWNhdXNlIHRoZSB0ZXh0IGNhbi9wcm9iYWJseSB1c2VzXG4gICAgICAgICAgICAvL2RlZmluZSwgYW5kIGFueSByZWxhdGl2ZSBwYXRocyBhbmQgcmVxdWlyZXMgc2hvdWxkIGJlIHJlbGF0aXZlXG4gICAgICAgICAgICAvL3RvIHRoYXQgaWQgd2FzIGl0IHdvdWxkIGJlIGZvdW5kIG9uIGRpc2suIEJ1dCB0aGlzIHdvdWxkIHJlcXVpcmVcbiAgICAgICAgICAgIC8vYm9vdHN0cmFwcGluZyBhIG1vZHVsZS9yZXF1aXJlIGZhaXJseSBkZWVwbHkgZnJvbSBub2RlIGNvcmUuXG4gICAgICAgICAgICAvL05vdCBzdXJlIGhvdyBiZXN0IHRvIGdvIGFib3V0IHRoYXQgeWV0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSBkb2VzIG5vdCBpbXBsZW1lbnQgbG9hZC5mcm9tVGV4dCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsb2FkO1xuICAgIH1cblxuICAgIG1ha2VSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpIHtcbiAgICAgICAgZnVuY3Rpb24gYW1kUmVxdWlyZShkZXBzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vU3luY2hyb25vdXMsIHNpbmdsZSBtb2R1bGUgcmVxdWlyZSgnJylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGRlcHMsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9BcnJheSBvZiBkZXBlbmRlbmNpZXMgd2l0aCBhIGNhbGxiYWNrLlxuXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IHRoZSBkZXBlbmRlbmNpZXMgdG8gbW9kdWxlcy5cbiAgICAgICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBOYW1lLCByZWxJZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL1dhaXQgZm9yIG5leHQgdGljayB0byBjYWxsIGJhY2sgdGhlIHJlcXVpcmUgY2FsbC5cbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZGVwcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhbWRSZXF1aXJlLnRvVXJsID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICBpZiAoZmlsZVBhdGguaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShmaWxlUGF0aCwgcGF0aC5kaXJuYW1lKG1vZHVsZS5maWxlbmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFtZFJlcXVpcmU7XG4gICAgfTtcblxuICAgIC8vRmF2b3IgZXhwbGljaXQgdmFsdWUsIHBhc3NlZCBpbiBpZiB0aGUgbW9kdWxlIHdhbnRzIHRvIHN1cHBvcnQgTm9kZSAwLjQuXG4gICAgcmVxdWlyZUZuID0gcmVxdWlyZUZuIHx8IGZ1bmN0aW9uIHJlcSgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5yZXF1aXJlLmFwcGx5KG1vZHVsZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICB2YXIgciwgZSwgbSwgcmVzdWx0O1xuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgZSA9IGxvYWRlckNhY2hlW2lkXSA9IHt9O1xuICAgICAgICAgICAgbSA9IHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdXJpOiBfX2ZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL09ubHkgc3VwcG9ydCBvbmUgZGVmaW5lIGNhbGwgcGVyIGZpbGVcbiAgICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSB3aXRoIG5vIG1vZHVsZSBJRCBjYW5ub3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHBlciBmaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vVXNlIHRoZSByZWFsIHZhcmlhYmxlcyBmcm9tIG5vZGVcbiAgICAgICAgICAgIC8vVXNlIG1vZHVsZS5leHBvcnRzIGZvciBleHBvcnRzLCBzaW5jZVxuICAgICAgICAgICAgLy90aGUgZXhwb3J0cyBpbiBoZXJlIGlzIGFtZGVmaW5lIGV4cG9ydHMuXG4gICAgICAgICAgICBlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgICAgICBtID0gbW9kdWxlO1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgbW9kdWxlLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vSWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llcywgdGhleSBhcmUgc3RyaW5ncywgc28gbmVlZFxuICAgICAgICAvL3RvIGNvbnZlcnQgdGhlbSB0byBkZXBlbmRlbmN5IHZhbHVlcy5cbiAgICAgICAgaWYgKGRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByKGRlcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0NhbGwgdGhlIGZhY3Rvcnkgd2l0aCB0aGUgcmlnaHQgZGVwZW5kZW5jaWVzLlxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3RvcnkuYXBwbHkobS5leHBvcnRzLCBkZXBzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3Rvcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG0uZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IG0uZXhwb3J0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0cmluZ1JlcXVpcmUgPSBmdW5jdGlvbiAoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBpZCwgcmVsSWQpIHtcbiAgICAgICAgLy9TcGxpdCB0aGUgSUQgYnkgYSAhIHNvIHRoYXRcbiAgICAgICAgdmFyIGluZGV4ID0gaWQuaW5kZXhPZignIScpLFxuICAgICAgICAgICAgb3JpZ2luYWxJZCA9IGlkLFxuICAgICAgICAgICAgcHJlZml4LCBwbHVnaW47XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcblxuICAgICAgICAgICAgLy9TdHJhaWdodCBtb2R1bGUgbG9va3VwLiBJZiBpdCBpcyBvbmUgb2YgdGhlIHNwZWNpYWwgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgLy9kZWFsIHdpdGggaXQsIG90aGVyd2lzZSwgZGVsZWdhdGUgdG8gbm9kZS5cbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ3JlcXVpcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ2V4cG9ydHMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvYWRlckNhY2hlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZihzeXN0ZW1SZXF1aXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1SZXF1aXJlKG9yaWdpbmFsSWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9kdWxlIHdpdGggSUQ6ICcgKyBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9UaGVyZSBpcyBhIHBsdWdpbiBpbiBwbGF5LlxuICAgICAgICAgICAgcHJlZml4ID0gaWQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKGluZGV4ICsgMSwgaWQubGVuZ3RoKTtcblxuICAgICAgICAgICAgcGx1Z2luID0gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHByZWZpeCwgcmVsSWQpO1xuXG4gICAgICAgICAgICBpZiAocGx1Z2luLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIGlkID0gcGx1Z2luLm5vcm1hbGl6ZShpZCwgbWFrZU5vcm1hbGl6ZShyZWxJZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL05vcm1hbGl6ZSB0aGUgSUQgbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5sb2FkKGlkLCBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSwgbWFrZUxvYWQoaWQpLCB7fSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vQ3JlYXRlIGEgZGVmaW5lIGZ1bmN0aW9uIHNwZWNpZmljIHRvIHRoZSBtb2R1bGUgYXNraW5nIGZvciBhbWRlZmluZS5cbiAgICBmdW5jdGlvbiBkZWZpbmUoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSBpZDtcbiAgICAgICAgICAgIGlkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBpZDtcbiAgICAgICAgICAgIGlkID0gZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXBzICYmICFBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vU2V0IHVwIHByb3BlcnRpZXMgZm9yIHRoaXMgbW9kdWxlLiBJZiBhbiBJRCwgdGhlbiB1c2VcbiAgICAgICAgLy9pbnRlcm5hbCBjYWNoZS4gSWYgbm8gSUQsIHRoZW4gdXNlIHRoZSBleHRlcm5hbCB2YXJpYWJsZXNcbiAgICAgICAgLy9mb3IgdGhpcyBub2RlIG1vZHVsZS5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAvL1B1dCB0aGUgbW9kdWxlIGluIGRlZXAgZnJlZXplIHVudGlsIHRoZXJlIGlzIGFcbiAgICAgICAgICAgIC8vcmVxdWlyZSBjYWxsIGZvciBpdC5cbiAgICAgICAgICAgIGRlZmluZUNhY2hlW2lkXSA9IFtpZCwgZGVwcywgZmFjdG9yeV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZGVmaW5lLnJlcXVpcmUsIHdoaWNoIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSB2YWx1ZXMgaW4gdGhlXG4gICAgLy9jYWNoZS4gVXNlZnVsIGZvciBBTUQgbW9kdWxlcyB0aGF0IGFsbCBoYXZlIElEcyBpbiB0aGUgZmlsZSxcbiAgICAvL2J1dCBuZWVkIHRvIGZpbmFsbHkgZXhwb3J0IGEgdmFsdWUgdG8gbm9kZSBiYXNlZCBvbiBvbmUgb2YgdGhvc2VcbiAgICAvL0lEcy5cbiAgICBkZWZpbmUucmVxdWlyZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUuYW1kID0ge307XG5cbiAgICByZXR1cm4gZGVmaW5lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFtZGVmaW5lO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJlc2NvZGVnZW5cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkVDTUFTY3JpcHQgY29kZSBnZW5lcmF0b3JcIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHA6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuXCIsXG4gIFwibWFpblwiOiBcImVzY29kZWdlbi5qc1wiLFxuICBcImJpblwiOiB7XG4gICAgXCJlc2dlbmVyYXRlXCI6IFwiLi9iaW4vZXNnZW5lcmF0ZS5qc1wiLFxuICAgIFwiZXNjb2RlZ2VuXCI6IFwiLi9iaW4vZXNjb2RlZ2VuLmpzXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjItZGV2XCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0wLjQuMFwiXG4gIH0sXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIll1c3VrZSBTdXp1a2lcIixcbiAgICAgIFwiZW1haWxcIjogXCJ1dGF0YW5lLnRlYUBnbWFpbC5jb21cIixcbiAgICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvblwiXG4gICAgfVxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbi9lc2NvZGVnZW4uZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZXNwcmltYVwiOiBcIn4xLjAuNFwiLFxuICAgIFwiZXN0cmF2ZXJzZVwiOiBcIn4xLjUuMFwiLFxuICAgIFwiZXN1dGlsc1wiOiBcIn4xLjAuMFwiLFxuICAgIFwic291cmNlLW1hcFwiOiBcIn4wLjEuMzBcIlxuICB9LFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInNvdXJjZS1tYXBcIjogXCJ+MC4xLjMwXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZXNwcmltYS1tb3pcIjogXCIqXCIsXG4gICAgXCJjb21tb25qcy1ldmVyeXdoZXJlXCI6IFwifjAuOC4wXCIsXG4gICAgXCJxXCI6IFwiKlwiLFxuICAgIFwiYm93ZXJcIjogXCIqXCIsXG4gICAgXCJzZW12ZXJcIjogXCIqXCIsXG4gICAgXCJjaGFpXCI6IFwifjEuNy4yXCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjUuMFwiLFxuICAgIFwiZ3J1bnQtY2xpXCI6IFwifjAuMS45XCIsXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMVwiLFxuICAgIFwiZ3J1bnQtbW9jaGEtdGVzdFwiOiBcIn4wLjYuMlwiXG4gIH0sXG4gIFwibGljZW5zZXNcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcIkJTRFwiLFxuICAgICAgXCJ1cmxcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2VzY29kZWdlbi9yYXcvbWFzdGVyL0xJQ0VOU0UuQlNEXCJcbiAgICB9XG4gIF0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZ3J1bnQgdHJhdmlzXCIsXG4gICAgXCJ1bml0LXRlc3RcIjogXCJncnVudCB0ZXN0XCIsXG4gICAgXCJsaW50XCI6IFwiZ3J1bnQgbGludFwiLFxuICAgIFwicmVsZWFzZVwiOiBcIm5vZGUgdG9vbHMvcmVsZWFzZS5qc1wiLFxuICAgIFwiYnVpbGQtbWluXCI6IFwiLi9ub2RlX21vZHVsZXMvLmJpbi9janNpZnkgLW1hIHBhdGg6IHRvb2xzL2VudHJ5LXBvaW50LmpzID4gZXNjb2RlZ2VuLmJyb3dzZXIubWluLmpzXCIsXG4gICAgXCJidWlsZFwiOiBcIi4vbm9kZV9tb2R1bGVzLy5iaW4vY2pzaWZ5IC1hIHBhdGg6IHRvb2xzL2VudHJ5LXBvaW50LmpzID4gZXNjb2RlZ2VuLmJyb3dzZXIuanNcIlxuICB9LFxuICBcInJlYWRtZVwiOiBcIlxcbiMjIyBFc2NvZGVnZW4gWyFbQnVpbGQgU3RhdHVzXShodHRwczovL3NlY3VyZS50cmF2aXMtY2kub3JnL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuLnBuZyldKGh0dHA6Ly90cmF2aXMtY2kub3JnL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuKSBbIVtCdWlsZCBTdGF0dXNdKGh0dHBzOi8vZHJvbmUuaW8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2VzY29kZWdlbi9zdGF0dXMucG5nKV0oaHR0cHM6Ly9kcm9uZS5pby9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuL2xhdGVzdClcXG5cXG5Fc2NvZGVnZW4gKFtlc2NvZGVnZW5dKGh0dHA6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuKSkgaXNcXG5bRUNNQVNjcmlwdF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9zdGFuZGFyZHMvRWNtYS0yNjIuaHRtKVxcbihhbHNvIHBvcHVsYXJseSBrbm93biBhcyBbSmF2YVNjcmlwdF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KYXZhU2NyaXB0PkphdmFTY3JpcHQpKVxcbmNvZGUgZ2VuZXJhdG9yIGZyb20gW1BhcnNlciBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJKSBBU1QuXFxuU2VlIFtvbmxpbmUgZ2VuZXJhdG9yIGRlbW9dKGh0dHA6Ly9jb25zdGVsbGF0aW9uLmdpdGh1Yi5jb20vZXNjb2RlZ2VuL2RlbW8vaW5kZXguaHRtbCkuXFxuXFxuXFxuIyMjIEluc3RhbGxcXG5cXG5Fc2NvZGVnZW4gY2FuIGJlIHVzZWQgaW4gYSB3ZWIgYnJvd3NlcjpcXG5cXG4gICAgPHNjcmlwdCBzcmM9XFxcImVzY29kZWdlbi5icm93c2VyLmpzXFxcIj48L3NjcmlwdD5cXG5cXG5lc2NvZGVnZW4uYnJvd3Nlci5qcyBpcyBmb3VuZCBpbiB0YWdnZWQtcmV2aXNpb24uIFNlZSBUYWdzIG9uIEdpdEh1Yi5cXG5cXG5PciBpbiBhIE5vZGUuanMgYXBwbGljYXRpb24gdmlhIHRoZSBwYWNrYWdlIG1hbmFnZXI6XFxuXFxuICAgIG5wbSBpbnN0YWxsIGVzY29kZWdlblxcblxcbiMjIyBVc2FnZVxcblxcbkEgc2ltcGxlIGV4YW1wbGU6IHRoZSBwcm9ncmFtXFxuXFxuICAgIGVzY29kZWdlbi5nZW5lcmF0ZSh7XFxuICAgICAgICB0eXBlOiAnQmluYXJ5RXhwcmVzc2lvbicsXFxuICAgICAgICBvcGVyYXRvcjogJysnLFxcbiAgICAgICAgbGVmdDogeyB0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiA0MCB9LFxcbiAgICAgICAgcmlnaHQ6IHsgdHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogMiB9XFxuICAgIH0pO1xcblxcbnByb2R1Y2VzIHRoZSBzdHJpbmcgYCc0MCArIDInYFxcblxcblNlZSB0aGUgW0FQSSBwYWdlXShodHRwczovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbi9lc2NvZGVnZW4vd2lraS9BUEkpIGZvclxcbm9wdGlvbnMuIFRvIHJ1biB0aGUgdGVzdHMsIGV4ZWN1dGUgYG5wbSB0ZXN0YCBpbiB0aGUgcm9vdCBkaXJlY3RvcnkuXFxuXFxuIyMjIExpY2Vuc2VcXG5cXG4jIyMjIEVzY29kZWdlblxcblxcbkNvcHlyaWdodCAoQykgMjAxMiBbWXVzdWtlIFN1enVraV0oaHR0cDovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbilcXG4gKHR3aXR0ZXI6IFtAQ29uc3RlbGxhdGlvbl0oaHR0cDovL3R3aXR0ZXIuY29tL0NvbnN0ZWxsYXRpb24pKSBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxcblxcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcblxcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxcbiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XFxuICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcXG4gICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCJcXG5BTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXFxuSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcXG5BUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXFxuRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XFxuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXFxuT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcXG5USElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcblxcbiMjIyMgc291cmNlLW1hcFxcblxcblNvdXJjZU5vZGVNb2NrcyBoYXMgYSBsaW1pdGVkIGludGVyZmFjZSBvZiBtb3ppbGxhL3NvdXJjZS1tYXAgU291cmNlTm9kZSBpbXBsZW1lbnRhdGlvbnMuXFxuXFxuQ29weXJpZ2h0IChjKSAyMDA5LTIwMTEsIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXFxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG5cXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG5tb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xcbiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXFxuICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXFxuICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4qIE5laXRoZXIgdGhlIG5hbWVzIG9mIHRoZSBNb3ppbGxhIEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBwcm9qZWN0XFxuICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzXFxuICBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCIgQU5EXFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxcbkZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXFxuREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcXG5TRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUlxcbkNBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksXFxuT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcXG5PRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcblwiLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwiUkVBRE1FLm1kXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbi9lc2NvZGVnZW4vaXNzdWVzXCJcbiAgfSxcbiAgXCJfaWRcIjogXCJlc2NvZGVnZW5AMS4wLjItZGV2XCIsXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCIyNGUwYmQ0MjMxNjZhZjgxYjllYWEzYWQ3NzI0M2VhNjNmMWYwZGUwXCJcbiAgfSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJnaXQ6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuLmdpdCNlZmVkM2UyMWE1ZDI1NDVkNjA1MGM4Njc0MjJlZTAyN2EwYjdhOWNmXCIsXG4gIFwiX2Zyb21cIjogXCJlc2NvZGVnZW5AZ2l0Oi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2VzY29kZWdlbi5naXQjbWFzdGVyXCJcbn1cbiIsIntcbiAgICB2YXIgX25zXyA9IHtcbiAgICAgICAgICAgIGlkOiAnd2lzcC5yZWFkZXInLFxuICAgICAgICAgICAgZG9jOiAnUmVhZGVyIG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgZm9yIHJlYWRpbmcgdGV4dCBpbnB1dFxcbiAgYXMgd2lzcCBkYXRhIHN0cnVjdHVyZXMnXG4gICAgICAgIH07XG4gICAgdmFyIHdpc3Bfc2VxdWVuY2UgPSByZXF1aXJlKCcuL3NlcXVlbmNlJyk7XG4gICAgdmFyIGxpc3QgPSB3aXNwX3NlcXVlbmNlLmxpc3Q7XG4gICAgdmFyIGlzTGlzdCA9IHdpc3Bfc2VxdWVuY2UuaXNMaXN0O1xuICAgIHZhciBjb3VudCA9IHdpc3Bfc2VxdWVuY2UuY291bnQ7XG4gICAgdmFyIGlzRW1wdHkgPSB3aXNwX3NlcXVlbmNlLmlzRW1wdHk7XG4gICAgdmFyIGZpcnN0ID0gd2lzcF9zZXF1ZW5jZS5maXJzdDtcbiAgICB2YXIgc2Vjb25kID0gd2lzcF9zZXF1ZW5jZS5zZWNvbmQ7XG4gICAgdmFyIHRoaXJkID0gd2lzcF9zZXF1ZW5jZS50aGlyZDtcbiAgICB2YXIgcmVzdCA9IHdpc3Bfc2VxdWVuY2UucmVzdDtcbiAgICB2YXIgbWFwID0gd2lzcF9zZXF1ZW5jZS5tYXA7XG4gICAgdmFyIHZlYyA9IHdpc3Bfc2VxdWVuY2UudmVjO1xuICAgIHZhciBjb25zID0gd2lzcF9zZXF1ZW5jZS5jb25zO1xuICAgIHZhciBjb25qID0gd2lzcF9zZXF1ZW5jZS5jb25qO1xuICAgIHZhciByZXN0ID0gd2lzcF9zZXF1ZW5jZS5yZXN0O1xuICAgIHZhciBjb25jYXQgPSB3aXNwX3NlcXVlbmNlLmNvbmNhdDtcbiAgICB2YXIgbGFzdCA9IHdpc3Bfc2VxdWVuY2UubGFzdDtcbiAgICB2YXIgYnV0bGFzdCA9IHdpc3Bfc2VxdWVuY2UuYnV0bGFzdDtcbiAgICB2YXIgc29ydCA9IHdpc3Bfc2VxdWVuY2Uuc29ydDtcbiAgICB2YXIgbGF6eVNlcSA9IHdpc3Bfc2VxdWVuY2UubGF6eVNlcTtcbiAgICB2YXIgcmVkdWNlID0gd2lzcF9zZXF1ZW5jZS5yZWR1Y2U7XG4gICAgdmFyIHdpc3BfcnVudGltZSA9IHJlcXVpcmUoJy4vcnVudGltZScpO1xuICAgIHZhciBpc09kZCA9IHdpc3BfcnVudGltZS5pc09kZDtcbiAgICB2YXIgZGljdGlvbmFyeSA9IHdpc3BfcnVudGltZS5kaWN0aW9uYXJ5O1xuICAgIHZhciBrZXlzID0gd2lzcF9ydW50aW1lLmtleXM7XG4gICAgdmFyIGlzTmlsID0gd2lzcF9ydW50aW1lLmlzTmlsO1xuICAgIHZhciBpbmMgPSB3aXNwX3J1bnRpbWUuaW5jO1xuICAgIHZhciBkZWMgPSB3aXNwX3J1bnRpbWUuZGVjO1xuICAgIHZhciBpc1ZlY3RvciA9IHdpc3BfcnVudGltZS5pc1ZlY3RvcjtcbiAgICB2YXIgaXNTdHJpbmcgPSB3aXNwX3J1bnRpbWUuaXNTdHJpbmc7XG4gICAgdmFyIGlzTnVtYmVyID0gd2lzcF9ydW50aW1lLmlzTnVtYmVyO1xuICAgIHZhciBpc0Jvb2xlYW4gPSB3aXNwX3J1bnRpbWUuaXNCb29sZWFuO1xuICAgIHZhciBpc09iamVjdCA9IHdpc3BfcnVudGltZS5pc09iamVjdDtcbiAgICB2YXIgaXNEaWN0aW9uYXJ5ID0gd2lzcF9ydW50aW1lLmlzRGljdGlvbmFyeTtcbiAgICB2YXIgcmVQYXR0ZXJuID0gd2lzcF9ydW50aW1lLnJlUGF0dGVybjtcbiAgICB2YXIgcmVNYXRjaGVzID0gd2lzcF9ydW50aW1lLnJlTWF0Y2hlcztcbiAgICB2YXIgcmVGaW5kID0gd2lzcF9ydW50aW1lLnJlRmluZDtcbiAgICB2YXIgc3RyID0gd2lzcF9ydW50aW1lLnN0cjtcbiAgICB2YXIgc3VicyA9IHdpc3BfcnVudGltZS5zdWJzO1xuICAgIHZhciBjaGFyID0gd2lzcF9ydW50aW1lLmNoYXI7XG4gICAgdmFyIHZhbHMgPSB3aXNwX3J1bnRpbWUudmFscztcbiAgICB2YXIgaXNFcXVhbCA9IHdpc3BfcnVudGltZS5pc0VxdWFsO1xuICAgIHZhciB3aXNwX2FzdCA9IHJlcXVpcmUoJy4vYXN0Jyk7XG4gICAgdmFyIGlzU3ltYm9sID0gd2lzcF9hc3QuaXNTeW1ib2w7XG4gICAgdmFyIHN5bWJvbCA9IHdpc3BfYXN0LnN5bWJvbDtcbiAgICB2YXIgaXNLZXl3b3JkID0gd2lzcF9hc3QuaXNLZXl3b3JkO1xuICAgIHZhciBrZXl3b3JkID0gd2lzcF9hc3Qua2V5d29yZDtcbiAgICB2YXIgbWV0YSA9IHdpc3BfYXN0Lm1ldGE7XG4gICAgdmFyIHdpdGhNZXRhID0gd2lzcF9hc3Qud2l0aE1ldGE7XG4gICAgdmFyIG5hbWUgPSB3aXNwX2FzdC5uYW1lO1xuICAgIHZhciBnZW5zeW0gPSB3aXNwX2FzdC5nZW5zeW07XG4gICAgdmFyIHdpc3Bfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbiAgICB2YXIgc3BsaXQgPSB3aXNwX3N0cmluZy5zcGxpdDtcbiAgICB2YXIgam9pbiA9IHdpc3Bfc3RyaW5nLmpvaW47XG59XG52YXIgcHVzaEJhY2tSZWFkZXIgPSBleHBvcnRzLnB1c2hCYWNrUmVhZGVyID0gZnVuY3Rpb24gcHVzaEJhY2tSZWFkZXIoc291cmNlLCB1cmkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdsaW5lcyc6IHNwbGl0KHNvdXJjZSwgJ1xcbicpLFxuICAgICAgICAgICAgJ2J1ZmZlcic6ICcnLFxuICAgICAgICAgICAgJ3VyaSc6IHVyaSxcbiAgICAgICAgICAgICdjb2x1bW4nOiAtMSxcbiAgICAgICAgICAgICdsaW5lJzogMFxuICAgICAgICB9O1xuICAgIH07XG52YXIgcGVla0NoYXIgPSBleHBvcnRzLnBlZWtDaGFyID0gZnVuY3Rpb24gcGVla0NoYXIocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZcO4MSA9IChyZWFkZXIgfHwgMClbJ2xpbmVzJ11bKHJlYWRlciB8fCAwKVsnbGluZSddXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW7DuDEgPSBpbmMoKHJlYWRlciB8fCAwKVsnY29sdW1uJ10pO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmlsKGxpbmXDuDEpID8gdm9pZCAwIDogbGluZcO4MVtjb2x1bW7DuDFdIHx8ICdcXG4nO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciByZWFkQ2hhciA9IGV4cG9ydHMucmVhZENoYXIgPSBmdW5jdGlvbiByZWFkQ2hhcihyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaMO4MSA9IHBlZWtDaGFyKHJlYWRlcik7XG4gICAgICAgICAgICBpc05ld2xpbmUocGVla0NoYXIocmVhZGVyKSkgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIChyZWFkZXIgfHwgMClbJ2xpbmUnXSA9IGluYygocmVhZGVyIHx8IDApWydsaW5lJ10pO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVhZGVyIHx8IDApWydjb2x1bW4nXSA9IC0xO1xuICAgICAgICAgICAgfSkoKSA6IChyZWFkZXIgfHwgMClbJ2NvbHVtbiddID0gaW5jKChyZWFkZXIgfHwgMClbJ2NvbHVtbiddKTtcbiAgICAgICAgICAgIHJldHVybiBjaMO4MTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgaXNOZXdsaW5lID0gZXhwb3J0cy5pc05ld2xpbmUgPSBmdW5jdGlvbiBpc05ld2xpbmUoY2gpIHtcbiAgICAgICAgcmV0dXJuICdcXG4nID09PSBjaDtcbiAgICB9O1xudmFyIGlzQnJlYWtpbmdXaGl0ZXNwYWNlID0gZXhwb3J0cy5pc0JyZWFraW5nV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGlzQnJlYWtpbmdXaGl0ZXNwYWNlKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JyB8fCBjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHInO1xuICAgIH07XG52YXIgaXNXaGl0ZXNwYWNlID0gZXhwb3J0cy5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiBpc1doaXRlc3BhY2UoY2gpIHtcbiAgICAgICAgcmV0dXJuIGlzQnJlYWtpbmdXaGl0ZXNwYWNlKGNoKSB8fCAnLCcgPT09IGNoO1xuICAgIH07XG52YXIgaXNOdW1lcmljID0gZXhwb3J0cy5pc051bWVyaWMgPSBmdW5jdGlvbiBpc051bWVyaWMoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoID09PSAnMCcgfHwgY2ggPT09ICcxJyB8fCBjaCA9PT0gJzInIHx8IGNoID09PSAnMycgfHwgY2ggPT09ICc0JyB8fCBjaCA9PT0gJzUnIHx8IGNoID09PSAnNicgfHwgY2ggPT09ICc3JyB8fCBjaCA9PT0gJzgnIHx8IGNoID09PSAnOSc7XG4gICAgfTtcbnZhciBpc0NvbW1lbnRQcmVmaXggPSBleHBvcnRzLmlzQ29tbWVudFByZWZpeCA9IGZ1bmN0aW9uIGlzQ29tbWVudFByZWZpeChjaCkge1xuICAgICAgICByZXR1cm4gJzsnID09PSBjaDtcbiAgICB9O1xudmFyIGlzTnVtYmVyTGl0ZXJhbCA9IGV4cG9ydHMuaXNOdW1iZXJMaXRlcmFsID0gZnVuY3Rpb24gaXNOdW1iZXJMaXRlcmFsKHJlYWRlciwgaW5pdGNoKSB7XG4gICAgICAgIHJldHVybiBpc051bWVyaWMoaW5pdGNoKSB8fCAoJysnID09PSBpbml0Y2ggfHwgJy0nID09PSBpbml0Y2gpICYmIGlzTnVtZXJpYyhwZWVrQ2hhcihyZWFkZXIpKTtcbiAgICB9O1xudmFyIHJlYWRlckVycm9yID0gZXhwb3J0cy5yZWFkZXJFcnJvciA9IGZ1bmN0aW9uIHJlYWRlckVycm9yKHJlYWRlciwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRleHTDuDEgPSAnJyArIG1lc3NhZ2UgKyAnXFxuJyArICdsaW5lOicgKyAocmVhZGVyIHx8IDApWydsaW5lJ10gKyAnXFxuJyArICdjb2x1bW46JyArIChyZWFkZXIgfHwgMClbJ2NvbHVtbiddO1xuICAgICAgICAgICAgdmFyIGVycm9yw7gxID0gU3ludGF4RXJyb3IodGV4dMO4MSwgKHJlYWRlciB8fCAwKVsndXJpJ10pO1xuICAgICAgICAgICAgZXJyb3LDuDEubGluZSA9IChyZWFkZXIgfHwgMClbJ2xpbmUnXTtcbiAgICAgICAgICAgIGVycm9yw7gxLmNvbHVtbiA9IChyZWFkZXIgfHwgMClbJ2NvbHVtbiddO1xuICAgICAgICAgICAgZXJyb3LDuDEudXJpID0gKHJlYWRlciB8fCAwKVsndXJpJ107XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcsO4MTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGlzTWFjcm9UZXJtaW5hdGluZyA9IGV4cG9ydHMuaXNNYWNyb1Rlcm1pbmF0aW5nID0gZnVuY3Rpb24gaXNNYWNyb1Rlcm1pbmF0aW5nKGNoKSB7XG4gICAgICAgIHJldHVybiAhKGNoID09PSAnIycpICYmICEoY2ggPT09ICdcXCcnKSAmJiAhKGNoID09PSAnOicpICYmIG1hY3JvcyhjaCk7XG4gICAgfTtcbnZhciByZWFkVG9rZW4gPSBleHBvcnRzLnJlYWRUb2tlbiA9IGZ1bmN0aW9uIHJlYWRUb2tlbihyZWFkZXIsIGluaXRjaCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgYnVmZmVyw7gxID0gaW5pdGNoO1xuICAgICAgICAgICAgdmFyIGNow7gxID0gcGVla0NoYXIocmVhZGVyKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZWN1ciA9IGlzTmlsKGNow7gxKSB8fCBpc1doaXRlc3BhY2UoY2jDuDEpIHx8IGlzTWFjcm9UZXJtaW5hdGluZyhjaMO4MSkgPyBidWZmZXLDuDEgOiAobG9vcFswXSA9ICcnICsgYnVmZmVyw7gxICsgcmVhZENoYXIocmVhZGVyKSwgbG9vcFsxXSA9IHBlZWtDaGFyKHJlYWRlciksIGxvb3ApO1xuICAgICAgICAgICAgfSB3aGlsZSAoYnVmZmVyw7gxID0gbG9vcFswXSwgY2jDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHNraXBMaW5lID0gZXhwb3J0cy5za2lwTGluZSA9IGZ1bmN0aW9uIHNraXBMaW5lKHJlYWRlciwgXykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVjdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaMO4MSA9IHJlYWRDaGFyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaMO4MSA9PT0gJ1xcbicgfHwgY2jDuDEgPT09ICdcXHInIHx8IGlzTmlsKGNow7gxKSA/IHJlYWRlciA6IChsb29wKTtcbiAgICAgICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChyZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGludFBhdHRlcm4gPSBleHBvcnRzLmludFBhdHRlcm4gPSByZVBhdHRlcm4oJ14oWy0rXT8pKD86KDApfChbMS05XVswLTldKil8MFt4WF0oWzAtOUEtRmEtZl0rKXwwKFswLTddKyl8KFsxLTldWzAtOV0/KVtyUl0oWzAtOUEtWmEtel0rKXwwWzAtOV0rKShOKT8kJyk7XG52YXIgcmF0aW9QYXR0ZXJuID0gZXhwb3J0cy5yYXRpb1BhdHRlcm4gPSByZVBhdHRlcm4oJyhbLStdP1swLTldKykvKFswLTldKyknKTtcbnZhciBmbG9hdFBhdHRlcm4gPSBleHBvcnRzLmZsb2F0UGF0dGVybiA9IHJlUGF0dGVybignKFstK10/WzAtOV0rKFxcXFwuWzAtOV0qKT8oW2VFXVstK10/WzAtOV0rKT8pKE0pPycpO1xudmFyIG1hdGNoSW50ID0gZXhwb3J0cy5tYXRjaEludCA9IGZ1bmN0aW9uIG1hdGNoSW50KHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBncm91cHPDuDEgPSByZUZpbmQoaW50UGF0dGVybiwgcyk7XG4gICAgICAgICAgICB2YXIgZ3JvdXAzw7gxID0gZ3JvdXBzw7gxWzJdO1xuICAgICAgICAgICAgcmV0dXJuICEoaXNOaWwoZ3JvdXAzw7gxKSB8fCBjb3VudChncm91cDPDuDEpIDwgMSkgPyAwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZWdhdGXDuDEgPSAnLScgPT09IGdyb3Vwc8O4MVsxXSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgYcO4MSA9IGdyb3Vwc8O4MVszXSA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc8O4MVszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgIF0gOiBncm91cHPDuDFbNF0gPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHPDuDFbNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAxNlxuICAgICAgICAgICAgICAgICAgICBdIDogZ3JvdXBzw7gxWzVdID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzw7gxWzVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgICAgICAgICBdIDogZ3JvdXBzw7gxWzddID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzw7gxWzddLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZ3JvdXBzw7gxWzddKVxuICAgICAgICAgICAgICAgICAgICBdIDogJ2Vsc2UnID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIF0gOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIG7DuDEgPSBhw7gxWzBdO1xuICAgICAgICAgICAgICAgIHZhciByYWRpeMO4MSA9IGHDuDFbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTmlsKG7DuDEpID8gdm9pZCAwIDogbmVnYXRlw7gxICogcGFyc2VJbnQobsO4MSwgcmFkaXjDuDEpO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBtYXRjaFJhdGlvID0gZXhwb3J0cy5tYXRjaFJhdGlvID0gZnVuY3Rpb24gbWF0Y2hSYXRpbyhzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBzw7gxID0gcmVGaW5kKHJhdGlvUGF0dGVybiwgcyk7XG4gICAgICAgICAgICB2YXIgbnVtaW5hdG9yw7gxID0gZ3JvdXBzw7gxWzFdO1xuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yw7gxID0gZ3JvdXBzw7gxWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bWluYXRvcsO4MSkgLyBwYXJzZUludChkZW5vbWluYXRvcsO4MSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIG1hdGNoRmxvYXQgPSBleHBvcnRzLm1hdGNoRmxvYXQgPSBmdW5jdGlvbiBtYXRjaEZsb2F0KHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocyk7XG4gICAgfTtcbnZhciBtYXRjaE51bWJlciA9IGV4cG9ydHMubWF0Y2hOdW1iZXIgPSBmdW5jdGlvbiBtYXRjaE51bWJlcihzKSB7XG4gICAgICAgIHJldHVybiByZU1hdGNoZXMoaW50UGF0dGVybiwgcykgPyBtYXRjaEludChzKSA6IHJlTWF0Y2hlcyhyYXRpb1BhdHRlcm4sIHMpID8gbWF0Y2hSYXRpbyhzKSA6IHJlTWF0Y2hlcyhmbG9hdFBhdHRlcm4sIHMpID8gbWF0Y2hGbG9hdChzKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIGVzY2FwZUNoYXJNYXAgPSBleHBvcnRzLmVzY2FwZUNoYXJNYXAgPSBmdW5jdGlvbiBlc2NhcGVDaGFyTWFwKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09ICd0JyA/ICdcXHQnIDogYyA9PT0gJ3InID8gJ1xccicgOiBjID09PSAnbicgPyAnXFxuJyA6IGMgPT09ICdcXFxcJyA/ICdcXFxcJyA6IGMgPT09ICdcIicgPyAnXCInIDogYyA9PT0gJ2InID8gJ1xcYicgOiBjID09PSAnZicgPyAnXFxmJyA6ICdlbHNlJyA/IHZvaWQgMCA6IHZvaWQgMDtcbiAgICB9O1xudmFyIHJlYWQyQ2hhcnMgPSBleHBvcnRzLnJlYWQyQ2hhcnMgPSBmdW5jdGlvbiByZWFkMkNoYXJzKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gJycgKyByZWFkQ2hhcihyZWFkZXIpICsgcmVhZENoYXIocmVhZGVyKTtcbiAgICB9O1xudmFyIHJlYWQ0Q2hhcnMgPSBleHBvcnRzLnJlYWQ0Q2hhcnMgPSBmdW5jdGlvbiByZWFkNENoYXJzKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gJycgKyByZWFkQ2hhcihyZWFkZXIpICsgcmVhZENoYXIocmVhZGVyKSArIHJlYWRDaGFyKHJlYWRlcikgKyByZWFkQ2hhcihyZWFkZXIpO1xuICAgIH07XG52YXIgdW5pY29kZTJQYXR0ZXJuID0gZXhwb3J0cy51bmljb2RlMlBhdHRlcm4gPSByZVBhdHRlcm4oJ1swLTlBLUZhLWZdezJ9Jyk7XG52YXIgdW5pY29kZTRQYXR0ZXJuID0gZXhwb3J0cy51bmljb2RlNFBhdHRlcm4gPSByZVBhdHRlcm4oJ1swLTlBLUZhLWZdezR9Jyk7XG52YXIgdmFsaWRhdGVVbmljb2RlRXNjYXBlID0gZXhwb3J0cy52YWxpZGF0ZVVuaWNvZGVFc2NhcGUgPSBmdW5jdGlvbiB2YWxpZGF0ZVVuaWNvZGVFc2NhcGUodW5pY29kZVBhdHRlcm4sIHJlYWRlciwgZXNjYXBlQ2hhciwgdW5pY29kZVN0cikge1xuICAgICAgICByZXR1cm4gcmVNYXRjaGVzKHVuaWNvZGVQYXR0ZXJuLCB1bmljb2RlU3RyKSA/IHVuaWNvZGVTdHIgOiByZWFkZXJFcnJvcihyZWFkZXIsICcnICsgJ1VuZXhwZWN0ZWQgdW5pY29kZSBlc2NhcGUgJyArICdcXFxcJyArIGVzY2FwZUNoYXIgKyB1bmljb2RlU3RyKTtcbiAgICB9O1xudmFyIG1ha2VVbmljb2RlQ2hhciA9IGV4cG9ydHMubWFrZVVuaWNvZGVDaGFyID0gZnVuY3Rpb24gbWFrZVVuaWNvZGVDaGFyKGNvZGVTdHIsIGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlw7gyID0gYmFzZSB8fCAxNjtcbiAgICAgICAgICAgIHZhciBjb2Rlw7gxID0gcGFyc2VJbnQoY29kZVN0ciwgYmFzZcO4Mik7XG4gICAgICAgICAgICByZXR1cm4gY2hhcihjb2Rlw7gxKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgZXNjYXBlQ2hhciA9IGV4cG9ydHMuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uIGVzY2FwZUNoYXIoYnVmZmVyLCByZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaMO4MSA9IHJlYWRDaGFyKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgbWFwcmVzdWx0w7gxID0gZXNjYXBlQ2hhck1hcChjaMO4MSk7XG4gICAgICAgICAgICByZXR1cm4gbWFwcmVzdWx0w7gxID8gbWFwcmVzdWx0w7gxIDogY2jDuDEgPT09ICd4JyA/IG1ha2VVbmljb2RlQ2hhcih2YWxpZGF0ZVVuaWNvZGVFc2NhcGUodW5pY29kZTJQYXR0ZXJuLCByZWFkZXIsIGNow7gxLCByZWFkMkNoYXJzKHJlYWRlcikpKSA6IGNow7gxID09PSAndScgPyBtYWtlVW5pY29kZUNoYXIodmFsaWRhdGVVbmljb2RlRXNjYXBlKHVuaWNvZGU0UGF0dGVybiwgcmVhZGVyLCBjaMO4MSwgcmVhZDRDaGFycyhyZWFkZXIpKSkgOiBpc051bWVyaWMoY2jDuDEpID8gY2hhcihjaMO4MSkgOiAnZWxzZScgPyByZWFkZXJFcnJvcihyZWFkZXIsICcnICsgJ1VuZXhwZWN0ZWQgdW5pY29kZSBlc2NhcGUgJyArICdcXFxcJyArIGNow7gxKSA6IHZvaWQgMDtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVhZFBhc3QgPSBleHBvcnRzLnJlYWRQYXN0ID0gZnVuY3Rpb24gcmVhZFBhc3QocHJlZGljYXRlLCByZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgdmFyIF/DuDEgPSB2b2lkIDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVjdXIgPSBwcmVkaWNhdGUocGVla0NoYXIocmVhZGVyKSkgPyAobG9vcFswXSA9IHJlYWRDaGFyKHJlYWRlciksIGxvb3ApIDogcGVla0NoYXIocmVhZGVyKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKF/DuDEgPSBsb29wWzBdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlYWREZWxpbWl0ZWRMaXN0ID0gZXhwb3J0cy5yZWFkRGVsaW1pdGVkTGlzdCA9IGZ1bmN0aW9uIHJlYWREZWxpbWl0ZWRMaXN0KGRlbGltLCByZWFkZXIsIGlzUmVjdXJzaXZlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgIHZhciBmb3Jtc8O4MSA9IFtdO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX8O4MSA9IHJlYWRQYXN0KGlzV2hpdGVzcGFjZSwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNow7gxID0gcmVhZENoYXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgIWNow7gxID8gcmVhZGVyRXJyb3IocmVhZGVyLCAnRU9GJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxpbSA9PT0gY2jDuDEgPyBmb3Jtc8O4MSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3Jtw7gxID0gcmVhZEZvcm0ocmVhZGVyLCBjaMO4MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vcFswXSA9IGZvcm3DuDEgPT09IHJlYWRlciA/IGZvcm1zw7gxIDogY29uaihmb3Jtc8O4MSwgZm9ybcO4MSksIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChmb3Jtc8O4MSA9IGxvb3BbMF0sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgbm90SW1wbGVtZW50ZWQgPSBleHBvcnRzLm5vdEltcGxlbWVudGVkID0gZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQocmVhZGVyLCBjaCkge1xuICAgICAgICByZXR1cm4gcmVhZGVyRXJyb3IocmVhZGVyLCAnJyArICdSZWFkZXIgZm9yICcgKyBjaCArICcgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH07XG52YXIgcmVhZERpc3BhdGNoID0gZXhwb3J0cy5yZWFkRGlzcGF0Y2ggPSBmdW5jdGlvbiByZWFkRGlzcGF0Y2gocmVhZGVyLCBfKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2jDuDEgPSByZWFkQ2hhcihyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGRtw7gxID0gZGlzcGF0Y2hNYWNyb3MoY2jDuDEpO1xuICAgICAgICAgICAgcmV0dXJuIGRtw7gxID8gZG3DuDEocmVhZGVyLCBfKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0w7gxID0gbWF5YmVSZWFkVGFnZ2VkVHlwZShyZWFkZXIsIGNow7gxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0w7gxID8gb2JqZWN0w7gxIDogcmVhZGVyRXJyb3IocmVhZGVyLCAnTm8gZGlzcGF0Y2ggbWFjcm8gZm9yICcsIGNow7gxKTtcbiAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVhZFVubWF0Y2hlZERlbGltaXRlciA9IGV4cG9ydHMucmVhZFVubWF0Y2hlZERlbGltaXRlciA9IGZ1bmN0aW9uIHJlYWRVbm1hdGNoZWREZWxpbWl0ZXIocmRyLCBjaCkge1xuICAgICAgICByZXR1cm4gcmVhZGVyRXJyb3IocmRyLCAnVW5tYWNoZWQgZGVsaW1pdGVyICcsIGNoKTtcbiAgICB9O1xudmFyIHJlYWRMaXN0ID0gZXhwb3J0cy5yZWFkTGlzdCA9IGZ1bmN0aW9uIHJlYWRMaXN0KHJlYWRlciwgXykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZvcm3DuDEgPSByZWFkRGVsaW1pdGVkTGlzdCgnKScsIHJlYWRlciwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gd2l0aE1ldGEobGlzdC5hcHBseSh2b2lkIDAsIGZvcm3DuDEpLCBtZXRhKGZvcm3DuDEpKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVhZENvbW1lbnQgPSBleHBvcnRzLnJlYWRDb21tZW50ID0gZnVuY3Rpb24gcmVhZENvbW1lbnQocmVhZGVyLCBfKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgIHZhciBidWZmZXLDuDEgPSAnJztcbiAgICAgICAgICAgIHZhciBjaMO4MSA9IHJlYWRDaGFyKHJlYWRlcik7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVjdXIgPSBpc05pbChjaMO4MSkgfHwgJ1xcbicgPT09IGNow7gxID8gcmVhZGVyIHx8IGxpc3Qoc3ltYm9sKHZvaWQgMCwgJ2NvbW1lbnQnKSwgYnVmZmVyw7gxKSA6ICdcXFxcJyA9PT0gY2jDuDEgPyAobG9vcFswXSA9ICcnICsgYnVmZmVyw7gxICsgZXNjYXBlQ2hhcihidWZmZXLDuDEsIHJlYWRlciksIGxvb3BbMV0gPSByZWFkQ2hhcihyZWFkZXIpLCBsb29wKSA6ICdlbHNlJyA/IChsb29wWzBdID0gJycgKyBidWZmZXLDuDEgKyBjaMO4MSwgbG9vcFsxXSA9IHJlYWRDaGFyKHJlYWRlciksIGxvb3ApIDogdm9pZCAwO1xuICAgICAgICAgICAgfSB3aGlsZSAoYnVmZmVyw7gxID0gbG9vcFswXSwgY2jDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlYWRWZWN0b3IgPSBleHBvcnRzLnJlYWRWZWN0b3IgPSBmdW5jdGlvbiByZWFkVmVjdG9yKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZERlbGltaXRlZExpc3QoJ10nLCByZWFkZXIsIHRydWUpO1xuICAgIH07XG52YXIgcmVhZE1hcCA9IGV4cG9ydHMucmVhZE1hcCA9IGZ1bmN0aW9uIHJlYWRNYXAocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm9ybcO4MSA9IHJlYWREZWxpbWl0ZWRMaXN0KCd9JywgcmVhZGVyLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBpc09kZChjb3VudChmb3Jtw7gxKSkgPyByZWFkZXJFcnJvcihyZWFkZXIsICdNYXAgbGl0ZXJhbCBtdXN0IGNvbnRhaW4gYW4gZXZlbiBudW1iZXIgb2YgZm9ybXMnKSA6IHdpdGhNZXRhKGRpY3Rpb25hcnkuYXBwbHkodm9pZCAwLCBmb3Jtw7gxKSwgbWV0YShmb3Jtw7gxKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlYWRTZXQgPSBleHBvcnRzLnJlYWRTZXQgPSBmdW5jdGlvbiByZWFkU2V0KHJlYWRlciwgXykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZvcm3DuDEgPSByZWFkRGVsaW1pdGVkTGlzdCgnfScsIHJlYWRlciwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gd2l0aE1ldGEoY29uY2F0KFtzeW1ib2wodm9pZCAwLCAnc2V0JyldLCBmb3Jtw7gxKSwgbWV0YShmb3Jtw7gxKSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlYWROdW1iZXIgPSBleHBvcnRzLnJlYWROdW1iZXIgPSBmdW5jdGlvbiByZWFkTnVtYmVyKHJlYWRlciwgaW5pdGNoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgIHZhciBidWZmZXLDuDEgPSBpbml0Y2g7XG4gICAgICAgICAgICB2YXIgY2jDuDEgPSBwZWVrQ2hhcihyZWFkZXIpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gaXNOaWwoY2jDuDEpIHx8IGlzV2hpdGVzcGFjZShjaMO4MSkgfHwgbWFjcm9zKGNow7gxKSA/IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoTnVtYmVyKGJ1ZmZlcsO4MSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc05pbChtYXRjaCkgPyByZWFkZXJFcnJvcihyZWFkZXIsICdJbnZhbGlkIG51bWJlciBmb3JtYXQgWycsIGJ1ZmZlcsO4MSwgJ10nKSA6IG5ldyBOdW1iZXIobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH0pKCkgOiAobG9vcFswXSA9ICcnICsgYnVmZmVyw7gxICsgcmVhZENoYXIocmVhZGVyKSwgbG9vcFsxXSA9IHBlZWtDaGFyKHJlYWRlciksIGxvb3ApO1xuICAgICAgICAgICAgfSB3aGlsZSAoYnVmZmVyw7gxID0gbG9vcFswXSwgY2jDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlYWRTdHJpbmcgPSBleHBvcnRzLnJlYWRTdHJpbmcgPSBmdW5jdGlvbiByZWFkU3RyaW5nKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgYnVmZmVyw7gxID0gJyc7XG4gICAgICAgICAgICB2YXIgY2jDuDEgPSByZWFkQ2hhcihyZWFkZXIpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gaXNOaWwoY2jDuDEpID8gcmVhZGVyRXJyb3IocmVhZGVyLCAnRU9GIHdoaWxlIHJlYWRpbmcgc3RyaW5nJykgOiAnXFxcXCcgPT09IGNow7gxID8gKGxvb3BbMF0gPSAnJyArIGJ1ZmZlcsO4MSArIGVzY2FwZUNoYXIoYnVmZmVyw7gxLCByZWFkZXIpLCBsb29wWzFdID0gcmVhZENoYXIocmVhZGVyKSwgbG9vcCkgOiAnXCInID09PSBjaMO4MSA/IG5ldyBTdHJpbmcoYnVmZmVyw7gxKSA6ICdkZWZhdWx0JyA/IChsb29wWzBdID0gJycgKyBidWZmZXLDuDEgKyBjaMO4MSwgbG9vcFsxXSA9IHJlYWRDaGFyKHJlYWRlciksIGxvb3ApIDogdm9pZCAwO1xuICAgICAgICAgICAgfSB3aGlsZSAoYnVmZmVyw7gxID0gbG9vcFswXSwgY2jDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlYWRDaGFyYWN0ZXIgPSBleHBvcnRzLnJlYWRDaGFyYWN0ZXIgPSBmdW5jdGlvbiByZWFkQ2hhcmFjdGVyKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZyhyZWFkQ2hhcihyZWFkZXIpKTtcbiAgICB9O1xudmFyIHJlYWRVbnF1b3RlID0gZXhwb3J0cy5yZWFkVW5xdW90ZSA9IGZ1bmN0aW9uIHJlYWRVbnF1b3RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNow7gxID0gcGVla0NoYXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiAhY2jDuDEgPyByZWFkZXJFcnJvcihyZWFkZXIsICdFT0Ygd2hpbGUgcmVhZGluZyBjaGFyYWN0ZXInKSA6IGNow7gxID09PSAnQCcgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlYWRDaGFyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Qoc3ltYm9sKHZvaWQgMCwgJ3VucXVvdGUtc3BsaWNpbmcnKSwgcmVhZChyZWFkZXIsIHRydWUsIHZvaWQgMCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfSkoKSA6IGxpc3Qoc3ltYm9sKHZvaWQgMCwgJ3VucXVvdGUnKSwgcmVhZChyZWFkZXIsIHRydWUsIHZvaWQgMCwgdHJ1ZSkpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBzcGVjaWFsU3ltYm9scyA9IGV4cG9ydHMuc3BlY2lhbFN5bWJvbHMgPSBmdW5jdGlvbiBzcGVjaWFsU3ltYm9scyh0ZXh0LCBub3RGb3VuZCkge1xuICAgICAgICByZXR1cm4gdGV4dCA9PT0gJ25pbCcgPyB2b2lkIDAgOiB0ZXh0ID09PSAndHJ1ZScgPyB0cnVlIDogdGV4dCA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogJ2Vsc2UnID8gbm90Rm91bmQgOiB2b2lkIDA7XG4gICAgfTtcbnZhciByZWFkU3ltYm9sID0gZXhwb3J0cy5yZWFkU3ltYm9sID0gZnVuY3Rpb24gcmVhZFN5bWJvbChyZWFkZXIsIGluaXRjaCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRva2Vuw7gxID0gcmVhZFRva2VuKHJlYWRlciwgaW5pdGNoKTtcbiAgICAgICAgICAgIHZhciBwYXJ0c8O4MSA9IHNwbGl0KHRva2Vuw7gxLCAnLycpO1xuICAgICAgICAgICAgdmFyIGhhc05zw7gxID0gY291bnQocGFydHPDuDEpID4gMSAmJiBjb3VudCh0b2tlbsO4MSkgPiAxO1xuICAgICAgICAgICAgdmFyIG5zw7gxID0gZmlyc3QocGFydHPDuDEpO1xuICAgICAgICAgICAgdmFyIG5hbWXDuDEgPSBqb2luKCcvJywgcmVzdChwYXJ0c8O4MSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc05zw7gxID8gc3ltYm9sKG5zw7gxLCBuYW1lw7gxKSA6IHNwZWNpYWxTeW1ib2xzKHRva2Vuw7gxLCBzeW1ib2wodG9rZW7DuDEpKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVhZEtleXdvcmQgPSBleHBvcnRzLnJlYWRLZXl3b3JkID0gZnVuY3Rpb24gcmVhZEtleXdvcmQocmVhZGVyLCBpbml0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbsO4MSA9IHJlYWRUb2tlbihyZWFkZXIsIHJlYWRDaGFyKHJlYWRlcikpO1xuICAgICAgICAgICAgdmFyIHBhcnRzw7gxID0gc3BsaXQodG9rZW7DuDEsICcvJyk7XG4gICAgICAgICAgICB2YXIgbmFtZcO4MSA9IGxhc3QocGFydHPDuDEpO1xuICAgICAgICAgICAgdmFyIG5zw7gxID0gY291bnQocGFydHPDuDEpID4gMSA/IGpvaW4oJy8nLCBidXRsYXN0KHBhcnRzw7gxKSkgOiB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgaXNzdWXDuDEgPSBsYXN0KG5zw7gxKSA9PT0gJzonID8gJ25hbWVzcGFjZSBjYW5cXCd0IGVuZHMgd2l0aCBcIjpcIicgOiBsYXN0KG5hbWXDuDEpID09PSAnOicgPyAnbmFtZSBjYW5cXCd0IGVuZCB3aXRoIFwiOlwiJyA6IGxhc3QobmFtZcO4MSkgPT09ICcvJyA/ICduYW1lIGNhblxcJ3QgZW5kIHdpdGggXCIvXCInIDogY291bnQoc3BsaXQodG9rZW7DuDEsICc6OicpKSA+IDEgPyAnbmFtZSBjYW5cXCd0IGNvbnRhaW4gXCI6OlwiJyA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBpc3N1ZcO4MSA/IHJlYWRlckVycm9yKHJlYWRlciwgJ0ludmFsaWQgdG9rZW4gKCcsIGlzc3Vlw7gxLCAnKTogJywgdG9rZW7DuDEpIDogIW5zw7gxICYmIGZpcnN0KG5hbWXDuDEpID09PSAnOicgPyBrZXl3b3JkKHJlc3QobmFtZcO4MSkpIDoga2V5d29yZChuc8O4MSwgbmFtZcO4MSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGRlc3VnYXJNZXRhID0gZXhwb3J0cy5kZXN1Z2FyTWV0YSA9IGZ1bmN0aW9uIGRlc3VnYXJNZXRhKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGlzS2V5d29yZChmb3JtKSA/IGRpY3Rpb25hcnkobmFtZShmb3JtKSwgdHJ1ZSkgOiBpc1N5bWJvbChmb3JtKSA/IHsgJ3RhZyc6IGZvcm0gfSA6IGlzU3RyaW5nKGZvcm0pID8geyAndGFnJzogZm9ybSB9IDogaXNEaWN0aW9uYXJ5KGZvcm0pID8gcmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhaXIpIHtcbiAgICAgICAgICAgIChyZXN1bHQgfHwgMClbbmFtZShmaXJzdChwYWlyKSldID0gc2Vjb25kKHBhaXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwge30sIGZvcm0pIDogJ2Vsc2UnID8gZm9ybSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIHdyYXBwaW5nUmVhZGVyID0gZXhwb3J0cy53cmFwcGluZ1JlYWRlciA9IGZ1bmN0aW9uIHdyYXBwaW5nUmVhZGVyKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QocHJlZml4LCByZWFkKHJlYWRlciwgdHJ1ZSwgdm9pZCAwLCB0cnVlKSk7XG4gICAgICAgIH07XG4gICAgfTtcbnZhciB0aHJvd2luZ1JlYWRlciA9IGV4cG9ydHMudGhyb3dpbmdSZWFkZXIgPSBmdW5jdGlvbiB0aHJvd2luZ1JlYWRlcihtc2cpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkZXJFcnJvcihyZWFkZXIsIG1zZyk7XG4gICAgICAgIH07XG4gICAgfTtcbnZhciByZWFkTWV0YSA9IGV4cG9ydHMucmVhZE1ldGEgPSBmdW5jdGlvbiByZWFkTWV0YShyZWFkZXIsIF8pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YcO4MSA9IGRlc3VnYXJNZXRhKHJlYWQocmVhZGVyLCB0cnVlLCB2b2lkIDAsIHRydWUpKTtcbiAgICAgICAgICAgICFpc0RpY3Rpb25hcnkobWV0YWRhdGHDuDEpID8gcmVhZGVyRXJyb3IocmVhZGVyLCAnTWV0YWRhdGEgbXVzdCBiZSBTeW1ib2wsIEtleXdvcmQsIFN0cmluZyBvciBNYXAnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm3DuDEgPSByZWFkKHJlYWRlciwgdHJ1ZSwgdm9pZCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QoZm9ybcO4MSkgPyB3aXRoTWV0YShmb3Jtw7gxLCBjb25qKG1ldGFkYXRhw7gxLCBtZXRhKGZvcm3DuDEpKSkgOiBmb3Jtw7gxO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciByZWFkUmVnZXggPSBleHBvcnRzLnJlYWRSZWdleCA9IGZ1bmN0aW9uIHJlYWRSZWdleChyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlcsO4MSA9ICcnO1xuICAgICAgICAgICAgdmFyIGNow7gxID0gcmVhZENoYXIocmVhZGVyKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZWN1ciA9IGlzTmlsKGNow7gxKSA/IHJlYWRlckVycm9yKHJlYWRlciwgJ0VPRiB3aGlsZSByZWFkaW5nIHN0cmluZycpIDogJ1xcXFwnID09PSBjaMO4MSA/IChsb29wWzBdID0gJycgKyBidWZmZXLDuDEgKyBjaMO4MSArIHJlYWRDaGFyKHJlYWRlciksIGxvb3BbMV0gPSByZWFkQ2hhcihyZWFkZXIpLCBsb29wKSA6ICdcIicgPT09IGNow7gxID8gcmVQYXR0ZXJuKGJ1ZmZlcsO4MSkgOiAnZGVmYXVsdCcgPyAobG9vcFswXSA9ICcnICsgYnVmZmVyw7gxICsgY2jDuDEsIGxvb3BbMV0gPSByZWFkQ2hhcihyZWFkZXIpLCBsb29wKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGJ1ZmZlcsO4MSA9IGxvb3BbMF0sIGNow7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciByZWFkUGFyYW0gPSBleHBvcnRzLnJlYWRQYXJhbSA9IGZ1bmN0aW9uIHJlYWRQYXJhbShyZWFkZXIsIGluaXRjaCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZvcm3DuDEgPSByZWFkU3ltYm9sKHJlYWRlciwgaW5pdGNoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKGZvcm3DuDEsIHN5bWJvbCgnJScpKSA/IHN5bWJvbCgnJTEnKSA6IGZvcm3DuDE7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGlzUGFyYW0gPSBleHBvcnRzLmlzUGFyYW0gPSBmdW5jdGlvbiBpc1BhcmFtKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGlzU3ltYm9sKGZvcm0pICYmICclJyA9PT0gZmlyc3QobmFtZShmb3JtKSk7XG4gICAgfTtcbnZhciBsYW1iZGFQYXJhbXNIYXNoID0gZXhwb3J0cy5sYW1iZGFQYXJhbXNIYXNoID0gZnVuY3Rpb24gbGFtYmRhUGFyYW1zSGFzaChmb3JtKSB7XG4gICAgICAgIHJldHVybiBpc1BhcmFtKGZvcm0pID8gZGljdGlvbmFyeShmb3JtLCBmb3JtKSA6IGlzRGljdGlvbmFyeShmb3JtKSB8fCBpc1ZlY3Rvcihmb3JtKSB8fCBpc0xpc3QoZm9ybSkgPyBjb25qLmFwcGx5KHZvaWQgMCwgbWFwKGxhbWJkYVBhcmFtc0hhc2gsIHZlYyhmb3JtKSkpIDogJ2Vsc2UnID8ge30gOiB2b2lkIDA7XG4gICAgfTtcbnZhciBsYW1iZGFQYXJhbXMgPSBleHBvcnRzLmxhbWJkYVBhcmFtcyA9IGZ1bmN0aW9uIGxhbWJkYVBhcmFtcyhib2R5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXPDuDEgPSBzb3J0KHZhbHMobGFtYmRhUGFyYW1zSGFzaChib2R5KSkpO1xuICAgICAgICAgICAgdmFyIHZhcmlhZGljw7gxID0gaXNFcXVhbChmaXJzdChuYW1lc8O4MSksIHN5bWJvbCgnJSYnKSk7XG4gICAgICAgICAgICB2YXIgbsO4MSA9IHZhcmlhZGljw7gxICYmIGNvdW50KG5hbWVzw7gxKSA9PT0gMSA/IDAgOiBwYXJzZUludChyZXN0KG5hbWUobGFzdChuYW1lc8O4MSkpKSk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zw7gxID0gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVzw7gyID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBpw7gxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBpw7gxIDw9IG7DuDEgPyAobG9vcFswXSA9IGNvbmoobmFtZXPDuDIsIHN5bWJvbCgnJyArICclJyArIGnDuDEpKSwgbG9vcFsxXSA9IGluYyhpw7gxKSwgbG9vcCkgOiBuYW1lc8O4MjtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobmFtZXPDuDIgPSBsb29wWzBdLCBpw7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhZGljw7gxID8gY29uaihwYXJhbXPDuDEsIHN5bWJvbCh2b2lkIDAsICcmJyksIHN5bWJvbCh2b2lkIDAsICclJicpKSA6IG5hbWVzw7gxO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciByZWFkTGFtYmRhID0gZXhwb3J0cy5yZWFkTGFtYmRhID0gZnVuY3Rpb24gcmVhZExhbWJkYShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5w7gxID0gcmVhZExpc3QocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0KHN5bWJvbCh2b2lkIDAsICdmbicpLCBsYW1iZGFQYXJhbXMoYm9kecO4MSksIGJvZHnDuDEpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciByZWFkRGlzY2FyZCA9IGV4cG9ydHMucmVhZERpc2NhcmQgPSBmdW5jdGlvbiByZWFkRGlzY2FyZChyZWFkZXIsIF8pIHtcbiAgICAgICAgcmVhZChyZWFkZXIsIHRydWUsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfTtcbnZhciBtYWNyb3MgPSBleHBvcnRzLm1hY3JvcyA9IGZ1bmN0aW9uIG1hY3JvcyhjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAnXCInID8gcmVhZFN0cmluZyA6IGMgPT09ICdcXFxcJyA/IHJlYWRDaGFyYWN0ZXIgOiBjID09PSAnOicgPyByZWFkS2V5d29yZCA6IGMgPT09ICc7JyA/IHJlYWRDb21tZW50IDogYyA9PT0gJ1xcJycgPyB3cmFwcGluZ1JlYWRlcihzeW1ib2wodm9pZCAwLCAncXVvdGUnKSkgOiBjID09PSAnQCcgPyB3cmFwcGluZ1JlYWRlcihzeW1ib2wodm9pZCAwLCAnZGVyZWYnKSkgOiBjID09PSAnXicgPyByZWFkTWV0YSA6IGMgPT09ICdgJyA/IHdyYXBwaW5nUmVhZGVyKHN5bWJvbCh2b2lkIDAsICdzeW50YXgtcXVvdGUnKSkgOiBjID09PSAnficgPyByZWFkVW5xdW90ZSA6IGMgPT09ICcoJyA/IHJlYWRMaXN0IDogYyA9PT0gJyknID8gcmVhZFVubWF0Y2hlZERlbGltaXRlciA6IGMgPT09ICdbJyA/IHJlYWRWZWN0b3IgOiBjID09PSAnXScgPyByZWFkVW5tYXRjaGVkRGVsaW1pdGVyIDogYyA9PT0gJ3snID8gcmVhZE1hcCA6IGMgPT09ICd9JyA/IHJlYWRVbm1hdGNoZWREZWxpbWl0ZXIgOiBjID09PSAnJScgPyByZWFkUGFyYW0gOiBjID09PSAnIycgPyByZWFkRGlzcGF0Y2ggOiAnZWxzZScgPyB2b2lkIDAgOiB2b2lkIDA7XG4gICAgfTtcbnZhciBkaXNwYXRjaE1hY3JvcyA9IGV4cG9ydHMuZGlzcGF0Y2hNYWNyb3MgPSBmdW5jdGlvbiBkaXNwYXRjaE1hY3JvcyhzKSB7XG4gICAgICAgIHJldHVybiBzID09PSAneycgPyByZWFkU2V0IDogcyA9PT0gJygnID8gcmVhZExhbWJkYSA6IHMgPT09ICc8JyA/IHRocm93aW5nUmVhZGVyKCdVbnJlYWRhYmxlIGZvcm0nKSA6IHMgPT09ICdcIicgPyByZWFkUmVnZXggOiBzID09PSAnIScgPyByZWFkQ29tbWVudCA6IHMgPT09ICdfJyA/IHJlYWREaXNjYXJkIDogJ2Vsc2UnID8gdm9pZCAwIDogdm9pZCAwO1xuICAgIH07XG52YXIgcmVhZEZvcm0gPSBleHBvcnRzLnJlYWRGb3JtID0gZnVuY3Rpb24gcmVhZEZvcm0ocmVhZGVyLCBjaCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0w7gxID0ge1xuICAgICAgICAgICAgICAgICAgICAnbGluZSc6IChyZWFkZXIgfHwgMClbJ2xpbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbic6IChyZWFkZXIgfHwgMClbJ2NvbHVtbiddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZWFkTWFjcm/DuDEgPSBtYWNyb3MoY2gpO1xuICAgICAgICAgICAgdmFyIGZvcm3DuDEgPSByZWFkTWFjcm/DuDEgPyByZWFkTWFjcm/DuDEocmVhZGVyLCBjaCkgOiBpc051bWJlckxpdGVyYWwocmVhZGVyLCBjaCkgPyByZWFkTnVtYmVyKHJlYWRlciwgY2gpIDogJ2Vsc2UnID8gcmVhZFN5bWJvbChyZWFkZXIsIGNoKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBlbmTDuDEgPSB7XG4gICAgICAgICAgICAgICAgICAgICdsaW5lJzogKHJlYWRlciB8fCAwKVsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAnY29sdW1uJzogaW5jKChyZWFkZXIgfHwgMClbJ2NvbHVtbiddKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbG9jYXRpb27DuDEgPSB7XG4gICAgICAgICAgICAgICAgICAgICd1cmknOiAocmVhZGVyIHx8IDApWyd1cmknXSxcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXJ0Jzogc3RhcnTDuDEsXG4gICAgICAgICAgICAgICAgICAgICdlbmQnOiBlbmTDuDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZvcm3DuDEgPT09IHJlYWRlciA/IGZvcm3DuDEgOiAhKGlzQm9vbGVhbihmb3Jtw7gxKSB8fCBpc05pbChmb3Jtw7gxKSB8fCBpc0tleXdvcmQoZm9ybcO4MSkpID8gd2l0aE1ldGEoZm9ybcO4MSwgY29uaihsb2NhdGlvbsO4MSwgbWV0YShmb3Jtw7gxKSkpIDogJ2Vsc2UnID8gZm9ybcO4MSA6IHZvaWQgMDtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVhZCA9IGV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIHJlYWQocmVhZGVyLCBlb2ZJc0Vycm9yLCBzZW50aW5lbCwgaXNSZWN1cnNpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2jDuDEgPSByZWFkQ2hhcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybcO4MSA9IGlzTmlsKGNow7gxKSA/IGVvZklzRXJyb3IgPyByZWFkZXJFcnJvcihyZWFkZXIsICdFT0YnKSA6IHNlbnRpbmVsIDogaXNXaGl0ZXNwYWNlKGNow7gxKSA/IHJlYWRlciA6IGlzQ29tbWVudFByZWZpeChjaMO4MSkgPyByZWFkKHJlYWRDb21tZW50KHJlYWRlciwgY2jDuDEpLCBlb2ZJc0Vycm9yLCBzZW50aW5lbCwgaXNSZWN1cnNpdmUpIDogJ2Vsc2UnID8gcmVhZEZvcm0ocmVhZGVyLCBjaMO4MSkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3Jtw7gxID09PSByZWFkZXIgPyAobG9vcCkgOiBmb3Jtw7gxO1xuICAgICAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVhZF8gPSBleHBvcnRzLnJlYWRfID0gZnVuY3Rpb24gcmVhZF8oc291cmNlLCB1cmkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWFkZXLDuDEgPSBwdXNoQmFja1JlYWRlcihzb3VyY2UsIHVyaSk7XG4gICAgICAgICAgICB2YXIgZW9mw7gxID0gZ2Vuc3ltKCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgICAgIHZhciBmb3Jtc8O4MSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmb3Jtw7gxID0gcmVhZChyZWFkZXLDuDEsIGZhbHNlLCBlb2bDuDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyID0gZm9ybcO4MSA9PT0gZW9mw7gxID8gZm9ybXPDuDEgOiAobG9vcFswXSA9IGNvbmooZm9ybXPDuDEsIGZvcm3DuDEpLCBsb29wWzFdID0gcmVhZChyZWFkZXLDuDEsIGZhbHNlLCBlb2bDuDEsIGZhbHNlKSwgbG9vcCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZm9ybXPDuDEgPSBsb29wWzBdLCBmb3Jtw7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVhZEZyb21TdHJpbmcgPSBleHBvcnRzLnJlYWRGcm9tU3RyaW5nID0gZnVuY3Rpb24gcmVhZEZyb21TdHJpbmcoc291cmNlLCB1cmkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWFkZXLDuDEgPSBwdXNoQmFja1JlYWRlcihzb3VyY2UsIHVyaSk7XG4gICAgICAgICAgICByZXR1cm4gcmVhZChyZWFkZXLDuDEsIHRydWUsIHZvaWQgMCwgZmFsc2UpO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciByZWFkVXVpZCA9IGZ1bmN0aW9uIHJlYWRVdWlkKHV1aWQpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodXVpZCkgPyBsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdVVUlELicpXS5jb25jYXQoW3V1aWRdKSkgOiByZWFkZXJFcnJvcih2b2lkIDAsICdVVUlEIGxpdGVyYWwgZXhwZWN0cyBhIHN0cmluZyBhcyBpdHMgcmVwcmVzZW50YXRpb24uJyk7XG59O1xudmFyIHJlYWRRdWV1ZSA9IGZ1bmN0aW9uIHJlYWRRdWV1ZShpdGVtcykge1xuICAgIHJldHVybiBpc1ZlY3RvcihpdGVtcykgPyBsaXN0LmFwcGx5KHZvaWQgMCwgW3N5bWJvbCh2b2lkIDAsICdQZXJzaXN0ZW50UXVldWUuJyldLmNvbmNhdChbaXRlbXNdKSkgOiByZWFkZXJFcnJvcih2b2lkIDAsICdRdWV1ZSBsaXRlcmFsIGV4cGVjdHMgYSB2ZWN0b3IgZm9yIGl0cyBlbGVtZW50cy4nKTtcbn07XG52YXIgX190YWdUYWJsZV9fID0gZXhwb3J0cy5fX3RhZ1RhYmxlX18gPSBkaWN0aW9uYXJ5KCd1dWlkJywgcmVhZFV1aWQsICdxdWV1ZScsIHJlYWRRdWV1ZSk7XG52YXIgbWF5YmVSZWFkVGFnZ2VkVHlwZSA9IGV4cG9ydHMubWF5YmVSZWFkVGFnZ2VkVHlwZSA9IGZ1bmN0aW9uIG1heWJlUmVhZFRhZ2dlZFR5cGUocmVhZGVyLCBpbml0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YWfDuDEgPSByZWFkU3ltYm9sKHJlYWRlciwgaW5pdGNoKTtcbiAgICAgICAgICAgIHZhciBwZm7DuDEgPSAoX190YWdUYWJsZV9fIHx8IDApW25hbWUodGFnw7gxKV07XG4gICAgICAgICAgICByZXR1cm4gcGZuw7gxID8gcGZuw7gxKHJlYWQocmVhZGVyLCB0cnVlLCB2b2lkIDAsIGZhbHNlKSkgOiByZWFkZXJFcnJvcihyZWFkZXIsICcnICsgJ0NvdWxkIG5vdCBmaW5kIHRhZyBwYXJzZXIgZm9yICcgKyBuYW1lKHRhZ8O4MSkgKyAnIGluICcgKyAoJycgKyBrZXlzKF9fdGFnVGFibGVfXykpKTtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07Iiwie1xuICAgIHZhciBfbnNfID0ge1xuICAgICAgICAgICAgaWQ6ICd3aXNwLnJ1bnRpbWUnLFxuICAgICAgICAgICAgZG9jOiAnQ29yZSBwcmltaXRpdmVzIHJlcXVpcmVkIGZvciBydW50aW1lJ1xuICAgICAgICB9O1xufVxudmFyIGlkZW50aXR5ID0gZXhwb3J0cy5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbnZhciBpc09kZCA9IGV4cG9ydHMuaXNPZGQgPSBmdW5jdGlvbiBpc09kZChuKSB7XG4gICAgICAgIHJldHVybiBuICUgMiA9PT0gMTtcbiAgICB9O1xudmFyIGlzRXZlbiA9IGV4cG9ydHMuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gJSAyID09PSAwO1xuICAgIH07XG52YXIgaXNEaWN0aW9uYXJ5ID0gZXhwb3J0cy5pc0RpY3Rpb25hcnkgPSBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoZm9ybSkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoZm9ybSkgJiYgaXNPYmplY3QoT2JqZWN0LmdldFByb3RvdHlwZU9mKGZvcm0pKSAmJiBpc05pbChPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKGZvcm0pKSk7XG4gICAgfTtcbnZhciBkaWN0aW9uYXJ5ID0gZXhwb3J0cy5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24gZGljdGlvbmFyeSgpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlc8O4MSA9IHBhaXJzO1xuICAgICAgICAgICAgdmFyIHJlc3VsdMO4MSA9IHt9O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0ga2V5VmFsdWVzw7gxLmxlbmd0aCA/IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdMO4MVtrZXlWYWx1ZXPDuDFbMF1dID0ga2V5VmFsdWVzw7gxWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vcFswXSA9IGtleVZhbHVlc8O4MS5zbGljZSgyKSwgbG9vcFsxXSA9IHJlc3VsdMO4MSwgbG9vcDtcbiAgICAgICAgICAgICAgICB9KSgpIDogcmVzdWx0w7gxO1xuICAgICAgICAgICAgfSB3aGlsZSAoa2V5VmFsdWVzw7gxID0gbG9vcFswXSwgcmVzdWx0w7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBrZXlzID0gZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ga2V5cyhkaWN0aW9uYXJ5KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhkaWN0aW9uYXJ5KTtcbiAgICB9O1xudmFyIHZhbHMgPSBleHBvcnRzLnZhbHMgPSBmdW5jdGlvbiB2YWxzKGRpY3Rpb25hcnkpIHtcbiAgICAgICAgcmV0dXJuIGtleXMoZGljdGlvbmFyeSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZGljdGlvbmFyeSB8fCAwKVtrZXldO1xuICAgICAgICB9KTtcbiAgICB9O1xudmFyIGtleVZhbHVlcyA9IGV4cG9ydHMua2V5VmFsdWVzID0gZnVuY3Rpb24ga2V5VmFsdWVzKGRpY3Rpb25hcnkpIHtcbiAgICAgICAgcmV0dXJuIGtleXMoZGljdGlvbmFyeSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIChkaWN0aW9uYXJ5IHx8IDApW2tleV1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH07XG52YXIgbWVyZ2UgPSBleHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICBpc09iamVjdChkaWN0aW9uYXJ5KSA/IE9iamVjdC5rZXlzKGRpY3Rpb25hcnkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZGVzY3JpcHRvciB8fCAwKVtrZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkaWN0aW9uYXJ5LCBrZXkpO1xuICAgICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlKSkpO1xuICAgIH07XG52YXIgaXNDb250YWluc1ZlY3RvciA9IGV4cG9ydHMuaXNDb250YWluc1ZlY3RvciA9IGZ1bmN0aW9uIGlzQ29udGFpbnNWZWN0b3IodmVjdG9yLCBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB2ZWN0b3IuaW5kZXhPZihlbGVtZW50KSA+PSAwO1xuICAgIH07XG52YXIgbWFwRGljdGlvbmFyeSA9IGV4cG9ydHMubWFwRGljdGlvbmFyeSA9IGZ1bmN0aW9uIG1hcERpY3Rpb25hcnkoc291cmNlLCBmKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICh0YXJnZXQgfHwgMClba2V5XSA9IGYoKHNvdXJjZSB8fCAwKVtrZXldKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xudmFyIHRvU3RyaW5nID0gZXhwb3J0cy50b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGbiA9IGV4cG9ydHMuaXNGbiA9IHR5cGVvZigvLi8pID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfSA6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YoeCkgPT09ICdmdW5jdGlvbic7XG4gICAgfTtcbnZhciBpc0Vycm9yID0gZXhwb3J0cy5pc0Vycm9yID0gZnVuY3Rpb24gaXNFcnJvcih4KSB7XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgRXJyb3IgfHwgdG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbiAgICB9O1xudmFyIGlzU3RyaW5nID0gZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih4KSA9PT0gJ3N0cmluZycgfHwgdG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfTtcbnZhciBpc051bWJlciA9IGV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiBpc051bWJlcih4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YoeCkgPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xuICAgIH07XG52YXIgaXNWZWN0b3IgPSBleHBvcnRzLmlzVmVjdG9yID0gaXNGbihBcnJheS5pc0FycmF5KSA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xudmFyIGlzRGF0ZSA9IGV4cG9ydHMuaXNEYXRlID0gZnVuY3Rpb24gaXNEYXRlKHgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9O1xudmFyIGlzQm9vbGVhbiA9IGV4cG9ydHMuaXNCb29sZWFuID0gZnVuY3Rpb24gaXNCb29sZWFuKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHRydWUgfHwgeCA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICAgIH07XG52YXIgaXNSZVBhdHRlcm4gPSBleHBvcnRzLmlzUmVQYXR0ZXJuID0gZnVuY3Rpb24gaXNSZVBhdHRlcm4oeCkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG4gICAgfTtcbnZhciBpc09iamVjdCA9IGV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiB4ICYmIHR5cGVvZih4KSA9PT0gJ29iamVjdCc7XG4gICAgfTtcbnZhciBpc05pbCA9IGV4cG9ydHMuaXNOaWwgPSBmdW5jdGlvbiBpc05pbCh4KSB7XG4gICAgICAgIHJldHVybiB4ID09PSB2b2lkIDAgfHwgeCA9PT0gbnVsbDtcbiAgICB9O1xudmFyIGlzVHJ1ZSA9IGV4cG9ydHMuaXNUcnVlID0gZnVuY3Rpb24gaXNUcnVlKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHRydWU7XG4gICAgfTtcbnZhciBpc0ZhbHNlID0gZXhwb3J0cy5pc0ZhbHNlID0gZnVuY3Rpb24gaXNGYWxzZSh4KSB7XG4gICAgICAgIHJldHVybiB4ID09PSB0cnVlO1xuICAgIH07XG52YXIgcmVGaW5kID0gZXhwb3J0cy5yZUZpbmQgPSBmdW5jdGlvbiByZUZpbmQocmUsIHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzw7gxID0gcmUuZXhlYyhzKTtcbiAgICAgICAgICAgIHJldHVybiAhaXNOaWwobWF0Y2hlc8O4MSkgPyBtYXRjaGVzw7gxLmxlbmd0aCA9PT0gMSA/IChtYXRjaGVzw7gxIHx8IDApWzBdIDogbWF0Y2hlc8O4MSA6IHZvaWQgMDtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVNYXRjaGVzID0gZXhwb3J0cy5yZU1hdGNoZXMgPSBmdW5jdGlvbiByZU1hdGNoZXMocGF0dGVybiwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlc8O4MSA9IHBhdHRlcm4uZXhlYyhzb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuICFpc05pbChtYXRjaGVzw7gxKSAmJiAobWF0Y2hlc8O4MSB8fCAwKVswXSA9PT0gc291cmNlID8gbWF0Y2hlc8O4MS5sZW5ndGggPT09IDEgPyAobWF0Y2hlc8O4MSB8fCAwKVswXSA6IG1hdGNoZXPDuDEgOiB2b2lkIDA7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlUGF0dGVybiA9IGV4cG9ydHMucmVQYXR0ZXJuID0gZnVuY3Rpb24gcmVQYXR0ZXJuKHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaMO4MSA9IHJlRmluZCgvXig/OlxcKFxcPyhbaWRtc3V4XSopXFwpKT8oLiopLywgcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgobWF0Y2jDuDEgfHwgMClbMl0sIChtYXRjaMO4MSB8fCAwKVsxXSk7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIGluYyA9IGV4cG9ydHMuaW5jID0gZnVuY3Rpb24gaW5jKHgpIHtcbiAgICAgICAgcmV0dXJuIHggKyAxO1xuICAgIH07XG52YXIgZGVjID0gZXhwb3J0cy5kZWMgPSBmdW5jdGlvbiBkZWMoeCkge1xuICAgICAgICByZXR1cm4geCAtIDE7XG4gICAgfTtcbnZhciBzdHIgPSBleHBvcnRzLnN0ciA9IGZ1bmN0aW9uIHN0cigpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuY29uY2F0LmFwcGx5KCcnLCBhcmd1bWVudHMpO1xuICAgIH07XG52YXIgY2hhciA9IGV4cG9ydHMuY2hhciA9IGZ1bmN0aW9uIGNoYXIoY29kZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9O1xudmFyIGludCA9IGV4cG9ydHMuaW50ID0gZnVuY3Rpb24gaW50KHgpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHgpID8geCA+PSAwID8gTWF0aC5mbG9vcih4KSA6IE1hdGguZmxvb3IoeCkgOiB4LmNoYXJDb2RlQXQoMCk7XG4gICAgfTtcbnZhciBzdWJzID0gZXhwb3J0cy5zdWJzID0gZnVuY3Rpb24gc3VicyhzdHJpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgfTtcbnZhciBpc1BhdHRlcm5FcXVhbCA9IGZ1bmN0aW9uIGlzUGF0dGVybkVxdWFsKHgsIHkpIHtcbiAgICByZXR1cm4gaXNSZVBhdHRlcm4oeCkgJiYgaXNSZVBhdHRlcm4oeSkgJiYgeC5zb3VyY2UgPT09IHkuc291cmNlICYmIHguZ2xvYmFsID09PSB5Lmdsb2JhbCAmJiB4Lm11bHRpbGluZSA9PT0geS5tdWx0aWxpbmUgJiYgeC5pZ25vcmVDYXNlID09PSB5Lmlnbm9yZUNhc2U7XG59O1xudmFyIGlzRGF0ZUVxdWFsID0gZnVuY3Rpb24gaXNEYXRlRXF1YWwoeCwgeSkge1xuICAgIHJldHVybiBpc0RhdGUoeCkgJiYgaXNEYXRlKHkpICYmIE51bWJlcih4KSA9PT0gTnVtYmVyKHkpO1xufTtcbnZhciBpc0RpY3Rpb25hcnlFcXVhbCA9IGZ1bmN0aW9uIGlzRGljdGlvbmFyeUVxdWFsKHgsIHkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgaXNPYmplY3QoeSkgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeEtleXPDuDEgPSBrZXlzKHgpO1xuICAgICAgICB2YXIgeUtleXPDuDEgPSBrZXlzKHkpO1xuICAgICAgICB2YXIgeENvdW50w7gxID0geEtleXPDuDEubGVuZ3RoO1xuICAgICAgICB2YXIgeUNvdW50w7gxID0geUtleXPDuDEubGVuZ3RoO1xuICAgICAgICByZXR1cm4geENvdW50w7gxID09PSB5Q291bnTDuDEgJiYgZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgdmFyIGNvdW50w7gxID0geENvdW50w7gxO1xuICAgICAgICAgICAgdmFyIGtleXPDuDEgPSB4S2V5c8O4MTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZWN1ciA9IGluZGV4w7gxIDwgY291bnTDuDEgPyBpc0VxdWl2YWxlbnQoKHggfHwgMClbKGtleXPDuDEgfHwgMClbaW5kZXjDuDFdXSwgKHkgfHwgMClbKGtleXPDuDEgfHwgMClbaW5kZXjDuDFdXSkgPyAobG9vcFswXSA9IGluYyhpbmRleMO4MSksIGxvb3BbMV0gPSBjb3VudMO4MSwgbG9vcFsyXSA9IGtleXPDuDEsIGxvb3ApIDogZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgfSB3aGlsZSAoaW5kZXjDuDEgPSBsb29wWzBdLCBjb3VudMO4MSA9IGxvb3BbMV0sIGtleXPDuDEgPSBsb29wWzJdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9LmNhbGwodGhpcyk7XG59O1xudmFyIGlzVmVjdG9yRXF1YWwgPSBmdW5jdGlvbiBpc1ZlY3RvckVxdWFsKHgsIHkpIHtcbiAgICByZXR1cm4gaXNWZWN0b3IoeCkgJiYgaXNWZWN0b3IoeSkgJiYgeC5sZW5ndGggPT09IHkubGVuZ3RoICYmIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgIHZhciB4c8O4MSA9IHg7XG4gICAgICAgIHZhciB5c8O4MSA9IHk7XG4gICAgICAgIHZhciBpbmRleMO4MSA9IDA7XG4gICAgICAgIHZhciBjb3VudMO4MSA9IHgubGVuZ3RoO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZWN1ciA9IGluZGV4w7gxIDwgY291bnTDuDEgPyBpc0VxdWl2YWxlbnQoKHhzw7gxIHx8IDApW2luZGV4w7gxXSwgKHlzw7gxIHx8IDApW2luZGV4w7gxXSkgPyAobG9vcFswXSA9IHhzw7gxLCBsb29wWzFdID0geXPDuDEsIGxvb3BbMl0gPSBpbmMoaW5kZXjDuDEpLCBsb29wWzNdID0gY291bnTDuDEsIGxvb3ApIDogZmFsc2UgOiB0cnVlO1xuICAgICAgICB9IHdoaWxlICh4c8O4MSA9IGxvb3BbMF0sIHlzw7gxID0gbG9vcFsxXSwgaW5kZXjDuDEgPSBsb29wWzJdLCBjb3VudMO4MSA9IGxvb3BbM10sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgIH0uY2FsbCh0aGlzKTtcbn07XG52YXIgaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gaXNFcXVpdmFsZW50KCkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgMjpcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICByZXR1cm4geCA9PT0geSB8fCAoaXNOaWwoeCkgPyBpc05pbCh5KSA6IGlzTmlsKHkpID8gaXNOaWwoeCkgOiBpc1N0cmluZyh4KSA/IGlzU3RyaW5nKHkpICYmIHgudG9TdHJpbmcoKSA9PT0geS50b1N0cmluZygpIDogaXNOdW1iZXIoeCkgPyBpc051bWJlcih5KSAmJiB4LnZhbHVlT2YoKSA9PT0geS52YWx1ZU9mKCkgOiBpc0ZuKHgpID8gZmFsc2UgOiBpc0Jvb2xlYW4oeCkgPyBmYWxzZSA6IGlzRGF0ZSh4KSA/IGlzRGF0ZUVxdWFsKHgsIHkpIDogaXNWZWN0b3IoeCkgPyBpc1ZlY3RvckVxdWFsKHgsIHksIFtdLCBbXSkgOiBpc1JlUGF0dGVybih4KSA/IGlzUGF0dGVybkVxdWFsKHgsIHkpIDogJ2Vsc2UnID8gaXNEaWN0aW9uYXJ5RXF1YWwoeCwgeSkgOiB2b2lkIDApO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXPDuDEgPSB4O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnTDuDEgPSB5O1xuICAgICAgICAgICAgdmFyIGluZGV4w7gxID0gMDtcbiAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlY3VyID0gaXNFcXVpdmFsZW50KHByZXZpb3Vzw7gxLCBjdXJyZW50w7gxKSAmJiAoaW5kZXjDuDEgPCBjb3VudMO4MSA/IChsb29wWzBdID0gY3VycmVudMO4MSwgbG9vcFsxXSA9IChtb3JlIHx8IDApW2luZGV4w7gxXSwgbG9vcFsyXSA9IGluYyhpbmRleMO4MSksIGxvb3BbM10gPSBjb3VudMO4MSwgbG9vcCkgOiB0cnVlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHByZXZpb3Vzw7gxID0gbG9vcFswXSwgY3VycmVudMO4MSA9IGxvb3BbMV0sIGluZGV4w7gxID0gbG9vcFsyXSwgY291bnTDuDEgPSBsb29wWzNdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9XG59O1xudmFyIGlzRXF1YWwgPSBleHBvcnRzLmlzRXF1YWwgPSBpc0VxdWl2YWxlbnQ7XG52YXIgaXNTdHJpY3RFcXVhbCA9IGV4cG9ydHMuaXNTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGlzU3RyaWN0RXF1YWwoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXPDuDEgPSB4O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50w7gxID0geTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBwcmV2aW91c8O4MSA9PSBjdXJyZW50w7gxICYmIChpbmRleMO4MSA8IGNvdW50w7gxID8gKGxvb3BbMF0gPSBjdXJyZW50w7gxLCBsb29wWzFdID0gKG1vcmUgfHwgMClbaW5kZXjDuDFdLCBsb29wWzJdID0gaW5jKGluZGV4w7gxKSwgbG9vcFszXSA9IGNvdW50w7gxLCBsb29wKSA6IHRydWUpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZpb3Vzw7gxID0gbG9vcFswXSwgY3VycmVudMO4MSA9IGxvb3BbMV0sIGluZGV4w7gxID0gbG9vcFsyXSwgY291bnTDuDEgPSBsb29wWzNdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbnZhciBncmVhdGVyVGhhbiA9IGV4cG9ydHMuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbigpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4geCA+IHk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXPDuDEgPSB4O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50w7gxID0geTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBwcmV2aW91c8O4MSA+IGN1cnJlbnTDuDEgJiYgKGluZGV4w7gxIDwgY291bnTDuDEgPyAobG9vcFswXSA9IGN1cnJlbnTDuDEsIGxvb3BbMV0gPSAobW9yZSB8fCAwKVtpbmRleMO4MV0sIGxvb3BbMl0gPSBpbmMoaW5kZXjDuDEpLCBsb29wWzNdID0gY291bnTDuDEsIGxvb3ApIDogdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldmlvdXPDuDEgPSBsb29wWzBdLCBjdXJyZW50w7gxID0gbG9vcFsxXSwgaW5kZXjDuDEgPSBsb29wWzJdLCBjb3VudMO4MSA9IGxvb3BbM10sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xudmFyIG5vdExlc3NUaGFuID0gZXhwb3J0cy5ub3RMZXNzVGhhbiA9IGZ1bmN0aW9uIG5vdExlc3NUaGFuKCkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJldHVybiB4ID49IHk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXPDuDEgPSB4O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50w7gxID0geTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBwcmV2aW91c8O4MSA+PSBjdXJyZW50w7gxICYmIChpbmRleMO4MSA8IGNvdW50w7gxID8gKGxvb3BbMF0gPSBjdXJyZW50w7gxLCBsb29wWzFdID0gKG1vcmUgfHwgMClbaW5kZXjDuDFdLCBsb29wWzJdID0gaW5jKGluZGV4w7gxKSwgbG9vcFszXSA9IGNvdW50w7gxLCBsb29wKSA6IHRydWUpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZpb3Vzw7gxID0gbG9vcFswXSwgY3VycmVudMO4MSA9IGxvb3BbMV0sIGluZGV4w7gxID0gbG9vcFsyXSwgY291bnTDuDEgPSBsb29wWzNdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbnZhciBsZXNzVGhhbiA9IGV4cG9ydHMubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbigpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4geCA8IHk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXPDuDEgPSB4O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50w7gxID0geTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBwcmV2aW91c8O4MSA8IGN1cnJlbnTDuDEgJiYgKGluZGV4w7gxIDwgY291bnTDuDEgPyAobG9vcFswXSA9IGN1cnJlbnTDuDEsIGxvb3BbMV0gPSAobW9yZSB8fCAwKVtpbmRleMO4MV0sIGxvb3BbMl0gPSBpbmMoaW5kZXjDuDEpLCBsb29wWzNdID0gY291bnTDuDEsIGxvb3ApIDogdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldmlvdXPDuDEgPSBsb29wWzBdLCBjdXJyZW50w7gxID0gbG9vcFsxXSwgaW5kZXjDuDEgPSBsb29wWzJdLCBjb3VudMO4MSA9IGxvb3BbM10sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xudmFyIG5vdEdyZWF0ZXJUaGFuID0gZXhwb3J0cy5ub3RHcmVhdGVyVGhhbiA9IGZ1bmN0aW9uIG5vdEdyZWF0ZXJUaGFuKCkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJldHVybiB4IDw9IHk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXPDuDEgPSB4O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50w7gxID0geTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBwcmV2aW91c8O4MSA8PSBjdXJyZW50w7gxICYmIChpbmRleMO4MSA8IGNvdW50w7gxID8gKGxvb3BbMF0gPSBjdXJyZW50w7gxLCBsb29wWzFdID0gKG1vcmUgfHwgMClbaW5kZXjDuDFdLCBsb29wWzJdID0gaW5jKGluZGV4w7gxKSwgbG9vcFszXSA9IGNvdW50w7gxLCBsb29wKSA6IHRydWUpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZpb3Vzw7gxID0gbG9vcFswXSwgY3VycmVudMO4MSA9IGxvb3BbMV0sIGluZGV4w7gxID0gbG9vcFsyXSwgY291bnTDuDEgPSBsb29wWzNdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbnZhciBzdW0gPSBleHBvcnRzLnN1bSA9IGZ1bmN0aW9uIHN1bSgpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHJldHVybiBhICsgYiArIGMgKyBkO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBiICsgYyArIGQgKyBlO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgdmFyIGYgPSBhcmd1bWVudHNbNV07XG4gICAgICAgICAgICByZXR1cm4gYSArIGIgKyBjICsgZCArIGUgKyBmO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIHZhciBmID0gYXJndW1lbnRzWzVdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDYpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWXDuDEgPSBhICsgYiArIGMgKyBkICsgZSArIGY7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4w7gxID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY291bnTDuDEgPSBtb3JlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyID0gaW5kZXjDuDEgPCBjb3VudMO4MSA/IChsb29wWzBdID0gdmFsdWXDuDEgKyAobW9yZSB8fCAwKVtpbmRleMO4MV0sIGxvb3BbMV0gPSBpbmMoaW5kZXjDuDEpLCBsb29wWzJdID0gY291bnTDuDEsIGxvb3ApIDogdmFsdWXDuDE7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodmFsdWXDuDEgPSBsb29wWzBdLCBpbmRleMO4MSA9IGxvb3BbMV0sIGNvdW50w7gxID0gbG9vcFsyXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG52YXIgc3VidHJhY3QgPSBleHBvcnRzLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmdzIHBhc3NlZCB0bzogLScpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gMCAtIGE7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYiAtIGM7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiIC0gYyAtIGQ7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHNbNF07XG4gICAgICAgICAgICByZXR1cm4gYSAtIGIgLSBjIC0gZCAtIGU7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHNbNF07XG4gICAgICAgICAgICB2YXIgZiA9IGFyZ3VtZW50c1s1XTtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYiAtIGMgLSBkIC0gZSAtIGY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgdmFyIGYgPSBhcmd1bWVudHNbNV07XG4gICAgICAgICAgICB2YXIgbW9yZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgNik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZcO4MSA9IGEgLSBiIC0gYyAtIGQgLSBlIC0gZjtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBpbmRleMO4MSA8IGNvdW50w7gxID8gKGxvb3BbMF0gPSB2YWx1ZcO4MSAtIChtb3JlIHx8IDApW2luZGV4w7gxXSwgbG9vcFsxXSA9IGluYyhpbmRleMO4MSksIGxvb3BbMl0gPSBjb3VudMO4MSwgbG9vcCkgOiB2YWx1ZcO4MTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh2YWx1ZcO4MSA9IGxvb3BbMF0sIGluZGV4w7gxID0gbG9vcFsxXSwgY291bnTDuDEgPSBsb29wWzJdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbnZhciBkaXZpZGUgPSBleHBvcnRzLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZSgpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3MgcGFzc2VkIHRvOiAvJyk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiAxIC8gYTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJldHVybiBhIC8gYjtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgcmV0dXJuIGEgLyBiIC8gYztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICByZXR1cm4gYSAvIGIgLyBjIC8gZDtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIHJldHVybiBhIC8gYiAvIGMgLyBkIC8gZTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIHZhciBmID0gYXJndW1lbnRzWzVdO1xuICAgICAgICAgICAgcmV0dXJuIGEgLyBiIC8gYyAvIGQgLyBlIC8gZjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHNbNF07XG4gICAgICAgICAgICB2YXIgZiA9IGFyZ3VtZW50c1s1XTtcbiAgICAgICAgICAgIHZhciBtb3JlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCA2KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlw7gxID0gYSAvIGIgLyBjIC8gZCAvIGUgLyBmO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleMO4MSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50w7gxID0gbW9yZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICByZWN1ciA9IGluZGV4w7gxIDwgY291bnTDuDEgPyAobG9vcFswXSA9IHZhbHVlw7gxIC8gKG1vcmUgfHwgMClbaW5kZXjDuDFdLCBsb29wWzFdID0gaW5jKGluZGV4w7gxKSwgbG9vcFsyXSA9IGNvdW50w7gxLCBsb29wKSA6IHZhbHVlw7gxO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHZhbHVlw7gxID0gbG9vcFswXSwgaW5kZXjDuDEgPSBsb29wWzFdLCBjb3VudMO4MSA9IGxvb3BbMl0sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xudmFyIG11bHRpcGx5ID0gZXhwb3J0cy5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KCkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHJldHVybiBhICogYiAqIGM7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgcmV0dXJuIGEgKiBiICogYyAqIGQ7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHNbNF07XG4gICAgICAgICAgICByZXR1cm4gYSAqIGIgKiBjICogZCAqIGU7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHZhciBkID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHNbNF07XG4gICAgICAgICAgICB2YXIgZiA9IGFyZ3VtZW50c1s1XTtcbiAgICAgICAgICAgIHJldHVybiBhICogYiAqIGMgKiBkICogZSAqIGY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgdmFyIGYgPSBhcmd1bWVudHNbNV07XG4gICAgICAgICAgICB2YXIgbW9yZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgNik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZcO4MSA9IGEgKiBiICogYyAqIGQgKiBlICogZjtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBpbmRleMO4MSA8IGNvdW50w7gxID8gKGxvb3BbMF0gPSB2YWx1ZcO4MSAqIChtb3JlIHx8IDApW2luZGV4w7gxXSwgbG9vcFsxXSA9IGluYyhpbmRleMO4MSksIGxvb3BbMl0gPSBjb3VudMO4MSwgbG9vcCkgOiB2YWx1ZcO4MTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh2YWx1ZcO4MSA9IGxvb3BbMF0sIGluZGV4w7gxID0gbG9vcFsxXSwgY291bnTDuDEgPSBsb29wWzJdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbnZhciBhbmQgPSBleHBvcnRzLmFuZCA9IGZ1bmN0aW9uIGFuZCgpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGEgJiYgYjtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgcmV0dXJuIGEgJiYgYiAmJiBjO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHJldHVybiBhICYmIGIgJiYgYyAmJiBkO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgcmV0dXJuIGEgJiYgYiAmJiBjICYmIGQgJiYgZTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIHZhciBmID0gYXJndW1lbnRzWzVdO1xuICAgICAgICAgICAgcmV0dXJuIGEgJiYgYiAmJiBjICYmIGQgJiYgZSAmJiBmO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIHZhciBmID0gYXJndW1lbnRzWzVdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDYpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWXDuDEgPSBhICYmIGIgJiYgYyAmJiBkICYmIGUgJiYgZjtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBpbmRleMO4MSA8IGNvdW50w7gxID8gKGxvb3BbMF0gPSB2YWx1ZcO4MSAmJiAobW9yZSB8fCAwKVtpbmRleMO4MV0sIGxvb3BbMV0gPSBpbmMoaW5kZXjDuDEpLCBsb29wWzJdID0gY291bnTDuDEsIGxvb3ApIDogdmFsdWXDuDE7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodmFsdWXDuDEgPSBsb29wWzBdLCBpbmRleMO4MSA9IGxvb3BbMV0sIGNvdW50w7gxID0gbG9vcFsyXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG52YXIgb3IgPSBleHBvcnRzLm9yID0gZnVuY3Rpb24gb3IoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGEgfHwgYjtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgcmV0dXJuIGEgfHwgYiB8fCBjO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHJldHVybiBhIHx8IGIgfHwgYyB8fCBkO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgcmV0dXJuIGEgfHwgYiB8fCBjIHx8IGQgfHwgZTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIHZhciBmID0gYXJndW1lbnRzWzVdO1xuICAgICAgICAgICAgcmV0dXJuIGEgfHwgYiB8fCBjIHx8IGQgfHwgZSB8fCBmO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGQgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIHZhciBmID0gYXJndW1lbnRzWzVdO1xuICAgICAgICAgICAgdmFyIG1vcmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDYpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWXDuDEgPSBhIHx8IGIgfHwgYyB8fCBkIHx8IGUgfHwgZjtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXjDuDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudMO4MSA9IG1vcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXIgPSBpbmRleMO4MSA8IGNvdW50w7gxID8gKGxvb3BbMF0gPSB2YWx1ZcO4MSB8fCAobW9yZSB8fCAwKVtpbmRleMO4MV0sIGxvb3BbMV0gPSBpbmMoaW5kZXjDuDEpLCBsb29wWzJdID0gY291bnTDuDEsIGxvb3ApIDogdmFsdWXDuDE7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodmFsdWXDuDEgPSBsb29wWzBdLCBpbmRleMO4MSA9IGxvb3BbMV0sIGNvdW50w7gxID0gbG9vcFsyXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG52YXIgcHJpbnQgPSBleHBvcnRzLnByaW50ID0gZnVuY3Rpb24gcHJpbnQoKSB7XG4gICAgICAgIHZhciBtb3JlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KHZvaWQgMCwgbW9yZSk7XG4gICAgfTtcbnZhciBtYXggPSBleHBvcnRzLm1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IGV4cG9ydHMubWluID0gTWF0aC5taW47Iiwie1xuICAgIHZhciBfbnNfID0ge1xuICAgICAgICAgICAgaWQ6ICd3aXNwLnNlcXVlbmNlJyxcbiAgICAgICAgICAgIGRvYzogdm9pZCAwXG4gICAgICAgIH07XG4gICAgdmFyIHdpc3BfcnVudGltZSA9IHJlcXVpcmUoJy4vcnVudGltZScpO1xuICAgIHZhciBpc05pbCA9IHdpc3BfcnVudGltZS5pc05pbDtcbiAgICB2YXIgaXNWZWN0b3IgPSB3aXNwX3J1bnRpbWUuaXNWZWN0b3I7XG4gICAgdmFyIGlzRm4gPSB3aXNwX3J1bnRpbWUuaXNGbjtcbiAgICB2YXIgaXNOdW1iZXIgPSB3aXNwX3J1bnRpbWUuaXNOdW1iZXI7XG4gICAgdmFyIGlzU3RyaW5nID0gd2lzcF9ydW50aW1lLmlzU3RyaW5nO1xuICAgIHZhciBpc0RpY3Rpb25hcnkgPSB3aXNwX3J1bnRpbWUuaXNEaWN0aW9uYXJ5O1xuICAgIHZhciBrZXlWYWx1ZXMgPSB3aXNwX3J1bnRpbWUua2V5VmFsdWVzO1xuICAgIHZhciBzdHIgPSB3aXNwX3J1bnRpbWUuc3RyO1xuICAgIHZhciBkZWMgPSB3aXNwX3J1bnRpbWUuZGVjO1xuICAgIHZhciBpbmMgPSB3aXNwX3J1bnRpbWUuaW5jO1xuICAgIHZhciBtZXJnZSA9IHdpc3BfcnVudGltZS5tZXJnZTtcbiAgICB2YXIgZGljdGlvbmFyeSA9IHdpc3BfcnVudGltZS5kaWN0aW9uYXJ5O1xufVxudmFyIExpc3QgPSBmdW5jdGlvbiBMaXN0KGhlYWQsIHRhaWwpIHtcbiAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgIHRoaXMudGFpbCA9IHRhaWwgfHwgbGlzdCgpO1xuICAgIHRoaXMubGVuZ3RoID0gaW5jKGNvdW50KHRoaXMudGFpbCkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcbkxpc3QucHJvdG90eXBlLmxlbmd0aCA9IDA7XG5MaXN0LnR5cGUgPSAnd2lzcC5saXN0Jztcbkxpc3QucHJvdG90eXBlLnR5cGUgPSBMaXN0LnR5cGU7XG5MaXN0LnByb3RvdHlwZS50YWlsID0gT2JqZWN0LmNyZWF0ZShMaXN0LnByb3RvdHlwZSk7XG5MaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgdmFyIHJlc3VsdMO4MSA9ICcnO1xuICAgICAgICB2YXIgbGlzdMO4MSA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlY3VyID0gaXNFbXB0eShsaXN0w7gxKSA/ICcnICsgJygnICsgcmVzdWx0w7gxLnN1YnN0cigxKSArICcpJyA6IChsb29wWzBdID0gJycgKyByZXN1bHTDuDEgKyAnICcgKyAoaXNWZWN0b3IoZmlyc3QobGlzdMO4MSkpID8gJycgKyAnWycgKyBmaXJzdChsaXN0w7gxKS5qb2luKCcgJykgKyAnXScgOiBpc05pbChmaXJzdChsaXN0w7gxKSkgPyAnbmlsJyA6IGlzU3RyaW5nKGZpcnN0KGxpc3TDuDEpKSA/IEpTT04uc3RyaW5naWZ5KGZpcnN0KGxpc3TDuDEpKSA6IGlzTnVtYmVyKGZpcnN0KGxpc3TDuDEpKSA/IEpTT04uc3RyaW5naWZ5KGZpcnN0KGxpc3TDuDEpKSA6IGZpcnN0KGxpc3TDuDEpKSwgbG9vcFsxXSA9IHJlc3QobGlzdMO4MSksIGxvb3ApO1xuICAgICAgICB9IHdoaWxlIChyZXN1bHTDuDEgPSBsb29wWzBdLCBsaXN0w7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBsYXp5U2VxVmFsdWUgPSBmdW5jdGlvbiBsYXp5U2VxVmFsdWUobGF6eVNlcSkge1xuICAgIHJldHVybiAhbGF6eVNlcS5yZWFsaXplZCA/IChsYXp5U2VxLnJlYWxpemVkID0gdHJ1ZSkgJiYgKGxhenlTZXEueCA9IGxhenlTZXEueCgpKSA6IGxhenlTZXEueDtcbn07XG52YXIgTGF6eVNlcSA9IGZ1bmN0aW9uIExhenlTZXEocmVhbGl6ZWQsIHgpIHtcbiAgICB0aGlzLnJlYWxpemVkID0gcmVhbGl6ZWQgfHwgZmFsc2U7XG4gICAgdGhpcy54ID0geDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5MYXp5U2VxLnR5cGUgPSAnd2lzcC5sYXp5LnNlcSc7XG5MYXp5U2VxLnByb3RvdHlwZS50eXBlID0gTGF6eVNlcS50eXBlO1xudmFyIGxhenlTZXEgPSBleHBvcnRzLmxhenlTZXEgPSBmdW5jdGlvbiBsYXp5U2VxKHJlYWxpemVkLCBib2R5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVNlcShyZWFsaXplZCwgYm9keSk7XG4gICAgfTtcbnZhciBpc0xhenlTZXEgPSBleHBvcnRzLmlzTGF6eVNlcSA9IGZ1bmN0aW9uIGlzTGF6eVNlcSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgTGF6eVNlcS50eXBlID09PSB2YWx1ZS50eXBlO1xuICAgIH07XG52b2lkIDA7XG52YXIgaXNMaXN0ID0gZXhwb3J0cy5pc0xpc3QgPSBmdW5jdGlvbiBpc0xpc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIExpc3QudHlwZSA9PT0gdmFsdWUudHlwZTtcbiAgICB9O1xudmFyIGxpc3QgPSBleHBvcnRzLmxpc3QgPSBmdW5jdGlvbiBsaXN0KCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IE9iamVjdC5jcmVhdGUoTGlzdC5wcm90b3R5cGUpIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5yZWR1Y2VSaWdodChmdW5jdGlvbiAodGFpbCwgaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnMoaGVhZCwgdGFpbCk7XG4gICAgICAgIH0sIGxpc3QoKSk7XG4gICAgfTtcbnZhciBjb25zID0gZXhwb3J0cy5jb25zID0gZnVuY3Rpb24gY29ucyhoZWFkLCB0YWlsKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdChoZWFkLCB0YWlsKTtcbiAgICB9O1xudmFyIHJldmVyc2VMaXN0ID0gZnVuY3Rpb24gcmV2ZXJzZUxpc3Qoc2VxdWVuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgdmFyIGl0ZW1zw7gxID0gW107XG4gICAgICAgIHZhciBzb3VyY2XDuDEgPSBzZXF1ZW5jZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSBpc0VtcHR5KHNvdXJjZcO4MSkgPyBsaXN0LmFwcGx5KHZvaWQgMCwgaXRlbXPDuDEpIDogKGxvb3BbMF0gPSBbZmlyc3Qoc291cmNlw7gxKV0uY29uY2F0KGl0ZW1zw7gxKSwgbG9vcFsxXSA9IHJlc3Qoc291cmNlw7gxKSwgbG9vcCk7XG4gICAgICAgIH0gd2hpbGUgKGl0ZW1zw7gxID0gbG9vcFswXSwgc291cmNlw7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBpc1NlcXVlbnRpYWwgPSBleHBvcnRzLmlzU2VxdWVudGlhbCA9IGZ1bmN0aW9uIGlzU2VxdWVudGlhbCh4KSB7XG4gICAgICAgIHJldHVybiBpc0xpc3QoeCkgfHwgaXNWZWN0b3IoeCkgfHwgaXNMYXp5U2VxKHgpIHx8IGlzRGljdGlvbmFyeSh4KSB8fCBpc1N0cmluZyh4KTtcbiAgICB9O1xudmFyIHJldmVyc2UgPSBleHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBpc0xpc3Qoc2VxdWVuY2UpID8gcmV2ZXJzZUxpc3Qoc2VxdWVuY2UpIDogaXNWZWN0b3Ioc2VxdWVuY2UpID8gc2VxdWVuY2UucmV2ZXJzZSgpIDogaXNOaWwoc2VxdWVuY2UpID8gbGlzdCgpIDogJ2Vsc2UnID8gcmV2ZXJzZShzZXEoc2VxdWVuY2UpKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIG1hcCA9IGV4cG9ydHMubWFwID0gZnVuY3Rpb24gbWFwKGYsIHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBpc1ZlY3RvcihzZXF1ZW5jZSkgPyBzZXF1ZW5jZS5tYXAoZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICByZXR1cm4gZigkMSk7XG4gICAgICAgIH0pIDogaXNMaXN0KHNlcXVlbmNlKSA/IG1hcExpc3QoZiwgc2VxdWVuY2UpIDogaXNOaWwoc2VxdWVuY2UpID8gbGlzdCgpIDogJ2Vsc2UnID8gbWFwKGYsIHNlcShzZXF1ZW5jZSkpIDogdm9pZCAwO1xuICAgIH07XG52YXIgbWFwTGlzdCA9IGZ1bmN0aW9uIG1hcExpc3QoZiwgc2VxdWVuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgdmFyIHJlc3VsdMO4MSA9IGxpc3QoKTtcbiAgICAgICAgdmFyIGl0ZW1zw7gxID0gc2VxdWVuY2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlY3VyID0gaXNFbXB0eShpdGVtc8O4MSkgPyByZXZlcnNlKHJlc3VsdMO4MSkgOiAobG9vcFswXSA9IGNvbnMoZihmaXJzdChpdGVtc8O4MSkpLCByZXN1bHTDuDEpLCBsb29wWzFdID0gcmVzdChpdGVtc8O4MSksIGxvb3ApO1xuICAgICAgICB9IHdoaWxlIChyZXN1bHTDuDEgPSBsb29wWzBdLCBpdGVtc8O4MSA9IGxvb3BbMV0sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgIH0uY2FsbCh0aGlzKTtcbn07XG52YXIgZmlsdGVyID0gZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoaXNGLCBzZXF1ZW5jZSkge1xuICAgICAgICByZXR1cm4gaXNWZWN0b3Ioc2VxdWVuY2UpID8gc2VxdWVuY2UuZmlsdGVyKGlzRikgOiBpc0xpc3Qoc2VxdWVuY2UpID8gZmlsdGVyTGlzdChpc0YsIHNlcXVlbmNlKSA6IGlzTmlsKHNlcXVlbmNlKSA/IGxpc3QoKSA6ICdlbHNlJyA/IGZpbHRlcihpc0YsIHNlcShzZXF1ZW5jZSkpIDogdm9pZCAwO1xuICAgIH07XG52YXIgZmlsdGVyTGlzdCA9IGZ1bmN0aW9uIGZpbHRlckxpc3QoaXNGLCBzZXF1ZW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICB2YXIgcmVzdWx0w7gxID0gbGlzdCgpO1xuICAgICAgICB2YXIgaXRlbXPDuDEgPSBzZXF1ZW5jZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSBpc0VtcHR5KGl0ZW1zw7gxKSA/IHJldmVyc2UocmVzdWx0w7gxKSA6IChsb29wWzBdID0gaXNGKGZpcnN0KGl0ZW1zw7gxKSkgPyBjb25zKGZpcnN0KGl0ZW1zw7gxKSwgcmVzdWx0w7gxKSA6IHJlc3VsdMO4MSwgbG9vcFsxXSA9IHJlc3QoaXRlbXPDuDEpLCBsb29wKTtcbiAgICAgICAgfSB3aGlsZSAocmVzdWx0w7gxID0gbG9vcFswXSwgaXRlbXPDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgIHJldHVybiByZWN1cjtcbiAgICB9LmNhbGwodGhpcyk7XG59O1xudmFyIHJlZHVjZSA9IGV4cG9ydHMucmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGYpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFzSW5pdGlhbMO4MSA9IGNvdW50KHBhcmFtcykgPj0gMjtcbiAgICAgICAgICAgIHZhciBpbml0aWFsw7gxID0gaGFzSW5pdGlhbMO4MSA/IGZpcnN0KHBhcmFtcykgOiB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgc2VxdWVuY2XDuDEgPSBoYXNJbml0aWFsw7gxID8gc2Vjb25kKHBhcmFtcykgOiBmaXJzdChwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmlsKHNlcXVlbmNlw7gxKSA/IGluaXRpYWzDuDEgOiBpc1ZlY3RvcihzZXF1ZW5jZcO4MSkgPyBoYXNJbml0aWFsw7gxID8gc2VxdWVuY2XDuDEucmVkdWNlKGYsIGluaXRpYWzDuDEpIDogc2VxdWVuY2XDuDEucmVkdWNlKGYpIDogaXNMaXN0KHNlcXVlbmNlw7gxKSA/IGhhc0luaXRpYWzDuDEgPyByZWR1Y2VMaXN0KGYsIGluaXRpYWzDuDEsIHNlcXVlbmNlw7gxKSA6IHJlZHVjZUxpc3QoZiwgZmlyc3Qoc2VxdWVuY2XDuDEpLCByZXN0KHNlcXVlbmNlw7gxKSkgOiAnZWxzZScgPyByZWR1Y2UoZiwgaW5pdGlhbMO4MSwgc2VxKHNlcXVlbmNlw7gxKSkgOiB2b2lkIDA7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICB9O1xudmFyIHJlZHVjZUxpc3QgPSBmdW5jdGlvbiByZWR1Y2VMaXN0KGYsIGluaXRpYWwsIHNlcXVlbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgIHZhciByZXN1bHTDuDEgPSBpbml0aWFsO1xuICAgICAgICB2YXIgaXRlbXPDuDEgPSBzZXF1ZW5jZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSBpc0VtcHR5KGl0ZW1zw7gxKSA/IHJlc3VsdMO4MSA6IChsb29wWzBdID0gZihyZXN1bHTDuDEsIGZpcnN0KGl0ZW1zw7gxKSksIGxvb3BbMV0gPSByZXN0KGl0ZW1zw7gxKSwgbG9vcCk7XG4gICAgICAgIH0gd2hpbGUgKHJlc3VsdMO4MSA9IGxvb3BbMF0sIGl0ZW1zw7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBjb3VudCA9IGV4cG9ydHMuY291bnQgPSBmdW5jdGlvbiBjb3VudChzZXF1ZW5jZSkge1xuICAgICAgICByZXR1cm4gaXNOaWwoc2VxdWVuY2UpID8gMCA6IHNlcShzZXF1ZW5jZSkubGVuZ3RoO1xuICAgIH07XG52YXIgaXNFbXB0eSA9IGV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoc2VxdWVuY2UpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50KHNlcXVlbmNlKSA9PT0gMDtcbiAgICB9O1xudmFyIGZpcnN0ID0gZXhwb3J0cy5maXJzdCA9IGZ1bmN0aW9uIGZpcnN0KHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBpc05pbChzZXF1ZW5jZSkgPyB2b2lkIDAgOiBpc0xpc3Qoc2VxdWVuY2UpID8gc2VxdWVuY2UuaGVhZCA6IGlzVmVjdG9yKHNlcXVlbmNlKSB8fCBpc1N0cmluZyhzZXF1ZW5jZSkgPyAoc2VxdWVuY2UgfHwgMClbMF0gOiBpc0xhenlTZXEoc2VxdWVuY2UpID8gZmlyc3QobGF6eVNlcVZhbHVlKHNlcXVlbmNlKSkgOiAnZWxzZScgPyBmaXJzdChzZXEoc2VxdWVuY2UpKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIHNlY29uZCA9IGV4cG9ydHMuc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBpc05pbChzZXF1ZW5jZSkgPyB2b2lkIDAgOiBpc0xpc3Qoc2VxdWVuY2UpID8gZmlyc3QocmVzdChzZXF1ZW5jZSkpIDogaXNWZWN0b3Ioc2VxdWVuY2UpIHx8IGlzU3RyaW5nKHNlcXVlbmNlKSA/IChzZXF1ZW5jZSB8fCAwKVsxXSA6IGlzTGF6eVNlcShzZXF1ZW5jZSkgPyBzZWNvbmQobGF6eVNlcVZhbHVlKHNlcXVlbmNlKSkgOiAnZWxzZScgPyBmaXJzdChyZXN0KHNlcShzZXF1ZW5jZSkpKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIHRoaXJkID0gZXhwb3J0cy50aGlyZCA9IGZ1bmN0aW9uIHRoaXJkKHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBpc05pbChzZXF1ZW5jZSkgPyB2b2lkIDAgOiBpc0xpc3Qoc2VxdWVuY2UpID8gZmlyc3QocmVzdChyZXN0KHNlcXVlbmNlKSkpIDogaXNWZWN0b3Ioc2VxdWVuY2UpIHx8IGlzU3RyaW5nKHNlcXVlbmNlKSA/IChzZXF1ZW5jZSB8fCAwKVsyXSA6IGlzTGF6eVNlcShzZXF1ZW5jZSkgPyB0aGlyZChsYXp5U2VxVmFsdWUoc2VxdWVuY2UpKSA6ICdlbHNlJyA/IHNlY29uZChyZXN0KHNlcShzZXF1ZW5jZSkpKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIHJlc3QgPSBleHBvcnRzLnJlc3QgPSBmdW5jdGlvbiByZXN0KHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBpc05pbChzZXF1ZW5jZSkgPyBsaXN0KCkgOiBpc0xpc3Qoc2VxdWVuY2UpID8gc2VxdWVuY2UudGFpbCA6IGlzVmVjdG9yKHNlcXVlbmNlKSB8fCBpc1N0cmluZyhzZXF1ZW5jZSkgPyBzZXF1ZW5jZS5zbGljZSgxKSA6IGlzTGF6eVNlcShzZXF1ZW5jZSkgPyByZXN0KGxhenlTZXFWYWx1ZShzZXF1ZW5jZSkpIDogJ2Vsc2UnID8gcmVzdChzZXEoc2VxdWVuY2UpKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIGxhc3RPZkxpc3QgPSBmdW5jdGlvbiBsYXN0T2ZMaXN0KGxpc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgdmFyIGl0ZW3DuDEgPSBmaXJzdChsaXN0KTtcbiAgICAgICAgdmFyIGl0ZW1zw7gxID0gcmVzdChsaXN0KTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSBpc0VtcHR5KGl0ZW1zw7gxKSA/IGl0ZW3DuDEgOiAobG9vcFswXSA9IGZpcnN0KGl0ZW1zw7gxKSwgbG9vcFsxXSA9IHJlc3QoaXRlbXPDuDEpLCBsb29wKTtcbiAgICAgICAgfSB3aGlsZSAoaXRlbcO4MSA9IGxvb3BbMF0sIGl0ZW1zw7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBsYXN0ID0gZXhwb3J0cy5sYXN0ID0gZnVuY3Rpb24gbGFzdChzZXF1ZW5jZSkge1xuICAgICAgICByZXR1cm4gaXNWZWN0b3Ioc2VxdWVuY2UpIHx8IGlzU3RyaW5nKHNlcXVlbmNlKSA/IChzZXF1ZW5jZSB8fCAwKVtkZWMoY291bnQoc2VxdWVuY2UpKV0gOiBpc0xpc3Qoc2VxdWVuY2UpID8gbGFzdE9mTGlzdChzZXF1ZW5jZSkgOiBpc05pbChzZXF1ZW5jZSkgPyB2b2lkIDAgOiBpc0xhenlTZXEoc2VxdWVuY2UpID8gbGFzdChsYXp5U2VxVmFsdWUoc2VxdWVuY2UpKSA6ICdlbHNlJyA/IGxhc3Qoc2VxKHNlcXVlbmNlKSkgOiB2b2lkIDA7XG4gICAgfTtcbnZhciBidXRsYXN0ID0gZXhwb3J0cy5idXRsYXN0ID0gZnVuY3Rpb24gYnV0bGFzdChzZXF1ZW5jZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zw7gxID0gaXNOaWwoc2VxdWVuY2UpID8gdm9pZCAwIDogaXNTdHJpbmcoc2VxdWVuY2UpID8gc3VicyhzZXF1ZW5jZSwgMCwgZGVjKGNvdW50KHNlcXVlbmNlKSkpIDogaXNWZWN0b3Ioc2VxdWVuY2UpID8gc2VxdWVuY2Uuc2xpY2UoMCwgZGVjKGNvdW50KHNlcXVlbmNlKSkpIDogaXNMaXN0KHNlcXVlbmNlKSA/IGxpc3QuYXBwbHkodm9pZCAwLCBidXRsYXN0KHZlYyhzZXF1ZW5jZSkpKSA6IGlzTGF6eVNlcShzZXF1ZW5jZSkgPyBidXRsYXN0KGxhenlTZXFWYWx1ZShzZXF1ZW5jZSkpIDogJ2Vsc2UnID8gYnV0bGFzdChzZXEoc2VxdWVuY2UpKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiAhKGlzTmlsKGl0ZW1zw7gxKSB8fCBpc0VtcHR5KGl0ZW1zw7gxKSkgPyBpdGVtc8O4MSA6IHZvaWQgMDtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgdGFrZSA9IGV4cG9ydHMudGFrZSA9IGZ1bmN0aW9uIHRha2Uobiwgc2VxdWVuY2UpIHtcbiAgICAgICAgcmV0dXJuIGlzTmlsKHNlcXVlbmNlKSA/IGxpc3QoKSA6IGlzVmVjdG9yKHNlcXVlbmNlKSA/IHRha2VGcm9tVmVjdG9yKG4sIHNlcXVlbmNlKSA6IGlzTGlzdChzZXF1ZW5jZSkgPyB0YWtlRnJvbUxpc3Qobiwgc2VxdWVuY2UpIDogaXNMYXp5U2VxKHNlcXVlbmNlKSA/IHRha2UobiwgbGF6eVNlcVZhbHVlKHNlcXVlbmNlKSkgOiAnZWxzZScgPyB0YWtlKG4sIHNlcShzZXF1ZW5jZSkpIDogdm9pZCAwO1xuICAgIH07XG52YXIgdGFrZVZlY3RvcldoaWxlID0gZnVuY3Rpb24gdGFrZVZlY3RvcldoaWxlKHByZWRpY2F0ZSwgdmVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgIHZhciByZXN1bHTDuDEgPSBbXTtcbiAgICAgICAgdmFyIHRhaWzDuDEgPSB2ZWN0b3I7XG4gICAgICAgIHZhciBoZWFkw7gxID0gZmlyc3QodmVjdG9yKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSAhaXNFbXB0eSh0YWlsw7gxKSAmJiBwcmVkaWNhdGUoaGVhZMO4MSkgPyAobG9vcFswXSA9IGNvbmoocmVzdWx0w7gxLCBoZWFkw7gxKSwgbG9vcFsxXSA9IHJlc3QodGFpbMO4MSksIGxvb3BbMl0gPSBmaXJzdCh0YWlsw7gxKSwgbG9vcCkgOiByZXN1bHTDuDE7XG4gICAgICAgIH0gd2hpbGUgKHJlc3VsdMO4MSA9IGxvb3BbMF0sIHRhaWzDuDEgPSBsb29wWzFdLCBoZWFkw7gxID0gbG9vcFsyXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciB0YWtlTGlzdFdoaWxlID0gZnVuY3Rpb24gdGFrZUxpc3RXaGlsZShwcmVkaWNhdGUsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgIHZhciByZXN1bHTDuDEgPSBbXTtcbiAgICAgICAgdmFyIHRhaWzDuDEgPSBpdGVtcztcbiAgICAgICAgdmFyIGhlYWTDuDEgPSBmaXJzdChpdGVtcyk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlY3VyID0gIWlzRW1wdHkodGFpbMO4MSkgJiYgaXNQcmVkaWNhdGUoaGVhZMO4MSkgPyAobG9vcFswXSA9IGNvbmoocmVzdWx0w7gxLCBoZWFkw7gxKSwgbG9vcFsxXSA9IHJlc3QodGFpbMO4MSksIGxvb3BbMl0gPSBmaXJzdCh0YWlsw7gxKSwgbG9vcCkgOiBsaXN0LmFwcGx5KHZvaWQgMCwgcmVzdWx0w7gxKTtcbiAgICAgICAgfSB3aGlsZSAocmVzdWx0w7gxID0gbG9vcFswXSwgdGFpbMO4MSA9IGxvb3BbMV0sIGhlYWTDuDEgPSBsb29wWzJdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgIHJldHVybiByZWN1cjtcbiAgICB9LmNhbGwodGhpcyk7XG59O1xudmFyIHRha2VXaGlsZSA9IGV4cG9ydHMudGFrZVdoaWxlID0gZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgc2VxdWVuY2UpIHtcbiAgICAgICAgcmV0dXJuIGlzTmlsKHNlcXVlbmNlKSA/IGxpc3QoKSA6IGlzVmVjdG9yKHNlcXVlbmNlKSA/IHRha2VWZWN0b3JXaGlsZShwcmVkaWNhdGUsIHNlcXVlbmNlKSA6IGlzTGlzdChzZXF1ZW5jZSkgPyB0YWtlVmVjdG9yV2hpbGUocHJlZGljYXRlLCBzZXF1ZW5jZSkgOiAnZWxzZScgPyB0YWtlV2hpbGUocHJlZGljYXRlLCBsYXp5U2VxVmFsdWUoc2VxdWVuY2UpKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIHRha2VGcm9tVmVjdG9yID0gZnVuY3Rpb24gdGFrZUZyb21WZWN0b3IobiwgdmVjdG9yKSB7XG4gICAgcmV0dXJuIHZlY3Rvci5zbGljZSgwLCBuKTtcbn07XG52YXIgdGFrZUZyb21MaXN0ID0gZnVuY3Rpb24gdGFrZUZyb21MaXN0KG4sIHNlcXVlbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgIHZhciB0YWtlbsO4MSA9IGxpc3QoKTtcbiAgICAgICAgdmFyIGl0ZW1zw7gxID0gc2VxdWVuY2U7XG4gICAgICAgIHZhciBuw7gyID0gbjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSBuw7gyID09PSAwIHx8IGlzRW1wdHkoaXRlbXPDuDEpID8gcmV2ZXJzZSh0YWtlbsO4MSkgOiAobG9vcFswXSA9IGNvbnMoZmlyc3QoaXRlbXPDuDEpLCB0YWtlbsO4MSksIGxvb3BbMV0gPSByZXN0KGl0ZW1zw7gxKSwgbG9vcFsyXSA9IGRlYyhuw7gyKSwgbG9vcCk7XG4gICAgICAgIH0gd2hpbGUgKHRha2Vuw7gxID0gbG9vcFswXSwgaXRlbXPDuDEgPSBsb29wWzFdLCBuw7gyID0gbG9vcFsyXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgfS5jYWxsKHRoaXMpO1xufTtcbnZhciBkcm9wRnJvbUxpc3QgPSBmdW5jdGlvbiBkcm9wRnJvbUxpc3Qobiwgc2VxdWVuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgdmFyIGxlZnTDuDEgPSBuO1xuICAgICAgICB2YXIgaXRlbXPDuDEgPSBzZXF1ZW5jZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVjdXIgPSBsZWZ0w7gxIDwgMSB8fCBpc0VtcHR5KGl0ZW1zw7gxKSA/IGl0ZW1zw7gxIDogKGxvb3BbMF0gPSBkZWMobGVmdMO4MSksIGxvb3BbMV0gPSByZXN0KGl0ZW1zw7gxKSwgbG9vcCk7XG4gICAgICAgIH0gd2hpbGUgKGxlZnTDuDEgPSBsb29wWzBdLCBpdGVtc8O4MSA9IGxvb3BbMV0sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgIH0uY2FsbCh0aGlzKTtcbn07XG52YXIgZHJvcCA9IGV4cG9ydHMuZHJvcCA9IGZ1bmN0aW9uIGRyb3Aobiwgc2VxdWVuY2UpIHtcbiAgICAgICAgcmV0dXJuIG4gPD0gMCA/IHNlcXVlbmNlIDogaXNTdHJpbmcoc2VxdWVuY2UpID8gc2VxdWVuY2Uuc3Vic3RyKG4pIDogaXNWZWN0b3Ioc2VxdWVuY2UpID8gc2VxdWVuY2Uuc2xpY2UobikgOiBpc0xpc3Qoc2VxdWVuY2UpID8gZHJvcEZyb21MaXN0KG4sIHNlcXVlbmNlKSA6IGlzTmlsKHNlcXVlbmNlKSA/IGxpc3QoKSA6IGlzTGF6eVNlcShzZXF1ZW5jZSkgPyBkcm9wKG4sIGxhenlTZXFWYWx1ZShzZXF1ZW5jZSkpIDogJ2Vsc2UnID8gZHJvcChuLCBzZXEoc2VxdWVuY2UpKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIGNvbmpMaXN0ID0gZnVuY3Rpb24gY29uakxpc3Qoc2VxdWVuY2UsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBjb25zKGl0ZW0sIHJlc3VsdCk7XG4gICAgfSwgc2VxdWVuY2UsIGl0ZW1zKTtcbn07XG52YXIgY29uaiA9IGV4cG9ydHMuY29uaiA9IGZ1bmN0aW9uIGNvbmooc2VxdWVuY2UpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGlzVmVjdG9yKHNlcXVlbmNlKSA/IHNlcXVlbmNlLmNvbmNhdChpdGVtcykgOiBpc1N0cmluZyhzZXF1ZW5jZSkgPyAnJyArIHNlcXVlbmNlICsgc3RyLmFwcGx5KHZvaWQgMCwgaXRlbXMpIDogaXNOaWwoc2VxdWVuY2UpID8gbGlzdC5hcHBseSh2b2lkIDAsIHJldmVyc2UoaXRlbXMpKSA6IGlzTGlzdChzZXF1ZW5jZSkgfHwgaXNMYXp5U2VxKCkgPyBjb25qTGlzdChzZXF1ZW5jZSwgaXRlbXMpIDogaXNEaWN0aW9uYXJ5KHNlcXVlbmNlKSA/IG1lcmdlKHNlcXVlbmNlLCBtZXJnZS5hcHBseSh2b2lkIDAsIGl0ZW1zKSkgOiAnZWxzZScgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcnICsgJ1R5cGUgY2FuXFwndCBiZSBjb25qb2luZWQgJyArIHNlcXVlbmNlKTtcbiAgICAgICAgfSkoKSA6IHZvaWQgMDtcbiAgICB9O1xudmFyIGFzc29jID0gZXhwb3J0cy5hc3NvYyA9IGZ1bmN0aW9uIGFzc29jKHNvdXJjZSkge1xuICAgICAgICB2YXIga2V5VmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGNvbmooc291cmNlLCBkaWN0aW9uYXJ5LmFwcGx5KHZvaWQgMCwga2V5VmFsdWVzKSk7XG4gICAgfTtcbnZhciBjb25jYXQgPSBleHBvcnRzLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgICAgdmFyIHNlcXVlbmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHJldHVybiByZXZlcnNlKHJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBzZXF1ZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnMoaXRlbSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0sIHJlc3VsdCwgc2VxKHNlcXVlbmNlKSk7XG4gICAgICAgIH0sIGxpc3QoKSwgc2VxdWVuY2VzKSk7XG4gICAgfTtcbnZhciBzZXEgPSBleHBvcnRzLnNlcSA9IGZ1bmN0aW9uIHNlcShzZXF1ZW5jZSkge1xuICAgICAgICByZXR1cm4gaXNOaWwoc2VxdWVuY2UpID8gdm9pZCAwIDogaXNWZWN0b3Ioc2VxdWVuY2UpIHx8IGlzTGlzdChzZXF1ZW5jZSkgfHwgaXNMYXp5U2VxKHNlcXVlbmNlKSA/IHNlcXVlbmNlIDogaXNTdHJpbmcoc2VxdWVuY2UpID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2VxdWVuY2UpIDogaXNEaWN0aW9uYXJ5KHNlcXVlbmNlKSA/IGtleVZhbHVlcyhzZXF1ZW5jZSkgOiAnZGVmYXVsdCcgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcnICsgJ0NhbiBub3Qgc2VxICcgKyBzZXF1ZW5jZSk7XG4gICAgICAgIH0pKCkgOiB2b2lkIDA7XG4gICAgfTtcbnZhciBpc1NlcSA9IGV4cG9ydHMuaXNTZXEgPSBmdW5jdGlvbiBpc1NlcShzZXF1ZW5jZSkge1xuICAgICAgICByZXR1cm4gaXNMaXN0KHNlcXVlbmNlKSB8fCBpc0xhenlTZXEoc2VxdWVuY2UpO1xuICAgIH07XG52YXIgbGlzdFRvVmVjdG9yID0gZnVuY3Rpb24gbGlzdFRvVmVjdG9yKHNvdXJjZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICB2YXIgcmVjdXIgPSBsb29wO1xuICAgICAgICB2YXIgcmVzdWx0w7gxID0gW107XG4gICAgICAgIHZhciBsaXN0w7gxID0gc291cmNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZWN1ciA9IGlzRW1wdHkobGlzdMO4MSkgPyByZXN1bHTDuDEgOiAobG9vcFswXSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0w7gxLnB1c2goZmlyc3QobGlzdMO4MSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHTDuDE7XG4gICAgICAgICAgICB9KSgpLCBsb29wWzFdID0gcmVzdChsaXN0w7gxKSwgbG9vcCk7XG4gICAgICAgIH0gd2hpbGUgKHJlc3VsdMO4MSA9IGxvb3BbMF0sIGxpc3TDuDEgPSBsb29wWzFdLCByZWN1ciA9PT0gbG9vcCk7XG4gICAgICAgIHJldHVybiByZWN1cjtcbiAgICB9LmNhbGwodGhpcyk7XG59O1xudmFyIHZlYyA9IGV4cG9ydHMudmVjID0gZnVuY3Rpb24gdmVjKHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBpc05pbChzZXF1ZW5jZSkgPyBbXSA6IGlzVmVjdG9yKHNlcXVlbmNlKSA/IHNlcXVlbmNlIDogaXNMaXN0KHNlcXVlbmNlKSA/IGxpc3RUb1ZlY3RvcihzZXF1ZW5jZSkgOiAnZWxzZScgPyB2ZWMoc2VxKHNlcXVlbmNlKSkgOiB2b2lkIDA7XG4gICAgfTtcbnZhciBzb3J0ID0gZXhwb3J0cy5zb3J0ID0gZnVuY3Rpb24gc29ydChmLCBpdGVtcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhhc0NvbXBhcmF0b3LDuDEgPSBpc0ZuKGYpO1xuICAgICAgICAgICAgdmFyIGl0ZW1zw7gyID0gIWhhc0NvbXBhcmF0b3LDuDEgJiYgaXNOaWwoaXRlbXMpID8gZiA6IGl0ZW1zO1xuICAgICAgICAgICAgdmFyIGNvbXBhcmXDuDEgPSBoYXNDb21wYXJhdG9yw7gxID8gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYoYSwgYikgPyAwIDogMTtcbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmlsKGl0ZW1zw7gyKSA/IGxpc3QoKSA6IGlzVmVjdG9yKGl0ZW1zw7gyKSA/IGl0ZW1zw7gyLnNvcnQoY29tcGFyZcO4MSkgOiBpc0xpc3QoaXRlbXPDuDIpID8gbGlzdC5hcHBseSh2b2lkIDAsIHZlYyhpdGVtc8O4Mikuc29ydChjb21wYXJlw7gxKSkgOiBpc0RpY3Rpb25hcnkoaXRlbXPDuDIpID8gc2VxKGl0ZW1zw7gyKS5zb3J0KGNvbXBhcmXDuDEpIDogJ2Vsc2UnID8gc29ydChmLCBzZXEoaXRlbXPDuDIpKSA6IHZvaWQgMDtcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgIH07XG52YXIgcmVwZWF0ID0gZXhwb3J0cy5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQobiwgeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgbsO4MiA9IG47XG4gICAgICAgICAgICB2YXIgcmVzdWx0w7gxID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVjdXIgPSBuw7gyIDw9IDAgPyByZXN1bHTDuDEgOiAobG9vcFswXSA9IGRlYyhuw7gyKSwgbG9vcFsxXSA9IGNvbmoocmVzdWx0w7gxLCB4KSwgbG9vcCk7XG4gICAgICAgICAgICB9IHdoaWxlIChuw7gyID0gbG9vcFswXSwgcmVzdWx0w7gxID0gbG9vcFsxXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBpc0V2ZXJ5ID0gZXhwb3J0cy5pc0V2ZXJ5ID0gZnVuY3Rpb24gaXNFdmVyeShwcmVkaWNhdGUsIHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiB2ZWMoc2VxdWVuY2UpLmV2ZXJ5KGZ1bmN0aW9uICgkMSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSgkMSk7XG4gICAgICAgIH0pO1xuICAgIH07XG52YXIgc29tZSA9IGV4cG9ydHMuc29tZSA9IGZ1bmN0aW9uIHNvbWUocHJlZGljYXRlLCBzZXF1ZW5jZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICB2YXIgaXRlbXPDuDEgPSBzZXF1ZW5jZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZWN1ciA9IGlzRW1wdHkoaXRlbXPDuDEpID8gZmFsc2UgOiBwcmVkaWNhdGUoZmlyc3QoaXRlbXPDuDEpKSA/IHRydWUgOiAnZWxzZScgPyAobG9vcFswXSA9IHJlc3QoaXRlbXPDuDEpLCBsb29wKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGl0ZW1zw7gxID0gbG9vcFswXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3VyO1xuICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgfTtcbnZhciBwYXJ0aXRpb24gPSBleHBvcnRzLnBhcnRpdGlvbiA9IGZ1bmN0aW9uIHBhcnRpdGlvbigpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciBuID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGNvbGwgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4gcGFydGl0aW9uKG4sIG4sIGNvbGwpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB2YXIgbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGNvbGwgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICByZXR1cm4gcGFydGl0aW9uKG4sIHN0ZXAsIFtdLCBjb2xsKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIG4gPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBwYWQgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgY29sbCA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdMO4MSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtc8O4MSA9IHNlcShjb2xsKTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rw7gxID0gdGFrZShuLCBpdGVtc8O4MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZcO4MSA9IGNvdW50KGNodW5rw7gxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplw7gxID09PSBuID8gKGxvb3BbMF0gPSBjb25qKHJlc3VsdMO4MSwgY2h1bmvDuDEpLCBsb29wWzFdID0gZHJvcChzdGVwLCBpdGVtc8O4MSksIGxvb3ApIDogMCA9PT0gc2l6ZcO4MSA/IHJlc3VsdMO4MSA6IG4gPiBzaXplw7gxICsgY291bnQocGFkKSA/IHJlc3VsdMO4MSA6ICdlbHNlJyA/IGNvbmoocmVzdWx0w7gxLCB0YWtlKG4sIHZlYyhjb25jYXQoY2h1bmvDuDEsIHBhZCkpKSkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChyZXN1bHTDuDEgPSBsb29wWzBdLCBpdGVtc8O4MSA9IGxvb3BbMV0sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbnZhciBpbnRlcmxlYXZlID0gZXhwb3J0cy5pbnRlcmxlYXZlID0gZnVuY3Rpb24gaW50ZXJsZWF2ZSgpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciBheCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBieCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWN1ciA9IGxvb3A7XG4gICAgICAgICAgICAgICAgdmFyIGN4w7gxID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGF4w7gyID0gYXg7XG4gICAgICAgICAgICAgICAgdmFyIGJ4w7gyID0gYng7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICByZWN1ciA9IGlzRW1wdHkoYXjDuDIpIHx8IGlzRW1wdHkoYnjDuDIpID8gc2VxKGN4w7gxKSA6IChsb29wWzBdID0gY29uaihjeMO4MSwgZmlyc3QoYXjDuDIpLCBmaXJzdChieMO4MikpLCBsb29wWzFdID0gcmVzdChheMO4MiksIGxvb3BbMl0gPSByZXN0KGJ4w7gyKSwgbG9vcCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3jDuDEgPSBsb29wWzBdLCBheMO4MiA9IGxvb3BbMV0sIGJ4w7gyID0gbG9vcFsyXSwgcmVjdXIgPT09IGxvb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cjtcbiAgICAgICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBzZXF1ZW5jZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VyID0gbG9vcDtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0w7gxID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHNlcXVlbmNlc8O4MiA9IHNlcXVlbmNlcztcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyID0gc29tZShpc0VtcHR5LCBzZXF1ZW5jZXPDuDIpID8gcmVzdWx0w7gxIDogKGxvb3BbMF0gPSBjb25jYXQocmVzdWx0w7gxLCBtYXAoZmlyc3QsIHNlcXVlbmNlc8O4MikpLCBsb29wWzFdID0gbWFwKHJlc3QsIHNlcXVlbmNlc8O4MiksIGxvb3ApO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHJlc3VsdMO4MSA9IGxvb3BbMF0sIHNlcXVlbmNlc8O4MiA9IGxvb3BbMV0sIHJlY3VyID09PSBsb29wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXI7XG4gICAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xudmFyIG50aCA9IGV4cG9ydHMubnRoID0gZnVuY3Rpb24gbnRoKHNlcXVlbmNlLCBpbmRleCwgbm90Rm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGlzTmlsKHNlcXVlbmNlKSA/IG5vdEZvdW5kIDogaXNMaXN0KHNlcXVlbmNlKSA/IGluZGV4IDwgY291bnQoc2VxdWVuY2UpID8gZmlyc3QoZHJvcChpbmRleCwgc2VxdWVuY2UpKSA6IG5vdEZvdW5kIDogaXNWZWN0b3Ioc2VxdWVuY2UpIHx8IGlzU3RyaW5nKHNlcXVlbmNlKSA/IGluZGV4IDwgY291bnQoc2VxdWVuY2UpID8gc2VxdWVuY2VbaW5kZXhdIDogbm90Rm91bmQgOiBpc0xhenlTZXEoc2VxdWVuY2UpID8gbnRoKGxhenlTZXFWYWx1ZShzZXF1ZW5jZSksIGluZGV4LCBub3RGb3VuZCkgOiAnZWxzZScgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlJyk7XG4gICAgICAgIH0pKCkgOiB2b2lkIDA7XG4gICAgfTsiLCJ7XG4gICAgdmFyIF9uc18gPSB7XG4gICAgICAgICAgICBpZDogJ3dpc3Auc3RyaW5nJyxcbiAgICAgICAgICAgIGRvYzogdm9pZCAwXG4gICAgICAgIH07XG4gICAgdmFyIHdpc3BfcnVudGltZSA9IHJlcXVpcmUoJy4vcnVudGltZScpO1xuICAgIHZhciBzdHIgPSB3aXNwX3J1bnRpbWUuc3RyO1xuICAgIHZhciBzdWJzID0gd2lzcF9ydW50aW1lLnN1YnM7XG4gICAgdmFyIHJlTWF0Y2hlcyA9IHdpc3BfcnVudGltZS5yZU1hdGNoZXM7XG4gICAgdmFyIGlzTmlsID0gd2lzcF9ydW50aW1lLmlzTmlsO1xuICAgIHZhciBpc1N0cmluZyA9IHdpc3BfcnVudGltZS5pc1N0cmluZztcbiAgICB2YXIgd2lzcF9zZXF1ZW5jZSA9IHJlcXVpcmUoJy4vc2VxdWVuY2UnKTtcbiAgICB2YXIgdmVjID0gd2lzcF9zZXF1ZW5jZS52ZWM7XG4gICAgdmFyIGlzRW1wdHkgPSB3aXNwX3NlcXVlbmNlLmlzRW1wdHk7XG59XG52YXIgc3BsaXQgPSBleHBvcnRzLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBwYXR0ZXJuLCBsaW1pdCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHBhdHRlcm4sIGxpbWl0KTtcbiAgICB9O1xudmFyIGpvaW4gPSBleHBvcnRzLmpvaW4gPSBmdW5jdGlvbiBqb2luKCkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdmFyIGNvbGwgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gc3RyLmFwcGx5KHZvaWQgMCwgdmVjKGNvbGwpKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBjb2xsID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHZlYyhjb2xsKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbnZhciB1cHBlckNhc2UgPSBleHBvcnRzLnVwcGVyQ2FzZSA9IGZ1bmN0aW9uIHVwcGVyQ2FzZShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy50b1VwcGVyQ2FzZSgpO1xuICAgIH07XG52YXIgdXBwZXJDYXNlID0gZXhwb3J0cy51cHBlckNhc2UgPSBmdW5jdGlvbiB1cHBlckNhc2Uoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcudG9VcHBlckNhc2UoKTtcbiAgICB9O1xudmFyIGxvd2VyQ2FzZSA9IGV4cG9ydHMubG93ZXJDYXNlID0gZnVuY3Rpb24gbG93ZXJDYXNlKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcbnZhciBjYXBpdGFsaXplID0gZXhwb3J0cy5jYXBpdGFsaXplID0gZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50KHN0cmluZykgPCAyID8gdXBwZXJDYXNlKHN0cmluZykgOiAnJyArIHVwcGVyQ2FzZShzdWJzKHMsIDAsIDEpKSArIGxvd2VyQ2FzZShzdWJzKHMsIDEpKTtcbiAgICB9O1xudmFyIHJlcGxhY2UgPSBleHBvcnRzLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0cmluZywgbWF0Y2gsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShtYXRjaCwgcmVwbGFjZW1lbnQpO1xuICAgIH07XG52YXIgX19MRUZUU1BBQ0VTX18gPSBleHBvcnRzLl9fTEVGVFNQQUNFU19fID0gL15cXHNcXHMqLztcbnZhciBfX1JJR0hUU1BBQ0VTX18gPSBleHBvcnRzLl9fUklHSFRTUEFDRVNfXyA9IC9cXHNcXHMqJC87XG52YXIgX19TUEFDRVNfXyA9IGV4cG9ydHMuX19TUEFDRVNfXyA9IC9eXFxzXFxzKiQvO1xudmFyIHRyaW1sID0gZXhwb3J0cy50cmltbCA9IGlzTmlsKCcnLnRyaW1MZWZ0KSA/IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9fTEVGVFNQQUNFU19fLCAnJyk7XG4gICAgfSA6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy50cmltTGVmdCgpO1xuICAgIH07XG52YXIgdHJpbXIgPSBleHBvcnRzLnRyaW1yID0gaXNOaWwoJycudHJpbVJpZ2h0KSA/IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9fUklHSFRTUEFDRVNfXywgJycpO1xuICAgIH0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcudHJpbVJpZ2h0KCk7XG4gICAgfTtcbnZhciB0cmltID0gZXhwb3J0cy50cmltID0gaXNOaWwoJycudHJpbSkgPyBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShfX0xFRlRTUEFDRVNfXykucmVwbGFjZShfX1JJR0hUU1BBQ0VTX18pO1xuICAgIH0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcudHJpbSgpO1xuICAgIH07XG52YXIgaXNCbGFuayA9IGV4cG9ydHMuaXNCbGFuayA9IGZ1bmN0aW9uIGlzQmxhbmsoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBpc05pbChzdHJpbmcpIHx8IGlzRW1wdHkoc3RyaW5nKSB8fCByZU1hdGNoZXMoX19TUEFDRVNfXywgc3RyaW5nKTtcbiAgICB9OyJdfQ==
;